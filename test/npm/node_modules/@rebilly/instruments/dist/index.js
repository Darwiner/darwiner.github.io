function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return (val) => !!map[val];
}
const hasOwnProperty$d = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
const isArray$7 = Array.isArray;
const isMap$2 = (val) => toTypeString(val) === "[object Map]";
const isString$1 = (val) => typeof val === "string";
const isSymbol$2 = (val) => typeof val === "symbol";
const isObject$b = (val) => val !== null && typeof val === "object";
const objectToString$2 = Object.prototype.toString;
const toTypeString = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const targetMap = /* @__PURE__ */ new WeakMap();
let trackOpBit = 1;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type2, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type2, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type2 === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$7(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type2) {
      case "add":
        if (!isArray$7(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$7(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$7(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$2)
);
const get$1 = /* @__PURE__ */ createGetter();
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$c(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$7(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$c;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$2(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$b(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$7(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$7(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$2(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$7(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$2(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type2) {
  return function(...args) {
    return type2 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$b(target)) {
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
const toReactive = (value) => isObject$b(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$b(value) ? readonly(value) : value;
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function isDOMElement(element) {
  return element instanceof Element || element instanceof Document;
}
const summaryLoaderHTML = `
  <div class="rebilly-instruments-summary-loader-total rebilly-instruments-loader-display-flex rebilly-instruments-loader-align-center rebilly-instruments-loader-justify-space-between">
    <div><p class="is-el-loading">Total</p></div>
    <p class="total is-el-loading">$99.99</p>
  </div>
`;
const methodsLoaderHTML = `
  <div class="rebilly-instruments-methods-loader">
    <div class="rebilly-instruments-loader-form-el is-el-loading"></div>
    <div class="rebilly-instruments-divider">
      <span class="rebilly-instruments-divider-label"><span class="is-el-loading">Divi</span></span>
    </div>
    <div class="rebilly-instruments-loader-display-flex rebilly-instruments-loader-justify-end">
      <div class="rebilly-instruments-methods-loader-card-icon is-el-loading"></div>
      <div class="rebilly-instruments-methods-loader-card-icon is-el-loading"></div>
    </div>
    <div class="rebilly-instruments-loader-form-el is-el-loading"></div>
    <div class="rebilly-instruments-methods-loader-form-fields">
      <div class="rebilly-instruments-loader-form-label"><small class="is-el-loading">Card holder name</small></div>
      <div class="rebilly-instruments-loader-form-el is-el-loading"></div>
    </div>
    <div class="rebilly-instruments-loader-form-el is-button">Continue</div> 
  </div>
`;
const loaderContainer = (padding = "0px") => `
  <div class="rebilly-instruments-loader is-active" style="padding: ${padding}"></div>
`;
const basicLoaderHTML = `
  <div class="rebilly-instruments-loader-spinner"></div>
`;
class Loader {
  constructor() {
    this.summary = [];
    this.form = [];
    this.modal = [];
    this.DOM = {
      loaderContainer,
      summaryLoaderHTML,
      methodsLoaderHTML,
      basicLoaderHTML
    };
  }
  addDOMElement({
    section = "form",
    el = null
  } = {}) {
    if (isDOMElement(el) && el) {
      el.style.position = "relative";
      this.DOM[section] = el;
    }
  }
  startLoading({ section = "form", id: id2 = "" } = {}) {
    var _a, _b, _c;
    this[section].push(id2);
    const rootEl = ((_a = state.shadowRoot) == null ? void 0 : _a.querySelector("style")) || document.querySelector(":root");
    const contentPadding = 2;
    let minHeight = "240px";
    if ((_b = this.DOM) == null ? void 0 : _b[section]) {
      let loaderEl = this.DOM[section].querySelector(
        ".rebilly-instruments-loader"
      );
      const { padding, paddingTop, paddingBottom } = getComputedStyle(
        (_c = this.DOM) == null ? void 0 : _c[section]
      );
      if (!loaderEl) {
        this.DOM[section].innerHTML = loaderContainer(
          `${parseFloat(padding) + contentPadding}px`
        );
        loaderEl = this.DOM[section].querySelector(
          ".rebilly-instruments-loader"
        );
        if (section === "form") {
          loaderEl.insertAdjacentHTML(
            "afterbegin",
            this.DOM.methodsLoaderHTML
          );
          if (rootEl) {
            minHeight = getComputedStyle(rootEl).getPropertyValue(
              "--rebilly-methodLoaderMinHeight"
            );
          }
        } else if (section === "summary") {
          loaderEl.insertAdjacentHTML(
            "afterbegin",
            this.DOM.summaryLoaderHTML
          );
          if (rootEl) {
            minHeight = getComputedStyle(rootEl).getPropertyValue(
              "--rebilly-summaryLoaderMinHeight"
            );
          }
        }
      } else {
        if (id2.includes("confirmation") || id2.includes("result") || id2.includes("modal")) {
          loaderEl.innerHTML = this.DOM.basicLoaderHTML;
        }
        loaderEl.classList.add("is-active");
      }
      this.DOM[section].style.minHeight = `calc(${minHeight} + ${paddingTop} + ${paddingBottom} + ${contentPadding * 2}px)`;
    }
  }
  stopLoading({ section = "form", id: id2 = "" } = {}) {
    const idIndex = this[section].indexOf(id2);
    if (idIndex !== -1) {
      this[section].splice(idIndex, 1);
    }
    if (this.DOM[section] && !this[section].length && this.DOM[section].querySelector(".rebilly-instruments-loader")) {
      this.DOM[section].querySelector(".rebilly-instruments-loader").classList.remove("is-active");
      this.DOM[section].style.minHeight = "";
    }
  }
  clearAll() {
    this.form.forEach((id2) => {
      this.stopLoading({ id: id2 });
    });
    if (this.summary) {
      this.summary.forEach((id2) => {
        this.stopLoading({ section: "summary", id: id2 });
      });
    }
    this.modal.forEach((id2) => {
      this.stopLoading({ section: "modal", id: id2 });
    });
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$5 = root$7.Symbol;
var _Symbol = Symbol$5;
var Symbol$4 = _Symbol;
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$6(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$6;
function isObject$a(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_1 = isObject$a;
var baseGetTag$5 = _baseGetTag, isObject$9 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$4(value) {
  if (!isObject$9(value)) {
    return false;
  }
  var tag = baseGetTag$5(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$4;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$3 = isFunction_1, isMasked = _isMasked, isObject$8 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$b = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$8(value) || isMasked(value)) {
    return false;
  }
  var pattern2 = isFunction$3(value) ? reIsNative : reIsHostCtor;
  return pattern2.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$5 = _root;
var Map$4 = getNative$6(root$5, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var getNative$4 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$2 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$2(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBuffer.exports);
var _cloneBufferExports = _cloneBuffer.exports;
var root$4 = _root;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
var Uint8Array$1 = _Uint8Array;
function cloneArrayBuffer$3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$3;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
function copyArray$2(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$2;
var isObject$7 = isObject_1;
var objectCreate = Object.create;
var baseCreate$1 = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$7(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$1;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var getPrototype$3 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$3;
var objectProto$8 = Object.prototype;
function isPrototype$3(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
var _isPrototype = isPrototype$3;
var baseCreate = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$2 = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$2(object) ? baseCreate(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$2;
function isObjectLike$8(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$4 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$7(value) && baseGetTag$4(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$6(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$2;
var isArray$6 = Array.isArray;
var isArray_1 = isArray$6;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction$2 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$4(value) {
  return value != null && isLength$1(value.length) && !isFunction$2(value);
}
var isArrayLike_1 = isArrayLike$4;
var isArrayLike$3 = isArrayLike_1, isObjectLike$5 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$5(value) && isArrayLike$3(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var isBuffer$4 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$4.exports;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$4, isBuffer$4.exports);
var isBufferExports = isBuffer$4.exports;
var baseGetTag$3 = _baseGetTag, getPrototype$1 = _getPrototype, isObjectLike$4 = isObjectLike_1;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$6 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$2(value) {
  if (!isObjectLike$4(value) || baseGetTag$3(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$2;
var baseGetTag$2 = _baseGetTag, isLength = isLength_1, isObjectLike$3 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$3(value) && isLength(value.length) && !!typedArrayTags[baseGetTag$2(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$3;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$2 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary$2(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var baseAssignValue$1 = _baseAssignValue, eq$1 = eq_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function assignValue$2(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$1(object, key, value);
  }
}
var _assignValue = assignValue$2;
var assignValue$1 = _assignValue, baseAssignValue = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue$1(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$2;
var baseTimes = _baseTimes, isArguments$1 = isArguments_1, isArray$5 = isArray_1, isBuffer$3 = isBufferExports, isIndex$1 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$5(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$3(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$1(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$6 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$6(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$2 = isArrayLike_1;
function keysIn$5(object) {
  return isArrayLike$2(object) ? arrayLikeKeys$1(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$5;
var copyObject$4 = _copyObject, keysIn$4 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject$4(value, keysIn$4(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer$1 = _cloneBufferExports, cloneTypedArray$1 = _cloneTypedArray, copyArray$1 = _copyArray, initCloneObject$1 = _initCloneObject, isArguments = isArguments_1, isArray$4 = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer$2 = isBufferExports, isFunction$1 = isFunction_1, isObject$5 = isObject_1, isPlainObject$1 = isPlainObject_1, isTypedArray$1 = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$4(srcValue), isBuff = !isArr && isBuffer$2(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$4(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray$1(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer$1(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray$1(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject$1(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$5(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject$1(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$1 = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$4 = isObject_1, keysIn$3 = keysIn_1, safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack$1());
    if (isObject$4(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn$3);
}
var _baseMerge = baseMerge$1;
function identity$2(value) {
  return value;
}
var identity_1 = identity$2;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax = Math.max;
function overRest$1(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$1 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$1 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject$3 = isObject_1;
function isIterateeCall$1(value, index2, object) {
  if (!isObject$3(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike$1(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
var baseRest = _baseRest, isIterateeCall = _isIterateeCall;
function createAssigner$1(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var baseMerge = _baseMerge, createAssigner = _createAssigner;
var merge$1 = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge$1;
const merge$2 = /* @__PURE__ */ getDefaultExportFromCjs(merge_1);
const en$2 = {
  summary: {
    subTotal: "Subtotal",
    discounts: "Discounts",
    taxes: "Taxes",
    shipping: "Shipping",
    total: "Total"
  },
  deposit: {
    goBack: "Choose another amount"
  },
  form: {
    expressCheckout: "Express checkout",
    or: "Or",
    popupOverlayText: "Click here to show popup window",
    andMore: "and more",
    error: {
      noPaymentMethods: "No payment methods available for this transaction, please contact support.",
      invoiceIsPaid: "The invoice has been fully paid.",
      invoiceIsVoid: "The invoice has been voided.",
      invoiceIsAbandoned: "The invoice has been abandoned.",
      invoiceIsRefunded: "The invoice has been refunded.",
      transactionIsCompleted: "The transaction is completed and cannot be updated.",
      payoutNotPending: "The payout request cannot be updated."
    },
    loaderMessages: {
      processingPayment: "Processing payment instrument."
    },
    bumpOffer: {
      title: "Yes, I want to upgrade!",
      startingAt: "Starting at {basePrice}"
    }
  },
  paymentMethods: {
    "payment-card": "Payment card",
    ach: "Bank account"
  }
};
const en$3 = {
  en: en$2
};
const es$1 = {
  summary: {
    subTotal: "Subtotal",
    discounts: "Descuentos",
    taxes: "Impuestos",
    shipping: "Envo",
    total: "Total"
  },
  deposit: {
    goBack: "Elija otro monto a depositar"
  },
  form: {
    expressCheckout: "Chequeo rpido",
    or: "O pague con",
    popupOverlayText: "Haga clic aqu para mostrar la ventana emergente",
    andMore: "y ms",
    error: {
      noPaymentMethods: "No hay mtodos de pago disponibles para esta transaccin, por favor, pngase en contacto con el servicio de asistencia.",
      invoiceIsPaid: "La factura ha sido completamente pagada.",
      invoiceIsVoid: "La factura ha sido anulada.",
      invoiceIsAbandoned: "La factura ha sido abandonada.",
      invoiceIsRefunded: "La factura ha reembolsada.",
      transactionIsCompleted: "La transaccin est finalizada y no se puede actualizar.",
      payoutNotPending: "La solicitud de pago no se puede actualizar."
    },
    loaderMessages: {
      processingPayment: "Procesamiento de instrumento de pago."
    },
    bumpOffer: {
      title: "S, me gustara actualizar!",
      startingAt: "A partir de {basePrice}"
    }
  },
  paymentMethods: {
    "payment-card": "Tarjeta de crdito",
    ach: "Cuenta bancaria"
  }
};
const es$2 = {
  es: es$1
};
function isLocales(locale, languages) {
  return !locale.includes("-") || Object.prototype.hasOwnProperty.call(languages, locale);
}
class Translate {
  constructor() {
    this.locale = "en";
    this.items = [];
    this.languages = { ...en$3, ...es$2 };
  }
  init(locale, messages) {
    const root2 = state.shadowRoot || document;
    this.items = Array.from(root2.querySelectorAll("[data-rebilly-i18n]"));
    this.locale = this.getLocale(locale);
    this.languages = merge$2({}, { ...en$3, ...es$2 }, messages);
  }
  translateItems() {
    const root2 = state.shadowRoot || document;
    this.items = Array.from(root2.querySelectorAll("[data-rebilly-i18n]"));
    if (this.locale in this.languages) {
      return this.items.forEach((item) => {
        const translate = this.getTranslation(
          item.dataset.rebillyI18n,
          this.languages[this.locale]
        );
        if (translate) {
          item.innerHTML = translate;
        }
      });
    }
    return false;
  }
  updateTranslationsToNewLocale(newLocale) {
    this.locale = newLocale;
    this.translateItems();
  }
  getLocale(locale = this.locale) {
    if (isLocales(locale, this.languages)) {
      return locale;
    }
    locale = locale.replace(/[-._]\w+$/gi, "");
    return this.getLocale(locale);
  }
  translateItem(item) {
    const locale = this.getLocale();
    return this.getTranslation(
      item.dataset.rebillyI18n,
      this.languages[locale]
    );
  }
  getTranslation(prop, lan = this.languages[this.locale]) {
    return prop.split(".").reduce(
      (acc, val) => acc == null ? void 0 : acc[val],
      lan
    );
  }
}
const iframes = (/* @__PURE__ */ (() => {
  let state2 = null;
  return {
    getInstance() {
      if (state2 === null) {
        state2 = {
          form: null,
          summary: null,
          hasFrame(name) {
            if ((state2 == null ? void 0 : state2[name]) && !name.match(/^has.*/)) {
              return Boolean(state2[name]);
            }
            return false;
          },
          hasComponent(name) {
            var _a;
            return Boolean((_a = state2 == null ? void 0 : state2[name]) == null ? void 0 : _a.component);
          }
        };
      }
      return state2;
    }
  };
})()).getInstance();
function validateStorefront(storefront) {
  if (storefront == null) {
    throw new Error("Could not access rebilly-js-sdk instance");
  }
}
function validateOptions$1(options) {
  if (options == null) {
    throw new Error(
      "Could not use Rebilly Instruments mount options to fetch Rebilly data"
    );
  }
}
function validateData(data) {
  if (data == null) {
    throw new Error("Could not access data instance");
  }
}
const state = (() => {
  let state2 = null;
  const defaultState = {
    options: null,
    data: {},
    mainStyleVars: null,
    storefront: null,
    form: null,
    summary: null,
    loader: new Loader(),
    translate: new Translate(),
    hasMounted: false,
    shadowRoot: null,
    toModel() {
      var _a;
      const model = {
        ...state2,
        data: ((_a = state2 == null ? void 0 : state2.data) == null ? void 0 : _a.toPostmatesModel) ? state2.data.toPostmatesModel() : {}
      };
      delete model.toModel;
      delete model.updateModel;
      delete model.reset;
      delete model.shadowRoot;
      return JSON.parse(JSON.stringify(model));
    },
    updateModel() {
      var _a, _b;
      const modelSafeState = state2 == null ? void 0 : state2.toModel();
      if (modelSafeState) {
        const updateModel = {
          data: modelSafeState.data,
          options: modelSafeState.options
        };
        if (iframes.hasComponent("summary")) {
          (_a = iframes.summary) == null ? void 0 : _a.component.call("update", updateModel);
        }
        if (iframes.hasComponent("form")) {
          (_b = iframes.form) == null ? void 0 : _b.component.call("update", updateModel);
        }
      }
    },
    reset() {
      if (state2 !== null) {
        state2 = reactive({ ...defaultState });
      }
    }
  };
  return {
    getInstance() {
      if (state2 === null) {
        state2 = reactive({ ...defaultState });
      }
      return state2;
    }
  };
})().getInstance();
/**
  popostmate - A powerful, simple, promise-based postMessage library
  @version v2.0.0
  @link https://github.com/vpopolin/postmate
  @author Jacob Kelley <jakie8@gmail.com>
  @license MIT
**/
var messageType = "application/x-postmate-v1+json";
var _messageId = 0;
var generateNewMessageId = function generateNewMessageId2() {
  return ++_messageId;
};
var _childId = 0;
function childId() {
  return ++_childId;
}
var resolveOrigin = function resolveOrigin2(url) {
  var a = document.createElement("a");
  a.href = url;
  var protocol = a.protocol.length > 4 ? a.protocol : window.location.protocol;
  var host = a.host.length ? a.port === "80" || a.port === "443" ? a.hostname : a.host : window.location.host;
  return a.origin || protocol + "//" + host;
};
var messageTypes = {
  handshake: 1,
  "handshake-reply": 1,
  call: 1,
  emit: 1,
  reply: 1,
  request: 1
};
var sanitize$1 = function sanitize(message, allowedOrigin) {
  if (typeof allowedOrigin === "string" && message.origin !== allowedOrigin) return false;
  if (!message.data) return false;
  if (typeof message.data === "object" && !("postmate" in message.data)) return false;
  if (message.data.type !== messageType) return false;
  if (!messageTypes[message.data.postmate]) return false;
  return true;
};
var SanitizeLogger = function SanitizeLogger2(logger) {
  var loggerMethods = ["debug", "error"];
  loggerMethods.forEach(function(methodName) {
    if (logger[methodName] === void 0 || typeof logger[methodName] !== "function") {
      logger[methodName] = function emptyMethod() {
      };
    }
  });
  return logger;
};
var resolveValue = function resolveValue2(model, property) {
  var unwrappedContext = typeof model[property] === "function" ? model[property]() : model[property];
  return Postmate.Promise.resolve(unwrappedContext);
};
var ParentAPI = /* @__PURE__ */ function() {
  function ParentAPI2(info) {
    var _this = this;
    this.parent = info.parent;
    this.frame = info.frame;
    this.child = info.child;
    this.childOrigin = info.childOrigin;
    this.childId = info.childId;
    this.logger = info.logger;
    this.events = {};
    this.logger.debug("Parent: Registering API");
    this.logger.debug("Parent: Awaiting messages...");
    this.listener = function(e2) {
      if (!sanitize$1(e2, _this.childOrigin)) return false;
      var _ref = ((e2 || {}).data || {}).value || {}, data = _ref.data, name = _ref.name;
      if (e2.data.postmate === "emit" && e2.data.childId === _this.childId) {
        _this.logger.debug("Parent: Received event emission: " + name);
        if (name in _this.events) {
          _this.events[name].forEach(function(callback) {
            callback.call(_this, data);
          });
        }
      }
    };
    this.parent.addEventListener("message", this.listener, false);
    this.logger.debug("Parent: Awaiting event emissions from Child");
  }
  var _proto = ParentAPI2.prototype;
  _proto.get = function get2(property) {
    var _this2 = this;
    return new Postmate.Promise(function(resolve2) {
      var uid = generateNewMessageId();
      var transact = function transact2(e2) {
        if (e2.data.uid === uid && e2.data.postmate === "reply" && e2.data.childId === _this2.childId) {
          _this2.parent.removeEventListener("message", transact2, false);
          resolve2(e2.data.value);
        }
      };
      _this2.parent.addEventListener("message", transact, false);
      _this2.child.postMessage({
        postmate: "request",
        type: messageType,
        property,
        uid
      }, _this2.childOrigin);
    });
  };
  _proto.call = function call(property, data) {
    this.child.postMessage({
      postmate: "call",
      type: messageType,
      property,
      data
    }, this.childOrigin);
  };
  _proto.on = function on2(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  };
  _proto.destroy = function destroy2() {
    this.logger.debug("Parent: Destroying Postmate instance");
    window.removeEventListener("message", this.listener, false);
    this.frame.parentNode.removeChild(this.frame);
  };
  return ParentAPI2;
}();
var ChildAPI = /* @__PURE__ */ function() {
  function ChildAPI2(info) {
    var _this3 = this;
    this.model = info.model;
    this.parent = info.parent;
    this.parentOrigin = info.parentOrigin;
    this.child = info.child;
    this.childId = info.childId;
    this.logger = info.logger;
    this.logger.debug("Child: Registering API");
    this.logger.debug("Child: Awaiting messages...");
    this.child.addEventListener("message", function(e2) {
      if (!sanitize$1(e2, _this3.parentOrigin)) return;
      _this3.logger.debug("Child: Received request", e2.data);
      var _e$data = e2.data, property = _e$data.property, uid = _e$data.uid, data = _e$data.data;
      if (e2.data.postmate === "call") {
        if (property in _this3.model && typeof _this3.model[property] === "function") {
          _this3.model[property](data);
        }
        return;
      }
      resolveValue(_this3.model, property).then(function(value) {
        return e2.source.postMessage({
          property,
          postmate: "reply",
          type: messageType,
          childId: _this3.childId,
          uid,
          value
        }, e2.origin);
      });
    });
  }
  var _proto2 = ChildAPI2.prototype;
  _proto2.emit = function emit(name, data) {
    this.logger.debug('Child: Emitting Event "' + name + '"', data);
    this.parent.postMessage({
      postmate: "emit",
      type: messageType,
      childId: this.childId,
      value: {
        name,
        data
      }
    }, this.parentOrigin);
  };
  return ChildAPI2;
}();
var Postmate = /* @__PURE__ */ function() {
  function Postmate2(_ref2) {
    var _ref2$container = _ref2.container, container = _ref2$container === void 0 ? typeof container !== "undefined" ? container : document.body : _ref2$container, model = _ref2.model, url = _ref2.url, name = _ref2.name, _ref2$classListArray = _ref2.classListArray, classListArray = _ref2$classListArray === void 0 ? [] : _ref2$classListArray, _ref2$logger = _ref2.logger, logger = _ref2$logger === void 0 ? {} : _ref2$logger;
    this.parent = window;
    this.frame = document.createElement("iframe");
    this.frame.name = name || "";
    if (classListArray.length > 0) {
      this.frame.classList.add.apply(this.frame.classList, classListArray);
    }
    container.appendChild(this.frame);
    this.child = this.frame.contentWindow || this.frame.contentDocument.parentWindow;
    this.model = model || {};
    this.childId = childId();
    this.logger = SanitizeLogger(logger);
    return this.sendHandshake(url);
  }
  var _proto3 = Postmate2.prototype;
  _proto3.sendHandshake = function sendHandshake(url) {
    var _this4 = this;
    var childOrigin = resolveOrigin(url);
    var attempt = 0;
    var responseInterval;
    return new Postmate2.Promise(function(resolve2, reject) {
      var reply = function reply2(e2) {
        if (!sanitize$1(e2, childOrigin)) return false;
        if (e2.data.childId !== _this4.childId) return false;
        if (e2.data.postmate === "handshake-reply") {
          clearInterval(responseInterval);
          _this4.logger.debug("Parent: Received handshake reply from Child");
          _this4.parent.removeEventListener("message", reply2, false);
          _this4.childOrigin = e2.origin;
          _this4.logger.debug("Parent: Saving Child origin", _this4.childOrigin);
          return resolve2(new ParentAPI(_this4));
        }
        _this4.logger.error("Parent: Failed handshake");
        return reject("Failed handshake");
      };
      _this4.parent.addEventListener("message", reply, false);
      var doSend = function doSend2() {
        if (++attempt > Postmate2.maxHandshakeRequests) {
          clearInterval(responseInterval);
          _this4.logger.error("Parent: Handshake Timeout Reached");
          return reject("Handshake Timeout Reached");
        }
        _this4.logger.debug("Parent: Sending handshake attempt " + attempt, {
          childOrigin
        });
        _this4.child.postMessage({
          postmate: "handshake",
          type: messageType,
          model: _this4.model,
          childId: _this4.childId
        }, childOrigin);
      };
      var loaded = function loaded2() {
        doSend();
        responseInterval = setInterval(doSend, 500);
      };
      if (_this4.frame.attachEvent) {
        _this4.frame.attachEvent("onload", loaded);
      } else {
        _this4.frame.addEventListener("load", loaded);
      }
      _this4.logger.debug("Parent: Loading frame", {
        url
      });
      _this4.frame.src = url;
    });
  };
  return Postmate2;
}();
Postmate.maxHandshakeRequests = 5;
Postmate.Promise = function() {
  try {
    return window ? window.Promise : Promise;
  } catch (e2) {
    return null;
  }
}();
Postmate.Model = /* @__PURE__ */ function() {
  function Model(model, logger) {
    if (logger === void 0) {
      logger = {};
    }
    this.child = window;
    this.model = model;
    this.parent = this.child.parent;
    this.logger = SanitizeLogger(logger);
    return this.sendHandshakeReply();
  }
  var _proto4 = Model.prototype;
  _proto4.sendHandshakeReply = function sendHandshakeReply() {
    var _this5 = this;
    return new Postmate.Promise(function(resolve2, reject) {
      var shake = function shake2(e2) {
        if (!e2.data.postmate) {
          return;
        }
        if (e2.data.postmate === "handshake") {
          _this5.logger.debug("Child: Received handshake from Parent");
          _this5.child.removeEventListener("message", shake2, false);
          _this5.logger.debug("Child: Sending handshake reply to Parent");
          e2.source.postMessage({
            postmate: "handshake-reply",
            type: messageType,
            childId: e2.data.childId
          }, e2.origin);
          _this5.childId = e2.data.childId;
          _this5.parentOrigin = e2.origin;
          var defaults2 = e2.data.model;
          if (defaults2) {
            Object.keys(defaults2).forEach(function(key) {
              _this5.model[key] = defaults2[key];
            });
            _this5.logger.debug("Child: Inherited and extended model from Parent");
          }
          _this5.logger.debug("Child: Saving Parent origin", _this5.parentOrigin);
          return resolve2(new ChildAPI(_this5));
        }
        _this5.logger.error("Child : Handshake Reply Failed");
        return reject("Handshake Reply Failed");
      };
      _this5.child.addEventListener("message", shake, false);
    });
  };
  return Model;
}();
class BaseIframe {
  constructor({
    name = "",
    url = "",
    model = {},
    container = null,
    classListArray = [],
    route = null
  } = {}) {
    classListArray = Array.isArray(classListArray) ? classListArray : [];
    if (!classListArray.includes("rebilly-instruments-iframe")) {
      classListArray.push("rebilly-instruments-iframe");
    }
    this.container = container;
    this.classListArray = classListArray;
    this.name = name;
    this.url = url;
    this.model = model;
    this.component = null;
    return (async () => {
      this.component = await this.createComponent();
      if (route) {
        this.component.call("route", route);
      }
      return this;
    })();
  }
  async destroy() {
    if (this.component.frame.parentNode) {
      await this.component.destroy();
    }
  }
  async createComponent() {
    const container = {
      appendChild: (iframe) => {
        iframe.setAttribute("loading", "lazy");
        iframe.setAttribute("allow", "payment");
        iframe.allowPaymentRequest = true;
        this.container.appendChild(iframe);
      }
    };
    const component = await new Postmate({
      name: this.name,
      url: this.url,
      container,
      classListArray: this.classListArray,
      model: this.model
    });
    return component;
  }
}
function resizeComponentHandler(iframe) {
  let prevHeight = "";
  iframe.component.on(`${iframe.name}-resize-frame`, (height) => {
    if (height !== prevHeight) {
      prevHeight = height;
      iframe.component.frame.style.height = height;
    }
  });
}
function arrayMap$1(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var baseGetTag$1 = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && baseGetTag$1(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol$1;
var Symbol$2 = _Symbol, arrayMap = _arrayMap, isArray$3 = isArray_1, isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$3(value)) {
    return arrayMap(value, baseToString$1) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$5(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$5;
function baseSlice$1(array, start, end) {
  var index2 = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseSlice = _baseSlice;
function castSlice$1(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice(array, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
var rsZWJ$2 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode$2(string) {
  return reHasUnicode.test(string);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string) {
  return string.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray$1(string) {
  return string.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string) {
  return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString$4 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string) {
    string = toString$4(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst$1 = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst$1;
var toString$3 = toString_1, upperFirst = upperFirst_1;
function capitalize$1(string) {
  return upperFirst(toString$3(string).toLowerCase());
}
var capitalize_1 = capitalize$1;
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function basePropertyOf$1(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var _basePropertyOf = basePropertyOf$1;
var basePropertyOf = _basePropertyOf;
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter$1 = basePropertyOf(deburredLetters);
var _deburrLetter = deburrLetter$1;
var deburrLetter = _deburrLetter, toString$2 = toString_1;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsCombo$1 = "[" + rsComboRange$1 + "]";
var reComboMark = RegExp(rsCombo$1, "g");
function deburr$1(string) {
  string = toString$2(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
var deburr_1 = deburr$1;
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords$1(string) {
  return string.match(reAsciiWord) || [];
}
var _asciiWords = asciiWords$1;
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord$1(string) {
  return reHasUnicodeWord.test(string);
}
var _hasUnicodeWord = hasUnicodeWord$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords$1(string) {
  return string.match(reUnicodeWord) || [];
}
var _unicodeWords = unicodeWords$1;
var asciiWords = _asciiWords, hasUnicodeWord = _hasUnicodeWord, toString$1 = toString_1, unicodeWords = _unicodeWords;
function words$1(string, pattern2, guard) {
  string = toString$1(string);
  pattern2 = guard ? void 0 : pattern2;
  if (pattern2 === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern2) || [];
}
var words_1 = words$1;
var arrayReduce = _arrayReduce, deburr = deburr_1, words = words_1;
var rsApos = "[']";
var reApos = RegExp(rsApos, "g");
function createCompounder$2(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
var _createCompounder = createCompounder$2;
var capitalize = capitalize_1, createCompounder$1 = _createCompounder;
var camelCase = createCompounder$1(function(result, word, index2) {
  word = word.toLowerCase();
  return result + (index2 ? capitalize(word) : word);
});
var camelCase_1 = camelCase;
const camelCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(camelCase_1);
var createCompounder = _createCompounder;
var kebabCase = createCompounder(function(result, word, index2) {
  return result + (index2 ? "-" : "") + word.toLowerCase();
});
var kebabCase_1 = kebabCase;
const kebabCase$1 = /* @__PURE__ */ getDefaultExportFromCjs(kebabCase_1);
class RegisteredListeners {
  constructor() {
    this._listeners = {};
  }
  add(eventName, callback) {
    document.addEventListener(eventName, callback, false);
    if (!(eventName in this._listeners)) {
      this._listeners[eventName] = [];
    }
    this._listeners[eventName].push(callback);
  }
  removeAll() {
    Object.keys(this._listeners).forEach((eventName) => {
      this._listeners[eventName].forEach(
        (callback) => document.removeEventListener(eventName, callback, false)
      );
    });
    this._listeners = {};
  }
}
const registeredListeners = new RegisteredListeners();
class BaseEvent {
  constructor(name) {
    const PREFIX = "rebilly-instruments-";
    this.internalName = PREFIX + name;
  }
  addEventListener(callback) {
    const innerCallback = ({ detail }) => callback(detail);
    registeredListeners.add(this.internalName, innerCallback);
  }
  dispatch(detail) {
    const event = new CustomEvent(this.internalName, {
      bubbles: true,
      detail
    });
    document.dispatchEvent(event);
  }
}
const events = {
  dataReady: new BaseEvent("data-ready"),
  instrumentReady: new BaseEvent("instrument-ready"),
  payoutCompleted: new BaseEvent("payout-completed"),
  purchaseCompleted: new BaseEvent("purchase-completed"),
  setupCompleted: new BaseEvent("setup-completed"),
  instrumentManaged: new BaseEvent("instrument-managed")
};
const publicEventNames = Object.keys(events).map(
  (internalName) => kebabCase$1(internalName)
);
function dispatchEventHandler(iframe) {
  iframe.component.on(`${iframe.name}-dispatch`, ({ event, detail }) => {
    events[camelCase$1(event).replace(/-/, "")].dispatch(detail);
  });
}
function updateCouponsHandler(iframe) {
  iframe.component.on(
    `${iframe.name}-update-coupon`,
    async ({ couponIds, previewPurchase } = {}) => {
      state.data.couponIds = couponIds;
      state.data.previewPurchase = previewPurchase;
      state.updateModel();
    }
  );
}
function updateAddonsHandler(iframe) {
  iframe.component.on(
    `${iframe.name}-update-addons`,
    async ({ addons, previewPurchase }) => {
      const addonPlanIds = addons.map((addon) => addon.planId);
      state.data.addons = addonPlanIds;
      state.data.previewPurchase = previewPurchase;
      state.data.previewPurchase.addonLineItems = state.data.previewPurchase.lineItems.filter(
        (item) => addonPlanIds.includes(item.planId)
      );
      state.data.previewPurchase.lineItems = state.data.previewPurchase.lineItems.filter(
        (item) => !addonPlanIds.includes(item.planId)
      );
      state.updateModel();
    }
  );
}
const errorTemplate = (error2) => {
  const title2 = "Error";
  function displayString(message = null) {
    if (message === null) {
      message = "An unexpected error has occurred";
      if (typeof error2 === "string") {
        message = error2;
      }
      if (error2.error) {
        message = error2.error;
      }
      if (error2.message) {
        message = error2.message;
      }
    }
    return `<p class="rebilly-instruments-error-card-message">${message}</p>`;
  }
  function displayList() {
    function displayDetail(detail) {
      let detailMessage = detail;
      if (detail == null ? void 0 : detail["data-rebilly"]) {
        detailMessage = `"${detail["data-rebilly"]}" ${detail.error}`;
      }
      return detailMessage;
    }
    if (error2.details.length > 1) {
      return `<ul class="rebilly-instruments-error-card-details">
        ${error2.details.map((detail) => `<li>${displayDetail(detail)}</li>`).join("")}
      </ul>`;
    }
    return displayString(displayDetail(error2.details[0]));
  }
  return `<div class="rebilly-instruments-error-card">
  <header class="rebilly-instruments-error-card-header">
    <p class="rebilly-instruments-error-card-title">${title2}</p>
    <button class="rebilly-instruments-error-card-close-button">
      <svg class="rebilly-instruments-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 10.5858l2.8284-2.8284c.3906-.3906 1.0237-.3906 1.4142 0 .3906.3905.3906 1.0236 0 1.4142L13.4142 12l2.8284 2.8284c.3906.3906.3906 1.0237 0 1.4142-.3905.3906-1.0236.3906-1.4142 0L12 13.4142l-2.8284 2.8284c-.3906.3906-1.0237.3906-1.4142 0-.3906-.3905-.3906-1.0236 0-1.4142L10.5858 12 7.7574 9.1716c-.3906-.3906-.3906-1.0237 0-1.4142.3905-.3906 1.0236-.3906 1.4142 0L12 10.5858z" fill-rule="nonzero"/>
      </svg>
    </button>
  </header>
  ${error2.details ? displayList() : displayString()}
</div>`;
};
function clearError() {
  var _a;
  const errorContainer = (_a = state.form) == null ? void 0 : _a.querySelector(
    "#rebilly-instruments-error"
  );
  if (!errorContainer) return;
  errorContainer.innerHTML = "";
}
function showError(error2, isCloseable = true) {
  var _a;
  if (!error2) return;
  const errorContainer = (_a = state.form) == null ? void 0 : _a.querySelector(
    "#rebilly-instruments-error"
  );
  if (!errorContainer) return;
  errorContainer.innerHTML = errorTemplate(error2);
  function clickOutsideError(e2) {
    if (errorContainer.contains(e2.target)) return;
    window.removeEventListener("click", clickOutsideError, false);
    clearError();
  }
  function windowBlur() {
    setTimeout(() => {
      if (document.activeElement.tagName === "IFRAME") {
        window.removeEventListener("click", windowBlur, false);
        clearError();
      }
    });
  }
  const closeButton = state.form.querySelector(
    ".rebilly-instruments-error-card-close-button"
  );
  if (isCloseable) {
    closeButton.addEventListener("click", clearError);
    window.addEventListener("click", clickOutsideError);
    window.addEventListener("blur", windowBlur, { once: true });
  } else {
    const errorBox = state.form.querySelector(
      ".rebilly-instruments-error-card"
    );
    errorBox.classList.add("not-closeable");
    closeButton.remove();
  }
  if (errorContainer.scrollIntoView) {
    errorContainer.scrollIntoView({
      behavior: "smooth",
      block: "end",
      inline: "nearest"
    });
  }
  console.error("Rebilly Instruments Error", error2);
  window.focus();
}
function showErrorHandler(iframe) {
  iframe.component.on(`${iframe.name}-show-error`, showError);
}
function stopLoaderHandler(iframe, data) {
  iframe.component.on(`${iframe.name}-stop-loading`, (id2) => {
    var _a;
    let { section } = data;
    if (!section) {
      section = id2.includes("summary") ? "summary" : "form";
    }
    (_a = data.loader) == null ? void 0 : _a.stopLoading({ section, id: id2 });
  });
}
function showConfirmationModalHandler(iframe) {
  iframe.component.on(
    `${iframe.name}-show-confirmation-modal`,
    async (params) => {
      try {
        const response = await showConfirmationModal(params);
        iframe.component.call("update", {
          data: { confirmModal: response.confirmed }
        });
      } catch (err) {
        console.error(err);
      }
    }
  );
}
const modalTemplate$1 = ({ title: title2, message, cancelText, confirmText }) => `
  <div class="rebilly-instruments-modal-overlay is-visible">
    <div class="rebilly-instruments-modal-container rebilly-instruments-confirmation-modal-container is-visible">
        <div class="rebilly-instruments-modal-header rebilly-instruments-confirmation-modal-header">
            <strong
                class="rebilly-instruments-modal-title rebilly-instruments-confirmation-modal-title"
            >${title2}</strong>
        </div>
        <div class="rebilly-instruments-modal-content rebilly-instruments-confirmation-modal-content">
            <p
                class="rebilly-instruments-modal-message rebilly-instruments-confirmation-modal-message"
            >${message}</p>
        </div>
        <div class="rebilly-instruments-modal-actions rebilly-instruments-confirmation-modal-actions">
            <button
                class="rebilly-instruments-button rebilly-instruments-button-secondary rebilly-instruments-confirmation-modal-cancel"
            >${cancelText}</button>
            <button
                class="rebilly-instruments-button rebilly-instruments-confirmation-modal-confirm"
            >${confirmText}</button>
        </div>
    </div>
  </div>
`;
function showConfirmationModal({ title: title2, message, confirmText, cancelText }) {
  return new Promise((resolve2) => {
    state.form.insertAdjacentHTML(
      "beforeend",
      modalTemplate$1({ title: title2, message, confirmText, cancelText })
    );
    document.body.style.overflow = "hidden";
    const modalOverlay = state.form.querySelector(
      ".rebilly-instruments-modal-overlay"
    );
    const confirmButton = state.form.querySelector(
      ".rebilly-instruments-confirmation-modal-confirm"
    );
    const cancelButton = state.form.querySelector(
      ".rebilly-instruments-confirmation-modal-cancel"
    );
    const closeModal = () => {
      modalOverlay.classList.remove("is-visible");
      setTimeout(() => {
        document.body.style.overflow = "auto";
        modalOverlay.remove();
      }, 300);
    };
    modalOverlay.addEventListener("click", (event) => {
      if (event.target === modalOverlay) {
        closeModal();
        resolve2({ confirmed: false });
      }
    });
    confirmButton.addEventListener("click", () => {
      closeModal();
      resolve2({ confirmed: true });
    });
    cancelButton.addEventListener("click", () => {
      closeModal();
      resolve2({ confirmed: false });
    });
  });
}
let ViewIframe$1 = class ViewIframe extends BaseIframe {
  constructor(args = {}) {
    super(args);
  }
  bindEventListeners({ loader } = {}) {
    dispatchEventHandler(this);
    resizeComponentHandler(this);
    stopLoaderHandler(this, { loader });
    showErrorHandler(this);
    updateCouponsHandler(this);
    updateAddonsHandler(this);
    showConfirmationModalHandler(this);
  }
};
function changeIframeSrcHandler(iframe) {
  iframe.component.on(`${iframe.name}-change-iframe-src`, (url = null) => {
    iframe.component.frame.src = url;
    iframe.component.frame.style.height = "75vh";
  });
}
let ModalIframe$1 = class ModalIframe extends BaseIframe {
  constructor(args = {}) {
    super(args);
  }
  bindEventListeners({ close = () => void 0, loader } = {}) {
    dispatchEventHandler(this);
    resizeComponentHandler(this);
    changeIframeSrcHandler(this);
    stopLoaderHandler(this, {
      loader,
      section: "modal",
      id: this.name
    });
    showErrorHandler(this);
    showConfirmationModalHandler(this);
    this.component.on(`${this.name}-close`, (...args) => {
      close(...args);
    });
    window.addEventListener(
      "message",
      async (event) => {
        var _a;
        if (event.data === "rebilly-instruments-approval-url-close") {
          if (state.options.transactionType === "purchase") {
            state.storefront.setSessionToken(
              state.data.token || state.options.jwt
            );
            const [{ fields: transaction }, { fields: invoice }] = await Promise.all([
              state.storefront.transactions.get({
                id: state.data.transaction.id
              }),
              ((_a = state.data.invoice) == null ? void 0 : _a.id) ? state.storefront.invoices.get({
                id: state.data.invoice.id
              }) : { fields: null }
            ]);
            const updatedPurchase = {
              orderId: state.data.orderId,
              token: state.data.token,
              transaction
            };
            if (invoice) {
              updatedPurchase.invoice = invoice;
            }
            close(updatedPurchase);
          } else if (state.options.transactionType === "setup") {
            state.storefront.setSessionToken(
              state.data.instrument.token || state.options.jwt
            );
            const { fields: transaction } = await state.storefront.transactions.get({
              id: state.data.transaction.id
            });
            close({
              transaction,
              instrument: state.data.instrument
            });
          } else {
            close();
          }
        }
      },
      false
    );
  }
};
const ViewIframe2 = ViewIframe$1;
const ModalIframe2 = ModalIframe$1;
function arrayEach$1(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$3(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var keys_1 = keys$3;
var copyObject$3 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$3(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
var copyObject$2 = _copyObject, keysIn$2 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$2(source, keysIn$2(source), object);
}
var _baseAssignIn = baseAssignIn$1;
function arrayFilter$1(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$2() {
  return [];
}
var stubArray_1 = stubArray$2;
var arrayFilter = _arrayFilter, stubArray$1 = stubArray_1;
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols$3 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$3;
var copyObject$1 = _copyObject, getSymbols$2 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$1(source, getSymbols$2(source), object);
}
var _copySymbols = copySymbols$1;
function arrayPush$2(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush, getPrototype = _getPrototype, getSymbols$1 = _getSymbols, stubArray = stubArray_1;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$1(object));
    object = getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var arrayPush = _arrayPush, isArray$2 = isArray_1;
function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$2(object) ? result : arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$2;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys$1(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$1 = keysIn_1;
function getAllKeysIn$1(object) {
  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var getNative$3 = _getNative, root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$3 = baseGetTag;
if (DataView && getTag$3(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag$3(new Map$1()) != mapTag$3 || Promise$1 && getTag$3(Promise$1.resolve()) != promiseTag || Set$1 && getTag$3(new Set$1()) != setTag$3 || WeakMap$1 && getTag$3(new WeakMap$1()) != weakMapTag$1) {
  getTag$3 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var _getTag = getTag$3;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$1.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var cloneArrayBuffer$1 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$1(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$1 = _Symbol;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray = _cloneTypedArray;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var getTag$2 = _getTag, isObjectLike$1 = isObjectLike_1;
var mapTag$1 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$1 = _baseUnary, nodeUtil$1 = _nodeUtilExports;
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$1 = _getTag, isObjectLike = isObjectLike_1;
var setTag$1 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsSet = nodeUtil && nodeUtil.isSet;
var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack = _Stack, arrayEach = _arrayEach, assignValue = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer = _cloneBufferExports, copyArray = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject = _initCloneObject, isArray$1 = isArray_1, isBuffer$1 = isBufferExports, isMap = isMap_1, isObject$2 = isObject_1, isSet = isSet_1, keys = keys_1, keysIn = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone$1(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$2(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
const cloneDeep$1 = /* @__PURE__ */ getDefaultExportFromCjs(cloneDeep_1);
class BaseModel {
  constructor({ ...fields } = {}) {
    Object.entries(fields).forEach(([key, value]) => {
      this[key] = value;
    });
  }
}
class SummaryLineItemModel extends BaseModel {
  constructor({
    unitPrice = 0,
    quantity = 0,
    price = 0,
    ...fields
  } = {}) {
    super(fields);
    this.unitPrice = unitPrice;
    this.quantity = quantity;
    this.price = price;
  }
}
class SummaryTaxModel extends BaseModel {
}
class SummaryDiscountModel extends BaseModel {
  constructor({ amount = 0, ...fields }) {
    super(fields);
    this.amount = amount;
  }
}
class SummaryModel {
  constructor({
    currency = "",
    lineItems = [],
    taxes = [],
    discounts = [],
    subtotalAmount = 0,
    taxAmount = 0,
    shippingAmount = 0,
    discountsAmount = 0,
    total = 0
  } = {}) {
    function map(array) {
      const list = Array.isArray(array) ? array : [];
      return {
        // eslint-disable-next-line new-cap
        to: (instance) => list.map((item) => new instance(item))
      };
    }
    this.currency = currency;
    this.lineItems = map(lineItems).to(SummaryLineItemModel);
    this.taxes = map(taxes).to(SummaryTaxModel);
    this.discounts = map(discounts).to(SummaryDiscountModel);
    this.subtotalAmount = subtotalAmount;
    this.taxAmount = taxAmount;
    this.shippingAmount = shippingAmount;
    this.discountsAmount = discountsAmount;
    this.total = total;
  }
}
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue2 = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue2);
  }
  return result;
}
const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$2 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$2.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$2.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code2, config, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
}
function removeBrackets(key) {
  return utils$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$2.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
  if (!utils$2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$2.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$2.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, "[]")) && (arr = utils$2.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$2.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$2.forEach(value, function each(el, key) {
      const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$2.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$1,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$2.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$2.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$2.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$2.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$2.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
    const obj = {};
    utils$2.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$2.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$2.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$2.isObject(data);
    if (isObjectPayload && utils$2.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$2.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$2.isArrayBuffer(data) || utils$2.isBuffer(data) || utils$2.isStream(data) || utils$2.isFile(data) || utils$2.isBlob(data) || utils$2.isReadableStream(data)) {
      return data;
    }
    if (utils$2.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$2.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$2.isResponse(data) || utils$2.isReadableStream(data)) {
      return data;
    }
    if (data && utils$2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const ignoreDuplicateOf = utils$2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$2.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$2.isString(value)) return;
  if (utils$2.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$2.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$2.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$2.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$2.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$2.forEach(this, (value, header) => {
      const key = utils$2.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$2.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$2.freezeMethods(AxiosHeaders);
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;
  utils$2.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$2.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$2.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$2.isString(path) && cookie.push("path=" + path);
      utils$2.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge.call({ caseless }, target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b2, caseless) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(a, b2, caseless);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b2) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a, b2) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
  };
  utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$2.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$2.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize, encode2) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode2(String(chunk)), chunkSize);
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish, encode2) => {
  const iterator = readBytes(stream, chunkSize, encode2);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$2.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$2.isFunction(res[type2]) ? (res2) => res2[type2]() : (_2, config) => {
      throw new AxiosError(`Response type '${type2}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$2.isBlob(body)) {
    return body.size;
  }
  if (utils$2.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils$2.isArrayBufferView(body) || utils$2.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$2.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$2.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$2.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }
    if (!utils$2.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$2.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$2.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve2, reject) => {
      settle(resolve2, reject, {
        data: responseData,
        headers: AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$2.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$2.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state2]) => `adapter ${id2} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.7.5";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema2, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema2[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$2.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$2.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);
  utils$2.extend(instance, Axios.prototype, context, { allOwnKeys: true });
  utils$2.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (thing) => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
var it$1 = Object.defineProperty;
var gt$1 = (e2, t2, s) => t2 in e2 ? it$1(e2, t2, { enumerable: true, configurable: true, writable: true, value: s }) : e2[t2] = s;
var q$1 = (e2, t2, s) => gt$1(e2, typeof t2 != "symbol" ? t2 + "" : t2, s);
function d(e2, { exclude: t2 = [] } = {}) {
  Object.freeze(e2);
  const s = typeof e2 == "function";
  return Object.getOwnPropertyNames(e2).forEach((n2) => {
    (!s || n2 !== "caller" && n2 !== "callee" && n2 !== "arguments") && e2[n2] !== null && !t2.includes(n2) && (typeof e2[n2] == "object" || typeof e2[n2] == "function") && !Object.isFrozen(e2[n2]) && d(e2[n2], { exclude: t2 });
  }), e2;
}
let G$1 = class G {
  constructor({ data: t2, status: s, statusText: n2, headers: r2 }, u = {}) {
    this.response = { status: s, statusText: n2, headers: r2 }, this.fields = { ...t2 }, this.config = u, d(this, { exclude: ["cancelToken"] });
  }
  /**
   * Returns a mutable JSON representation of the Member.
   * @returns {Object}
   */
  getJSON() {
    return JSON.parse(JSON.stringify({ fields: this.fields }));
  }
};
const U$1 = {
  /**
   * Amount of records requested at once
   */
  limit: "pagination-limit",
  /**
   * Offset from which the records were requested
   */
  offset: "pagination-offset",
  /**
   * Total amount of records for the collection
   */
  total: "pagination-total"
};
let at$1 = class at {
  constructor({ data: t2, status: s, statusText: n2, headers: r2 }, u = {}) {
    this.limit = null, this.offset = null, this.total = null, Object.keys(U$1).forEach((o2) => {
      const l = r2[U$1[o2]];
      this[o2] = l ? Number(l) : null;
    }), this.response = { status: s, statusText: n2, headers: r2 }, this.items = t2.map(
      (o2) => new G$1({ data: o2, status: s, statusText: n2, headers: r2 })
    ), this.config = u, d(this, { exclude: ["cancelToken"] });
  }
  /**
   * Returns a mutable JSON representation of the Collection.
   * @returns {Object}
   */
  getJSON() {
    return JSON.parse(JSON.stringify({ items: this.items }));
  }
};
let mt$1 = class mt {
  constructor({ data: t2, status: s, statusText: n2, headers: r2 }, u = {}) {
    this.response = { status: s, statusText: n2, headers: r2 }, this.data = t2, this.config = u;
  }
};
class p extends Error {
  constructor({ error: t2, name: s = null }) {
    let {
      config: n2 = null,
      response: r2 = null,
      request: u = null,
      message: o2 = null
    } = t2, l = o2 || "Request Error";
    r2 && r2.data && r2.data.error && (l = r2.data.error), super(l), this.name = s || "RebillyError", this.response = r2, this.request = u, this.config = n2, this.status = r2 && r2.status ? r2.status : null, this.statusText = r2 && r2.statusText ? r2.statusText : null, this.details = r2 && r2.data && r2.data.details ? r2.data.details : null, this.invalidFields = r2 && r2.data && r2.data.invalidFields ? r2.data.invalidFields : null;
  }
}
let ft$1 = class ft extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyRequestError" });
  }
};
let $t$1 = class $t extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyValidationError" });
  }
};
let pt$1 = class pt extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyNotFoundError" });
  }
};
let ht$1 = class ht extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyConflictError" });
  }
};
let yt$1 = class yt extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyForbiddenError" });
  }
};
let At$1 = class At extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyMethodNotAllowedError" });
  }
};
let Rt$1 = class Rt extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyTimeoutError" });
  }
};
let bt$1 = class bt extends p {
  constructor(t2) {
    super({ error: t2, name: "RebillyCanceledError" });
  }
};
const $$1 = {
  RebillyError: p,
  RebillyRequestError: ft$1,
  RebillyValidationError: $t$1,
  RebillyNotFoundError: pt$1,
  RebillyConflictError: ht$1,
  RebillyForbiddenError: yt$1,
  RebillyMethodNotAllowedError: At$1,
  RebillyTimeoutError: Rt$1,
  RebillyCanceledError: bt$1
};
function wt$1(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
var kt$1 = Object.prototype.toString, Y$1 = function(t2) {
  if (t2 === void 0) return "undefined";
  if (t2 === null) return "null";
  var s = typeof t2;
  if (s === "boolean") return "boolean";
  if (s === "string") return "string";
  if (s === "number") return "number";
  if (s === "symbol") return "symbol";
  if (s === "function")
    return Et$1(t2) ? "generatorfunction" : "function";
  if (vt$1(t2)) return "array";
  if (xt$1(t2)) return "buffer";
  if (qt$1(t2)) return "arguments";
  if (dt$1(t2)) return "date";
  if (Tt$1(t2)) return "error";
  if (St$1(t2)) return "regexp";
  switch (Q$1(t2)) {
    case "Symbol":
      return "symbol";
    case "Promise":
      return "promise";
    case "WeakMap":
      return "weakmap";
    case "WeakSet":
      return "weakset";
    case "Map":
      return "map";
    case "Set":
      return "set";
    case "Int8Array":
      return "int8array";
    case "Uint8Array":
      return "uint8array";
    case "Uint8ClampedArray":
      return "uint8clampedarray";
    case "Int16Array":
      return "int16array";
    case "Uint16Array":
      return "uint16array";
    case "Int32Array":
      return "int32array";
    case "Uint32Array":
      return "uint32array";
    case "Float32Array":
      return "float32array";
    case "Float64Array":
      return "float64array";
  }
  if (It$1(t2))
    return "generator";
  switch (s = kt$1.call(t2), s) {
    case "[object Object]":
      return "object";
    case "[object Map Iterator]":
      return "mapiterator";
    case "[object Set Iterator]":
      return "setiterator";
    case "[object String Iterator]":
      return "stringiterator";
    case "[object Array Iterator]":
      return "arrayiterator";
  }
  return s.slice(8, -1).toLowerCase().replace(/\s/g, "");
};
function Q$1(e2) {
  return typeof e2.constructor == "function" ? e2.constructor.name : null;
}
function vt$1(e2) {
  return Array.isArray ? Array.isArray(e2) : e2 instanceof Array;
}
function Tt$1(e2) {
  return e2 instanceof Error || typeof e2.message == "string" && e2.constructor && typeof e2.constructor.stackTraceLimit == "number";
}
function dt$1(e2) {
  return e2 instanceof Date ? true : typeof e2.toDateString == "function" && typeof e2.getDate == "function" && typeof e2.setDate == "function";
}
function St$1(e2) {
  return e2 instanceof RegExp ? true : typeof e2.flags == "string" && typeof e2.ignoreCase == "boolean" && typeof e2.multiline == "boolean" && typeof e2.global == "boolean";
}
function Et$1(e2, t2) {
  return Q$1(e2) === "GeneratorFunction";
}
function It$1(e2) {
  return typeof e2.throw == "function" && typeof e2.return == "function" && typeof e2.next == "function";
}
function qt$1(e2) {
  try {
    if (typeof e2.length == "number" && typeof e2.callee == "function")
      return true;
  } catch (t2) {
    if (t2.message.indexOf("callee") !== -1)
      return true;
  }
  return false;
}
function xt$1(e2) {
  return e2.constructor && typeof e2.constructor.isBuffer == "function" ? e2.constructor.isBuffer(e2) : false;
}
/*!
 * shallow-clone <https://github.com/jonschlinkert/shallow-clone>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const V$1 = Symbol.prototype.valueOf, Pt$1 = Y$1;
function Ct$1(e2, t2) {
  switch (Pt$1(e2)) {
    case "array":
      return e2.slice();
    case "object":
      return Object.assign({}, e2);
    case "date":
      return new e2.constructor(Number(e2));
    case "map":
      return new Map(e2);
    case "set":
      return new Set(e2);
    case "buffer":
      return Ot$1(e2);
    case "symbol":
      return Ft$1(e2);
    case "arraybuffer":
      return Dt$1(e2);
    case "float32array":
    case "float64array":
    case "int16array":
    case "int32array":
    case "int8array":
    case "uint16array":
    case "uint32array":
    case "uint8clampedarray":
    case "uint8array":
      return Mt$1(e2);
    case "regexp":
      return jt$1(e2);
    case "error":
      return Object.create(e2);
    default:
      return e2;
  }
}
function jt$1(e2) {
  const t2 = e2.flags !== void 0 ? e2.flags : /\w+$/.exec(e2) || void 0, s = new e2.constructor(e2.source, t2);
  return s.lastIndex = e2.lastIndex, s;
}
function Dt$1(e2) {
  const t2 = new e2.constructor(e2.byteLength);
  return new Uint8Array(t2).set(new Uint8Array(e2)), t2;
}
function Mt$1(e2, t2) {
  return new e2.constructor(e2.buffer, e2.byteOffset, e2.length);
}
function Ot$1(e2) {
  const t2 = e2.length, s = Buffer.allocUnsafe ? Buffer.allocUnsafe(t2) : Buffer.from(t2);
  return e2.copy(s), s;
}
function Ft$1(e2) {
  return V$1 ? Object(V$1.call(e2)) : {};
}
var Kt$1 = Ct$1;
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Bt$1 = function(t2) {
  return t2 != null && typeof t2 == "object" && Array.isArray(t2) === false;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var Lt$1 = Bt$1;
function J$1(e2) {
  return Lt$1(e2) === true && Object.prototype.toString.call(e2) === "[object Object]";
}
var Nt$1 = function(t2) {
  var s, n2;
  return !(J$1(t2) === false || (s = t2.constructor, typeof s != "function") || (n2 = s.prototype, J$1(n2) === false) || n2.hasOwnProperty("isPrototypeOf") === false);
};
const zt$1 = Kt$1, Ut$1 = Y$1, Vt$1 = Nt$1;
function P(e2, t2) {
  switch (Ut$1(e2)) {
    case "object":
      return Jt$1(e2, t2);
    case "array":
      return Wt$1(e2, t2);
    default:
      return zt$1(e2);
  }
}
function Jt$1(e2, t2) {
  if (typeof t2 == "function")
    return t2(e2);
  if (t2 || Vt$1(e2)) {
    const s = new e2.constructor();
    for (let n2 in e2)
      s[n2] = P(e2[n2], t2);
    return s;
  }
  return e2;
}
function Wt$1(e2, t2) {
  const s = new e2.constructor(e2.length);
  for (let n2 = 0; n2 < e2.length; n2++)
    s[n2] = P(e2[n2], t2);
  return s;
}
var Gt$1 = P;
const Yt$1 = /* @__PURE__ */ wt$1(Gt$1), Qt$1 = "0.0.0";
let Xt$1 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Zt$1 = (e2 = 21) => {
  let t2 = "", s = e2;
  for (; s--; )
    t2 += Xt$1[Math.random() * 64 | 0];
  return t2;
};
let _t$1 = class _t {
  constructor({ id: t2 = null, created: s = null } = {}) {
    this.id = t2 || Zt$1(), this.created = s || (/* @__PURE__ */ new Date()).getTime(), this.cancelSource = axios.CancelToken.source(), this.cancel = this.cancelSource.cancel, this.cancelToken = this.cancelSource.token, d(this, {
      exclude: ["cancelSource", "cancelToken", "cancel"]
    });
  }
};
class v {
  constructor() {
    if (v.instance)
      return v.instance;
    this.requests = {}, v.instance = this;
  }
  /**
   * Returns Array with all CachedRequest from the cache.
   *
   * @return {Array}
   */
  getAll() {
    return Object.values(this.requests);
  }
  /**
   * Returns CachedRequest instance from the cache if it exists.
   *
   * @param {CachedRequestId} id
   * @returns {CachedRequest|undefined}
   */
  getById(t2) {
    return this.requests[t2];
  }
  /**
   * Delete CachedRequest from the cache object if exists.
   *
   * @param {CachedRequestId} id
   * @returns {*}
   */
  deleteById(t2) {
    this.requests[t2] && delete this.requests[t2];
  }
  /**
   * Save new request into the cache.
   *
   * @returns {{id:CachedRequestId, cancelToken: CancelToken}}
   */
  save() {
    const t2 = new _t$1();
    return this.requests[t2.id] = t2, { id: t2.id, cancelToken: t2.cancelToken };
  }
}
const w = new v();
class T {
}
q$1(T, "cancelById", (t2, s) => {
  try {
    w.getById(t2).cancel(s), w.deleteById(t2);
  } catch {
  }
}), /**
* Cancel All requests.
*
* @param {string} [reason]
* @return {Promise<any>}
*
* @example
* // import cancellation
* import {cancellation} from 'rebilly-js-sdk'
*
* // create some requests
*
* // cancel all active requests
* await cancellation.cancelAll();
*/
q$1(T, "cancelAll", async (t2) => {
  for (const s of w.getAll())
    await s.cancel(t2), w.deleteById(s.id);
});
const cn$1 = {
  /**
   * @type Cancellation.cancelAll
   */
  cancelAll: async (...e2) => await T.cancelAll(...e2)
}, b$1 = {
  request: "request",
  response: "response"
}, W$1 = (e2) => {
  if (!Object.values(b$1).includes(e2))
    throw new Error(`There is no such interceptor type as "${e2}"`);
  return true;
};
function C$1({ options: e2 }) {
  const t2 = s();
  function s() {
    return axios.create(r2());
  }
  function n2() {
    return t2;
  }
  function r2() {
    return {
      baseURL: u(),
      timeout: e2.requestTimeout,
      headers: o2()
    };
  }
  function u() {
    let c = e2.isSandbox ? e2.apiEndpoints.sandbox : e2.apiEndpoints.live;
    return e2.apiVersion && (c = `${c}/${e2.apiVersion}`), e2.organizationId && (c = `${c}/organizations/${e2.organizationId}`), `${c}`;
  }
  function o2() {
    const c = {
      "REB-API-CONSUMER": `RebillySDK/JS-SDK ${Qt$1}`
    };
    return e2.apiKey && (c["REB-APIKEY"] = e2.apiKey), c;
  }
  function l() {
    return Yt$1(t2.defaults.headers);
  }
  function a(c) {
    e2.requestTimeout = Number(c), t2.defaults.timeout = e2.requestTimeout;
  }
  function f(c = e2.jwt) {
    const i = l();
    e2.apiKey = null, e2.jwt = c, delete i.common["REB-APIKEY"], i.common.Authorization = `Bearer ${c}`, t2.defaults.headers = i;
  }
  function y(c = e2.publishableKey) {
    const i = l();
    e2.publishableKey = c, i.common.Authorization = `${c}`, t2.defaults.headers = i;
  }
  function E2({ host: c, port: i, auth: g }) {
    t2.defaults.proxy = {
      host: c,
      port: i,
      auth: g
    };
  }
  function I2({ live: c = null, sandbox: i = null }) {
    c && (e2.apiEndpoints.live = c), i && (e2.apiEndpoints.sandbox = i), t2.defaults.baseURL = u();
  }
  function M2(c, { thenDelegate: i, catchDelegate: g = () => {
  } }) {
    return W$1(c) && t2.interceptors[b$1[c]].use(
      i,
      g
    );
  }
  function O2(c, i) {
    return W$1(c) && t2.interceptors[b$1[c]].eject(i);
  }
  function X2({ thenDelegate: c, catchDelegate: i = () => {
  } }) {
    return M2(b$1.request, {
      thenDelegate: c,
      catchDelegate: i
    });
  }
  function Z2(c) {
    O2(b$1.request, c);
  }
  function _2({
    thenDelegate: c,
    catchDelegate: i = () => {
    }
  }) {
    return M2(b$1.response, {
      thenDelegate: c,
      catchDelegate: i
    });
  }
  function H2(c) {
    O2(b$1.response, c);
  }
  function A2({ request: c, isCollection: i, config: g }) {
    const m2 = K2(g), { id: h, cancelToken: ct2 } = w.save();
    m2.cancelToken = ct2;
    const z2 = async function() {
      try {
        const k2 = await c(m2);
        return tt2({
          response: k2,
          isCollection: i,
          config: m2
        });
      } catch (k2) {
        return F2({ error: k2, config: m2 });
      } finally {
        w.deleteById(h);
      }
    }();
    return z2.cancel = (k2) => T.cancelById(h, k2), z2;
  }
  function tt2({ response: c, isCollection: i, config: g }) {
    return i ? new at$1(c, g) : new G$1(c, g);
  }
  function F2({ error: c }) {
    if (axios.isCancel(c))
      throw new $$1.RebillyCanceledError(c);
    if (c.response)
      switch (Number(c.response.status)) {
        case 401:
          throw new $$1.RebillyForbiddenError(c);
        case 404:
          throw new $$1.RebillyNotFoundError(c);
        case 405:
          throw new $$1.RebillyMethodNotAllowedError(c);
        case 409:
          throw new $$1.RebillyConflictError(c);
        case 422:
          throw new $$1.RebillyValidationError(c);
        default:
          throw new $$1.RebillyRequestError(c);
      }
    throw c.code === "ECONNABORTED" ? new $$1.RebillyTimeoutError(c) : new $$1.RebillyRequestError(c);
  }
  function et2(c) {
    return c.params !== void 0 && (c.params = Object.keys(c.params).filter(
      (i) => c.params[i] !== null && c.params[i] !== ""
    ).reduce((i, g) => (i[g] = c.params[g], i), {})), c;
  }
  function K2(c = {}) {
    return { ...et2(c) };
  }
  function B2(c, i = {}) {
    return A2({
      request: (g) => t2.get(c, g),
      config: { params: i }
    });
  }
  function st2(c, i) {
    return A2({
      request: (g) => t2.get(c, g),
      config: { params: i },
      isCollection: true
    });
  }
  function L2(c, i, g = {}) {
    let m2 = {};
    return g.authenticate === false && (m2 = { headers: l() }, delete m2.headers.common["REB-APIKEY"], delete m2.headers.common.Authorization), g.params && (m2.params = { ...g.params }), A2({
      request: (h) => t2.post(c, i, h),
      config: m2
    });
  }
  function N2(c, i, g = {}) {
    return A2({
      request: (m2) => t2.put(c, i, m2),
      config: { params: g }
    });
  }
  function nt2(c, i) {
    return A2({
      request: (g) => t2.patch(c, i, g),
      config: {}
    });
  }
  function rt2(c) {
    return A2({
      request: (i) => t2.delete(c, i),
      config: {}
    });
  }
  function ut2(c, i) {
    return A2({
      request: (g) => t2.delete(c, g),
      config: { data: { ...i } }
    });
  }
  async function ot2(c, i, g, m2 = {}) {
    if (i === "")
      return L2(c, g, { params: m2 });
    try {
      if ((await B2(c)).response.status === 200)
        throw new $$1.RebillyConflictError({
          message: "A resource already exists with this ID. Please use a different ID."
        });
    } catch (h) {
      if (h.name === "RebillyNotFoundError")
        return N2(c, g, m2);
      throw h;
    }
  }
  async function lt2(c, i) {
    const g = K2(i);
    try {
      const m2 = await t2.get(c, g);
      return new mt$1(m2, g);
    } catch (m2) {
      return F2({ error: m2, config: g });
    }
  }
  return {
    getInstance: n2,
    addRequestInterceptor: X2,
    removeRequestInterceptor: Z2,
    addResponseInterceptor: _2,
    removeResponseInterceptor: H2,
    setTimeout: a,
    setProxyAgent: E2,
    setSessionToken: f,
    setPublishableKey: y,
    setEndpoints: I2,
    get: B2,
    getAll: st2,
    post: L2,
    put: N2,
    patch: nt2,
    delete: rt2,
    deleteAll: ut2,
    create: ot2,
    download: lt2
  };
}
function Ht$1({ apiHandler: e2 }) {
  return {
    forgotPassword({ data: t2 }) {
      return e2.post("forgot-password", t2, { authenticate: false });
    }
  };
}
function te$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetAllowlistCollectionRequest } request
     * @returns { rebilly.GetAllowlistCollectionResponsePromise } response
     */
    getAllowlistCollection({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null
    } = {}) {
      const u = { filter: t2, sort: s, limit: n2, offset: r2 };
      return e2.getAll("allowlists", u);
    },
    storeAllowlist({ data: t2 }) {
      return e2.post("allowlists", t2);
    },
    /**
     * @returns { rebilly.GetAllowlistResponsePromise } response
     */
    getAllowlist({ id: t2 }) {
      return e2.get(`allowlists/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`allowlists/${t2}`);
    }
  };
}
function ee$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetAmlCheckCollectionRequest } request
     * @returns { rebilly.GetAmlCheckCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("aml-checks", o2);
    },
    /**
     * @returns { rebilly.GetAmlCheckResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`aml-checks/${t2}`);
    },
    startReview({ id: t2 }) {
      return e2.post(`aml-checks/${t2}/start-review`);
    },
    stopReview({ id: t2 }) {
      return e2.post(`aml-checks/${t2}/stop-review`);
    },
    review({ id: t2, data: s }) {
      return e2.post(`aml-checks/${t2}/review`, s);
    }
  };
}
function se$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetAmlSettingsResponsePromise } response
     */
    getAmlSettings() {
      return e2.get("aml-settings");
    },
    /**
     * @returns { rebilly.PutAmlSettingsResponsePromise } response
     */
    putAmlSettings({ data: t2 }) {
      return e2.put("aml-settings", t2);
    }
  };
}
function ne$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetApiKeyCollectionRequest } request
     * @returns { rebilly.GetApiKeyCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, sort: n2 = null } = {}) {
      const r2 = { limit: t2, offset: s, sort: n2 };
      return e2.getAll("api-keys", r2);
    },
    /**
     * @param { rebilly.CreateApiKeyRequest } request
     * @returns { rebilly.PostApiKeyResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`api-keys/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetApiKeyResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`api-keys/${t2}`);
    },
    /**
     * @returns { rebilly.PutApiKeyResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`api-keys/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`api-keys/${t2}`);
    }
  };
}
function re$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetApplicationInstanceResponsePromise } response
     */
    get({ applicationId: t2 }) {
      return e2.get(`application-instances/${t2}`);
    },
    /**
     * @returns { rebilly.PutApplicationInstanceResponsePromise } response
     */
    upsert({ applicationId: t2, data: s }) {
      return e2.put(`application-instances/${t2}`, s);
    },
    delete({ applicationId: t2 }) {
      return e2.delete(`application-instances/${t2}`);
    },
    /**
     * @returns { rebilly.GetApplicationInstanceConfigurationResponsePromise } response
     */
    getConfiguration({ applicationId: t2 }) {
      return e2.get(
        `application-instances/${t2}/configuration`
      );
    },
    /**
     * @returns { rebilly.PutApplicationInstanceConfigurationResponsePromise } response
     */
    upsertConfiguration({ applicationId: t2, data: s }) {
      return e2.put(
        `application-instances/${t2}/configuration`,
        s
      );
    }
  };
}
function ue$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetApplicationCollectionRequest } request
     * @returns { rebilly.GetApplicationCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      expand: u = null,
      fields: o2 = null,
      sort: l = null
    } = {}) {
      const a = { limit: t2, offset: s, filter: n2, q: r2, expand: u, fields: o2, sort: l };
      return e2.getAll("applications", a);
    },
    create({ data: t2 }) {
      return e2.post("applications", t2);
    },
    /**
     * @returns { rebilly.GetApplicationResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`applications/${t2}`);
    },
    /**
     * @param { rebilly.GetApplicationInstanceCollectionRequest } request
     * @returns { rebilly.GetApplicationInstanceCollectionResponsePromise } response
     */
    getInstances({ id: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(`applications/${t2}/instances`, r2);
    },
    /**
     * @returns { rebilly.GetApplicationInstanceByOrganizationResponsePromise } response
     */
    getInstance({ id: t2, organizationId: s }) {
      return e2.get(`applications/${t2}/instances/${s}`);
    }
  };
}
function oe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetBalanceTransactionCollectionRequest } request
     * @returns { rebilly.GetBalanceTransactionCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("balance-transactions", u);
    },
    /**
     * @returns { rebilly.GetBalanceTransactionResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`balance-transactions/${t2}`);
    }
  };
}
function le$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetBillingPortalCollectionRequest } request
     * @returns { rebilly.GetBillingPortalCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("billing-portals", o2);
    },
    /**
     * @param { rebilly.CreateBillingPortalRequest } request
     * @returns { rebilly.PostBillingPortalResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`billing-portals/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetBillingPortalResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`billing-portals/${t2}`);
    },
    /**
     * @returns { rebilly.PutBillingPortalResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`billing-portals/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`billing-portals/${t2}`);
    }
  };
}
function ce$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetBlocklistCollectionRequest } request
     * @returns { rebilly.GetBlocklistCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("blocklists", o2);
    },
    /**
     * @param { rebilly.CreateBlocklistRequest } request
     * @returns { rebilly.PostBlocklistResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`blocklists/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetBlocklistResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`blocklists/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`blocklists/${t2}`);
    }
  };
}
function ie$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetBroadcastMessageCollectionRequest } request
     * @returns { rebilly.GetBroadcastMessageCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, sort: n2 = null, filter: r2 = null } = {}) {
      const u = { limit: t2, offset: s, sort: n2, filter: r2 };
      return e2.getAll("broadcast-messages", u);
    },
    create({ data: t2 }) {
      return e2.post("broadcast-messages", t2);
    },
    /**
     * @returns { rebilly.GetBroadcastMessageResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`broadcast-messages/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`broadcast-messages/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`broadcast-messages/${t2}`, s);
    }
  };
}
function ge({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetCheckoutFormCollectionRequest } request
     * @returns { rebilly.GetCheckoutFormCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("checkout-forms", o2);
    },
    /**
     * @param { rebilly.CreateCheckoutFormRequest } request
     * @returns { rebilly.PostCheckoutFormResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`checkout-forms/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetCheckoutFormResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`checkout-forms/${t2}`);
    },
    /**
     * @returns { rebilly.PutCheckoutFormResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`checkout-forms/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`checkout-forms/${t2}`);
    }
  };
}
function ae$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetCouponRedemptionCollectionRequest } request
     * @returns { rebilly.GetCouponRedemptionCollectionResponsePromise } response
     */
    getAllRedemptions({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, q: r2, sort: u };
      return e2.getAll("coupons-redemptions", o2);
    },
    redeem({ data: t2 }) {
      return e2.post("coupons-redemptions", t2);
    },
    /**
     * @returns { rebilly.GetCouponRedemptionResponsePromise } response
     */
    getRedemption({ id: t2 }) {
      return e2.get(`coupons-redemptions/${t2}`);
    },
    cancelRedemption({ id: t2 }) {
      return e2.post(`coupons-redemptions/${t2}/cancel`);
    },
    /**
     * @param { rebilly.GetCouponCollectionRequest } request
     * @returns { rebilly.GetCouponCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, q: r2, sort: u };
      return e2.getAll("coupons", o2);
    },
    /**
     * @param { rebilly.CreateCouponRequest } request
     * @returns { rebilly.PostCouponResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`coupons/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetCouponResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`coupons/${t2}`);
    },
    /**
     * @returns { rebilly.PutCouponResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`coupons/${t2}`, s);
    },
    setExpiration({ id: t2, data: s }) {
      return e2.post(`coupons/${t2}/expiration`, s);
    }
  };
}
function me$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetCreditMemoCollectionRequest } request
     * @returns { rebilly.GetCreditMemoCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("credit-memos", o2);
    },
    /**
     * @param { rebilly.CreateCreditMemoRequest } request
     * @returns { rebilly.PostCreditMemoResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`credit-memos/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetCreditMemoResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`credit-memos/${t2}`);
    },
    /**
     * @returns { rebilly.PutCreditMemoResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`credit-memos/${t2}`, s);
    },
    patch({ id: t2, data: s }) {
      return e2.patch(`credit-memos/${t2}`, s);
    },
    void({ id: t2 }) {
      return e2.post(`credit-memos/${t2}/void`);
    },
    /**
     * @param { rebilly.GetCreditMemoTimelineCollectionRequest } request
     * @returns { rebilly.GetCreditMemoTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`credit-memos/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`credit-memos/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetCreditMemoTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`credit-memos/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`credit-memos/${t2}/timeline/${s}`);
    }
  };
}
function fe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetCustomDomainCollectionRequest } request
     * @returns { rebilly.GetCustomDomainCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("custom-domains", o2);
    },
    create({ data: t2 }) {
      return e2.post("custom-domains", t2);
    },
    /**
     * @returns { rebilly.GetCustomDomainResponsePromise } response
     */
    get({ domain: t2 }) {
      return e2.get(`custom-domains/${t2}`);
    },
    delete({ domain: t2 }) {
      return e2.delete(`custom-domains/${t2}`);
    }
  };
}
function $e$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetCustomFieldCollectionResponsePromise } response
     */
    getAll({ resource: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(`custom-fields/${t2}`, r2);
    },
    /**
     * @returns { rebilly.GetCustomFieldResponsePromise } response
     */
    get({ resource: t2, name: s }) {
      return e2.get(`custom-fields/${t2}/${s}`);
    },
    /**
     * @returns { rebilly.PutCustomFieldResponsePromise } response
     */
    create({ resource: t2, name: s, data: n2 }) {
      return e2.put(`custom-fields/${t2}/${s}`, n2);
    },
    /**
     * @returns { rebilly.PutCustomFieldResponsePromise } response
     */
    update({ resource: t2, name: s, data: n2 }) {
      return e2.put(`custom-fields/${t2}/${s}`, n2);
    }
  };
}
function pe$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetAuthenticationOptionResponsePromise } response
     */
    getAuthOptions() {
      return e2.get("authentication-options");
    },
    /**
     * @returns { rebilly.PutAuthenticationOptionResponsePromise } response
     */
    updateAuthOptions({ data: t2 }) {
      return e2.put("authentication-options", t2);
    },
    /**
     * @param { rebilly.GetAuthenticationTokenCollectionRequest } request
     * @returns { rebilly.GetAuthenticationTokenCollectionResponsePromise } response
     */
    getAllAuthTokens({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("authentication-tokens", n2);
    },
    login({ data: t2 }) {
      return e2.post("authentication-tokens", t2);
    },
    /**
     * @returns { rebilly.GetAuthenticationTokenVerificationResponsePromise } response
     */
    verify({ token: t2 }) {
      return e2.get(`authentication-tokens/${t2}`);
    },
    logout({ token: t2 }) {
      return e2.delete(`authentication-tokens/${t2}`);
    },
    exchangeToken({ token: t2, data: s }) {
      return e2.post(`authentication-tokens/${t2}/exchange`, s);
    },
    /**
     * @param { rebilly.GetCredentialCollectionRequest } request
     * @returns { rebilly.GetCredentialCollectionResponsePromise } response
     */
    getAllCredentials({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("credentials", n2);
    },
    /**
     * @param { rebilly.CreateCredentialRequest } request
     * @returns { rebilly.PostCredentialResponsePromise } response
     */
    createCredential({ id: t2 = "", data: s }) {
      return e2.create(`credentials/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetCredentialResponsePromise } response
     */
    getCredential({ id: t2 }) {
      return e2.get(`credentials/${t2}`);
    },
    /**
     * @returns { rebilly.PutCredentialResponsePromise } response
     */
    updateCredential({ id: t2, data: s }) {
      return e2.put(`credentials/${t2}`, s);
    },
    deleteCredential({ id: t2 }) {
      return e2.delete(`credentials/${t2}`);
    },
    /**
     * @param { rebilly.GetPasswordTokenCollectionRequest } request
     * @returns { rebilly.GetPasswordTokenCollectionResponsePromise } response
     */
    getAllResetPasswordTokens({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("password-tokens", n2);
    },
    createResetPasswordToken({ data: t2 }) {
      return e2.post("password-tokens", t2);
    },
    /**
     * @returns { rebilly.GetPasswordTokenResponsePromise } response
     */
    getResetPasswordToken({ id: t2 }) {
      return e2.get(`password-tokens/${t2}`);
    },
    deleteResetPasswordToken({ id: t2 }) {
      return e2.delete(`password-tokens/${t2}`);
    }
  };
}
function he$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetCustomerCollectionRequest } request
     * @returns { rebilly.GetCustomerCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      expand: u = null,
      fields: o2 = null,
      sort: l = null
    } = {}) {
      const a = { limit: t2, offset: s, filter: n2, q: r2, expand: u, fields: o2, sort: l };
      return e2.getAll("customers", a);
    },
    /**
     * @param { rebilly.CreateCustomerRequest } request
     * @returns { rebilly.PostCustomerResponsePromise } response
     */
    create({ id: t2 = "", data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.create(`customers/${t2}`, t2, s, r2);
    },
    /**
     * @returns { rebilly.GetCustomerResponsePromise } response
     */
    get({ id: t2, expand: s = null, fields: n2 = null }) {
      const r2 = { expand: s, fields: n2 };
      return e2.get(`customers/${t2}`, r2);
    },
    /**
     * @returns { rebilly.PutCustomerResponsePromise } response
     */
    update({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.put(`customers/${t2}`, s, r2);
    },
    merge({ id: t2, targetCustomerId: s }) {
      return e2.delete(
        `customers/${t2}?targetCustomerId=${s}`
      );
    },
    /**
     * @returns { rebilly.GetCustomerLeadSourceResponsePromise } response
     */
    getLeadSource({ id: t2 }) {
      return e2.get(`customers/${t2}/lead-source`);
    },
    /**
     * @returns { rebilly.PutCustomerLeadSourceResponsePromise } response
     */
    createLeadSource({ id: t2, data: s }) {
      return e2.put(`customers/${t2}/lead-source`, s);
    },
    /**
     * @returns { rebilly.PutCustomerLeadSourceResponsePromise } response
     */
    updateLeadSource({ id: t2, data: s }) {
      return e2.put(`customers/${t2}/lead-source`, s);
    },
    deleteLeadSource({ id: t2 }) {
      return e2.delete(`customers/${t2}/lead-source`);
    },
    /**
     * @param { rebilly.GetCustomerTimelineCollectionRequest } request
     * @returns { rebilly.GetCustomerTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`customers/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`customers/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetCustomerTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`customers/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`customers/${t2}/timeline/${s}`);
    },
    /**
     * @returns { rebilly.GetCustomerEddScoreResponsePromise } response
     */
    getCustomerEddScore({ id: t2 }) {
      return e2.get(`customers/${t2}/edd-score`);
    },
    patchCustomerEddScore({ id: t2, data: s }) {
      return e2.patch(`customers/${t2}/edd-score`, s);
    },
    /**
     * @param { rebilly.GetCustomerEddTimelineCollectionRequest } request
     * @returns { rebilly.GetCustomerEddTimelineCollectionResponsePromise } response
     */
    getEddTimelineCollection({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`customers/${t2}/edd-timeline`, l);
    },
    createEddTimelineComment({ id: t2, data: s }) {
      return e2.post(`customers/${t2}/edd-timeline`, s);
    },
    /**
     * @returns { rebilly.GetCustomerEddTimelineResponsePromise } response
     */
    getEddTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`customers/${t2}/edd-timeline/${s}`);
    },
    deleteEddTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`customers/${t2}/edd-timeline/${s}`);
    },
    /**
     * @param { rebilly.GetCustomerEddSearchResultCollectionRequest } request
     * @returns { rebilly.GetCustomerEddSearchResultCollectionResponsePromise } response
     */
    getAllEddSearchResults({ id: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(`customers/${t2}/edd-search-results`, r2);
    },
    /**
     * @returns { rebilly.GetCustomerEddSearchResultResponsePromise } response
     */
    getEddSearchResult({ id: t2, searchResultId: s }) {
      return e2.get(
        `customers/${t2}/edd-search-results/${s}`
      );
    }
  };
}
function ye$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetDepositCustomPropertySetCollectionRequest } request
     * @returns { rebilly.GetDepositCustomPropertySetCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("deposit-custom-property-sets", u);
    },
    /**
     * @param { rebilly.CreateDepositCustomPropertySetRequest } request
     * @returns { rebilly.PostDepositCustomPropertySetResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`deposit-custom-property-sets/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetDepositCustomPropertySetResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`deposit-custom-property-sets/${t2}`);
    },
    /**
     * @returns { rebilly.PutDepositCustomPropertySetResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`deposit-custom-property-sets/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`deposit-custom-property-sets/${t2}`);
    }
  };
}
function Ae$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetDepositRequestCollectionRequest } request
     * @returns { rebilly.GetDepositRequestCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("deposit-requests", u);
    },
    create({ data: t2 }) {
      return e2.post("deposit-requests", t2);
    },
    /**
     * @returns { rebilly.GetDepositRequestResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`deposit-requests/${t2}`, n2);
    }
  };
}
function Re$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetDepositStrategyCollectionRequest } request
     * @returns { rebilly.GetDepositStrategyCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("deposit-strategies", u);
    },
    /**
     * @param { rebilly.CreateDepositStrategyRequest } request
     * @returns { rebilly.PostDepositStrategyResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`deposit-strategies/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetDepositStrategyResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`deposit-strategies/${t2}`);
    },
    /**
     * @returns { rebilly.PutDepositStrategyResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`deposit-strategies/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`deposit-strategies/${t2}`);
    }
  };
}
function be({ apiHandler: e2 }) {
  return {
    validate({ data: t2 }) {
      return e2.post("digital-wallets/validation", t2);
    },
    create({ data: t2 }) {
      return e2.post("digital-wallets/onboarding/apple-pay", t2);
    }
  };
}
function we$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetDisputeCollectionRequest } request
     * @returns { rebilly.GetDisputeCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("disputes", l);
    },
    /**
     * @param { rebilly.CreateDisputeRequest } request
     * @returns { rebilly.PostDisputeResponsePromise } response
     */
    create({ id: t2 = "", data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.create(`disputes/${t2}`, t2, s, r2);
    },
    /**
     * @returns { rebilly.GetDisputeResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`disputes/${t2}`);
    },
    /**
     * @returns { rebilly.PutDisputeResponsePromise } response
     */
    update({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.put(`disputes/${t2}`, s, r2);
    }
  };
}
function ke$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.PutEmailDeliverySettingsVerificationResponsePromise } response
     */
    verify({ token: t2 }) {
      return e2.put(`email-delivery-setting-verifications/${t2}`);
    },
    /**
     * @param { rebilly.GetEmailDeliverySettingCollectionRequest } request
     * @returns { rebilly.GetEmailDeliverySettingCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, sort: r2, q: u };
      return e2.getAll("email-delivery-settings", o2);
    },
    create({ data: t2 }) {
      return e2.post("email-delivery-settings", t2);
    },
    /**
     * @returns { rebilly.GetEmailDeliverySettingResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`email-delivery-settings/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`email-delivery-settings/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`email-delivery-settings/${t2}`, s);
    },
    resendVerification({ id: t2 }) {
      return e2.post(
        `email-delivery-settings/${t2}/resend-email-verification`
      );
    }
  };
}
function ve$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetEmailMessageCollectionRequest } request
     * @returns { rebilly.GetEmailMessageCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      q: n2 = null,
      sort: r2 = null,
      filter: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, q: n2, sort: r2, filter: u };
      return e2.getAll("email-messages", o2);
    },
    create({ data: t2 }) {
      return e2.post("email-messages", t2);
    },
    /**
     * @returns { rebilly.GetEmailMessageResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`email-messages/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`email-messages/${t2}`);
    },
    send({ id: t2, data: s = { status: "outbox" } }) {
      return e2.patch(`email-messages/${t2}`, s);
    }
  };
}
function Te$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetEmailNotificationCollectionRequest } request
     * @returns { rebilly.GetEmailNotificationCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("email-notifications", n2);
    }
  };
}
function de$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetEventCollectionRequest } request
     * @returns { rebilly.GetEventCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, q: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, q: r2 };
      return e2.getAll("events", u);
    },
    /**
     * @returns { rebilly.GetEventResponsePromise } response
     */
    get({ eventType: t2 }) {
      return e2.get(`events/${t2}`);
    },
    /**
     * @returns { rebilly.GetEventRuleCollectionResponsePromise } response
     */
    getRules({ eventType: t2 }) {
      return e2.get(`events/${t2}/rules`);
    },
    /**
     * @returns { rebilly.PutEventRuleResponsePromise } response
     */
    createRules({ eventType: t2, data: s }) {
      return e2.put(`events/${t2}/rules`, s);
    },
    /**
     * @returns { rebilly.PutEventRuleResponsePromise } response
     */
    updateRules({ eventType: t2, data: s }) {
      return e2.put(`events/${t2}/rules`, s);
    },
    /**
     * @param { rebilly.GetRuleSetCollectionRequest } request
     * @returns { rebilly.GetRuleSetCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      eventType: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`events/${t2}/timeline`, l);
    },
    createTimelineComment({ eventType: t2, data: s }) {
      return e2.post(`events/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetRuleSetTimelineResponsePromise } response
     */
    getTimelineMessage({ eventType: t2, messageId: s }) {
      return e2.get(`events/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ eventType: t2, messageId: s }) {
      return e2.delete(`events/${t2}/timeline/${s}`);
    },
    /**
     * @returns { rebilly.GetEventRuleHistoryCollectionResponsePromise } response
     */
    getRulesHistory({
      eventType: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      q: u = null,
      sort: o2 = null,
      fields: l = null
    }) {
      const a = { limit: s, offset: n2, filter: r2, q: u, sort: o2, fields: l };
      return e2.getAll(`events/${t2}/rules/history`, a);
    },
    /**
     * @returns { rebilly.GetEventRuleHistoryResponsePromise } response
     */
    getRulesVersionNumber({ eventType: t2, version: s, fields: n2 = null }) {
      const r2 = { fields: n2 };
      return e2.get(
        `events/${t2}/rules/history/${s}`,
        r2
      );
    },
    /**
     * @returns { rebilly.GetEventRuleVersionResponsePromise } response
     */
    getRulesVersionDetail({ eventType: t2, version: s, fields: n2 = null }) {
      const r2 = { fields: n2 };
      return e2.get(
        `events/${t2}/rules/versions/${s}`,
        r2
      );
    },
    /**
     * @returns { rebilly.GetEventRuleSetDraftCollectionResponsePromise } response
     */
    getAllDraftRulesets({
      eventType: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      q: u = null,
      sort: o2 = null,
      fields: l = null
    }) {
      const a = { limit: s, offset: n2, filter: r2, q: u, sort: o2, fields: l };
      return e2.getAll(`events/${t2}/rules/drafts`, a);
    },
    createDraftRuleset({ eventType: t2, data: s }) {
      return e2.post(`events/${t2}/rules/drafts`, s);
    },
    /**
     * @returns { rebilly.GetEventRuleSetDraftResponsePromise } response
     */
    getDraftRuleset({ eventType: t2, id: s, fields: n2 = null }) {
      const r2 = { fields: n2 };
      return e2.get(`events/${t2}/rules/drafts/${s}`, r2);
    },
    /**
     * @returns { rebilly.PutEventRuleSetDraftResponsePromise } response
     */
    updateDraftRuleset({ eventType: t2, id: s, data: n2 }) {
      return e2.put(`events/${t2}/rules/drafts/${s}`, n2);
    },
    deleteDraftRuleset({ eventType: t2, id: s }) {
      return e2.delete(`events/${t2}/rules/drafts/${s}`);
    }
  };
}
function Se$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetExternalIdentifierResponsePromise } response
     */
    get({ resource: t2, resourceId: s, service: n2 }) {
      return e2.get(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    },
    sync({ resource: t2, resourceId: s, service: n2 }) {
      return e2.post(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    },
    /**
     * @returns { rebilly.PutExternalIdentifierResponsePromise } response
     */
    update({ resource: t2, resourceId: s, service: n2, data: r2 }) {
      return e2.put(
        `${t2}/${s}/external-identifiers/${n2}`,
        r2
      );
    },
    delete({ resource: t2, resourceId: s, service: n2 }) {
      return e2.delete(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    }
  };
}
function Ee$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetExternalServiceSettingsResponsePromise } response
     */
    getExternalServiceSettings() {
      return e2.get("external-services-settings");
    },
    /**
     * @returns { rebilly.PutExternalServiceSettingsResponsePromise } response
     */
    updateExternalServiceSettings({ data: t2 }) {
      return e2.put("external-services-settings", t2);
    }
  };
}
function Ie$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetFeeCollectionRequest } request
     * @returns { rebilly.GetFeeCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("fees", u);
    },
    /**
     * @param { rebilly.CreateFeeRequest } request
     * @returns { rebilly.PostFeeResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`fees/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetFeeResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`fees/${t2}`);
    },
    /**
     * @returns { rebilly.PutFeeResponsePromise } response
     */
    upsert({ id: t2, data: s }) {
      return e2.put(`fees/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`fees/${t2}`);
    },
    patch({ id: t2, data: s }) {
      return e2.patch(`fees/${t2}`, s);
    }
  };
}
function qe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetAttachmentCollectionRequest } request
     * @returns { rebilly.GetAttachmentCollectionResponsePromise } response
     */
    getAllAttachments({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      expand: u = null,
      fields: o2 = null,
      sort: l = null
    } = {}) {
      const a = { limit: t2, offset: s, filter: n2, q: r2, expand: u, fields: o2, sort: l };
      return e2.getAll("attachments", a);
    },
    /**
     * @returns { rebilly.PostAttachmentResponsePromise } response
     */
    attach({ id: t2 = "", data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.create(`attachments/${t2}`, t2, s, r2);
    },
    /**
     * @returns { rebilly.GetAttachmentResponsePromise } response
     */
    getAttachment({ id: t2 }) {
      return e2.get(`attachments/${t2}`);
    },
    /**
     * @returns { rebilly.PutAttachmentResponsePromise } response
     */
    updateAttachment({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.put(`attachments/${t2}`, s, r2);
    },
    detach({ id: t2 }) {
      return e2.delete(`attachments/${t2}`);
    },
    /**
     * @param { rebilly.GetFileCollectionRequest } request
     * @returns { rebilly.GetFileCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      fields: u = null,
      sort: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, filter: n2, q: r2, fields: u, sort: o2 };
      return e2.getAll("files", l);
    },
    upload({ fileObject: t2 }) {
      return e2.post("files", t2);
    },
    /**
     * @returns { rebilly.GetFileResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`files/${t2}`);
    },
    /**
     * @returns { rebilly.PutFileResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`files/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`files/${t2}`);
    },
    download({ id: t2 }) {
      const s = {
        responseType: "arraybuffer"
      };
      return e2.download(`files/${t2}/download`, s);
    },
    detachAndDelete({ id: t2 }) {
      const s = {
        filter: `fileId:${t2}`
      };
      let n2 = [];
      const u = (async () => {
        const o2 = this.getAllAttachments(s);
        n2.push(o2);
        const a = (await o2).items.map(
          (y) => (
            // @ts-ignore
            this.detach({ id: y.fields.id })
          )
        );
        n2 = [...n2, a], await Promise.all(a);
        const f = e2.delete(`files/${t2}`);
        return n2.push(f), f;
      })();
      return u.cancel = () => {
        n2.forEach((o2) => o2.cancel());
      }, u;
    },
    uploadAndUpdate({ fileObject: t2, data: s = { description: "", tags: [""] } }) {
      const n2 = [], u = (async () => {
        const o2 = this.upload({ fileObject: t2 });
        n2.push(o2), await o2;
        const l = {
          name: o2.name,
          extension: o2.extension,
          description: s.description,
          tags: s.tags,
          url: ""
        }, a = this.update({ id: o2.fields.id, data: l });
        return n2.push(a), a;
      })();
      return u.cancel = () => {
        n2.forEach((o2) => o2.cancel());
      }, u;
    }
  };
}
function xe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetGatewayAccountCollectionRequest } request
     * @returns { rebilly.GetGatewayAccountCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null,
      fields: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, sort: n2, filter: r2, q: u, fields: o2 };
      return e2.getAll("gateway-accounts", l);
    },
    /**
     * @param { rebilly.CreateGatewayAccountRequest } request
     * @returns { rebilly.PostGatewayAccountResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`gateway-accounts/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetGatewayAccountResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`gateway-accounts/${t2}`);
    },
    /**
     * @returns { rebilly.PutGatewayAccountResponsePromise } response
     */
    upsert({ id: t2, data: s }) {
      return e2.put(`gateway-accounts/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`gateway-accounts/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`gateway-accounts/${t2}`, s);
    },
    close({ id: t2 }) {
      return e2.post(`gateway-accounts/${t2}/close`);
    },
    disable({ id: t2 }) {
      return e2.post(`gateway-accounts/${t2}/disable`);
    },
    /**
     * @returns { rebilly.GetGatewayAccountDowntimeScheduleCollectionResponsePromise } response
     */
    getAllDowntimeSchedules({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null
    }) {
      const o2 = { limit: s, offset: n2, filter: r2, sort: u };
      return e2.getAll(
        `gateway-accounts/${t2}/downtime-schedules`,
        o2
      );
    },
    createDowntimeSchedule({ id: t2, data: s }) {
      return e2.post(`gateway-accounts/${t2}/downtime-schedules`, s);
    },
    /**
     * @returns { rebilly.GetGatewayAccountDowntimeScheduleResponsePromise } response
     */
    getDowntimeSchedule({ id: t2, downtimeId: s }) {
      return e2.get(
        `gateway-accounts/${t2}/downtime-schedules/${s}`
      );
    },
    /**
     * @returns { rebilly.PutGatewayAccountDowntimeScheduleResponsePromise } response
     */
    updateDowntimeSchedule({ id: t2, downtimeId: s, data: n2 }) {
      return e2.put(
        `gateway-accounts/${t2}/downtime-schedules/${s}`,
        n2
      );
    },
    deleteDowntimeSchedule({ id: t2, downtimeId: s }) {
      return e2.delete(
        `gateway-accounts/${t2}/downtime-schedules/${s}`
      );
    },
    enable({ id: t2 }) {
      return e2.post(`gateway-accounts/${t2}/enable`);
    },
    /**
     * @returns { rebilly.GetGatewayAccountLimitCollectionResponsePromise } response
     */
    getAllVolumeLimits({ id: t2 }) {
      return e2.getAll(`gateway-accounts/${t2}/limits`);
    },
    /**
     * @returns { rebilly.GetGatewayAccountLimitResponsePromise } response
     */
    getVolumeLimit({ id: t2, limitId: s }) {
      return e2.get(`gateway-accounts/${t2}/limits/${s}`);
    },
    /**
     * @returns { rebilly.PutGatewayAccountLimitResponsePromise } response
     */
    updateVolumeLimit({ id: t2, limitId: s, data: n2 }) {
      return e2.put(`gateway-accounts/${t2}/limits/${s}`, n2);
    },
    deleteVolumeLimit({ id: t2, limitId: s }) {
      return e2.delete(`gateway-accounts/${t2}/limits/${s}`);
    },
    /**
     * @returns { rebilly.GetGatewayAccountTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`gateway-accounts/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`gateway-accounts/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetGatewayAccountTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`gateway-accounts/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`gateway-accounts/${t2}/timeline/${s}`);
    },
    checkCredentials({ id: t2 }) {
      return e2.post(`gateway-accounts/${t2}/check-credentials`);
    },
    /**
     * @returns { rebilly.GetGatewayAccountFinancialSettingsResponsePromise } response
     */
    getFinancialSettings({ id: t2 }) {
      return e2.get(`gateway-accounts/${t2}/financial-settings`);
    },
    /**
     * @returns { rebilly.PutGatewayAccountFinancialSettingsResponsePromise } response
     */
    setFinancialSettings({ id: t2, data: s }) {
      return e2.put(`gateway-accounts/${t2}/financial-settings`, s);
    }
  };
}
function Pe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetIntegrationCollectionRequest } request
     * @returns { rebilly.GetIntegrationCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("integrations", n2);
    },
    /**
     * @returns { rebilly.GetIntegrationResponsePromise } response
     */
    get({ label: t2 }) {
      return e2.get(`integrations/${t2}`);
    }
  };
}
const S$1 = { Accept: "application/pdf" };
function Ce$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetInvoiceCollectionRequest } request
     * @returns { rebilly.GetInvoiceCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("invoices", l);
    },
    /**
     * @param { rebilly.CreateInvoiceRequest } request
     * @returns { rebilly.PostInvoiceResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`invoices/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetInvoiceResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`invoices/${t2}`, n2);
    },
    /**
     * @returns { rebilly.PutInvoiceResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`invoices/${t2}`, s);
    },
    /**
     * @param { rebilly.GetInvoiceItemCollectionRequest } request
     * @returns { rebilly.GetInvoiceItemCollectionResponsePromise } response
     */
    getAllInvoiceItems({ id: t2, limit: s = null, offset: n2 = null, expand: r2 = null }) {
      const u = { limit: s, offset: n2, expand: r2 };
      return e2.getAll(`invoices/${t2}/items`, u);
    },
    createInvoiceItem({ id: t2, data: s }) {
      return e2.post(`invoices/${t2}/items`, s);
    },
    /**
     * @returns { rebilly.GetInvoiceItemResponsePromise } response
     */
    getInvoiceItem({ id: t2, itemId: s }) {
      return e2.get(`invoices/${t2}/items/${s}`);
    },
    /**
     * @returns { rebilly.PutInvoiceItemResponsePromise } response
     */
    updateInvoiceItem({ id: t2, itemId: s, data: n2 }) {
      return e2.put(`invoices/${t2}/items/${s}`, n2);
    },
    deleteInvoiceItem({ id: t2, itemId: s }) {
      return e2.delete(`invoices/${t2}/items/${s}`);
    },
    issue({ id: t2, data: s }) {
      return e2.post(`invoices/${t2}/issue`, s);
    },
    abandon({ id: t2 }) {
      return e2.post(`invoices/${t2}/abandon`);
    },
    void({ id: t2 }) {
      return e2.post(`invoices/${t2}/void`);
    },
    recalculate({ id: t2 }) {
      return e2.post(`invoices/${t2}/recalculate`);
    },
    reissue({ id: t2, data: s }) {
      return e2.post(`invoices/${t2}/reissue`, s);
    },
    /**
     * @param { rebilly.GetInvoiceTransactionAllocationCollectionRequest } request
     * @returns { rebilly.GetInvoiceTransactionAllocationCollectionResponsePromise } response
     */
    getAllTransactionAllocations({ id: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(
        `invoices/${t2}/transaction-allocations`,
        r2
      );
    },
    applyTransaction({ id: t2, data: s }) {
      return e2.post(`invoices/${t2}/transaction`, s);
    },
    /**
     * @param { rebilly.GetInvoiceTimelineCollectionRequest } request
     * @returns { rebilly.GetInvoiceTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`invoices/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`invoices/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetInvoiceTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`invoices/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`invoices/${t2}/timeline/${s}`);
    },
    downloadPDF({ id: t2 }) {
      const s = {
        headers: S$1,
        responseType: "arraybuffer"
      };
      return e2.download(`invoices/${t2}`, s);
    }
  };
}
function je$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetJournalAccountCollectionRequest } request
     * @returns { rebilly.GetJournalAccountCollectionResponsePromise } response
     */
    getAllAccounts({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null
    } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("journal-accounts", u);
    },
    /**
     * @param { rebilly.CreateJournalAccountRequest } request
     * @returns { rebilly.PostJournalAccountResponsePromise } response
     */
    createAccount({ id: t2 = "", data: s }) {
      return e2.create(`journal-accounts/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetJournalAccountResponsePromise } response
     */
    getAccount({ id: t2 }) {
      return e2.get(`journal-accounts/${t2}`);
    },
    /**
     * @returns { rebilly.PutJournalAccountResponsePromise } response
     */
    updateAccount({ id: t2, data: s }) {
      return e2.put(`journal-accounts/${t2}`, s);
    }
  };
}
function De$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetJournalEntryCollectionRequest } request
     * @returns { rebilly.GetJournalEntryCollectionResponsePromise } response
     */
    getAllEntries({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null
    } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("journal-entries", u);
    },
    /**
     * @param { rebilly.CreateJournalEntryRequest } request
     * @returns { rebilly.PostJournalEntryResponsePromise } response
     */
    createEntry({ id: t2 = "", data: s }) {
      return e2.create(`journal-entries/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetJournalEntryResponsePromise } response
     */
    getEntry({ id: t2 }) {
      return e2.get(`journal-entries/${t2}`);
    },
    /**
     * @returns { rebilly.PutJournalEntryResponsePromise } response
     */
    updateEntry({ id: t2, data: s }) {
      return e2.put(`journal-entries/${t2}`, s);
    },
    /**
     * @param { rebilly.GetJournalRecordCollectionRequest } request
     * @returns { rebilly.GetJournalRecordCollectionResponsePromise } response
     */
    getAllRecords({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      expand: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, expand: o2 };
      return e2.getAll(`journal-entries/${t2}/records`, l);
    },
    createRecord({ id: t2, data: s }) {
      return e2.post(`journal-entries/${t2}/records`, s);
    },
    /**
     * @returns { rebilly.GetJournalRecordResponsePromise } response
     */
    getRecord({ id: t2, journalRecordId: s }) {
      return e2.get(`journal-entries/${t2}/records/${s}`);
    },
    /**
     * @returns { rebilly.PutJournalRecordResponsePromise } response
     */
    updateRecord({ id: t2, journalRecordId: s, data: n2 }) {
      return e2.put(
        `journal-entries/${t2}/records/${s}`,
        n2
      );
    },
    deleteRecord({ id: t2, journalRecordId: s }) {
      return e2.delete(
        `journal-entries/${t2}/records/${s}`
      );
    }
  };
}
function Me$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetKycDocumentCollectionRequest } request
     * @returns { rebilly.GetKycDocumentCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      expand: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, sort: r2, expand: u };
      return e2.getAll("kyc-documents", o2);
    },
    /**
     * @param { rebilly.CreateKycDocumentRequest } request
     * @returns { rebilly.PostKycDocumentResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`kyc-documents/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetKycDocumentResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`kyc-documents/${t2}`);
    },
    /**
     * @returns { rebilly.PutKycDocumentResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`kyc-documents/${t2}`, s);
    },
    accept({ id: t2 }) {
      return e2.post(`kyc-documents/${t2}/acceptance`);
    },
    matches({ id: t2, data: s }) {
      return e2.post(`kyc-documents/${t2}/matches`, s);
    },
    reject({ id: t2, data: s }) {
      return e2.post(`kyc-documents/${t2}/rejection`, s);
    },
    review({ id: t2 }) {
      return e2.post(`kyc-documents/${t2}/review`);
    },
    startReview({ id: t2 }) {
      return e2.post(`kyc-documents/${t2}/start-review`);
    },
    stopReview({ id: t2 }) {
      return e2.post(`kyc-documents/${t2}/stop-review`);
    }
  };
}
function Oe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetKycRequestCollectionRequest } request
     * @returns { rebilly.GetKycRequestCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      expand: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, sort: r2, expand: u };
      return e2.getAll("kyc-requests", o2);
    },
    create({ data: t2 }) {
      return e2.post("kyc-requests", t2);
    },
    /**
     * @returns { rebilly.GetKycRequestResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`kyc-requests/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`kyc-requests/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`kyc-requests/${t2}`, s);
    }
  };
}
function Fe$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetKycSettingsResponsePromise } response
     */
    getKycSettings() {
      return e2.get("kyc-settings");
    },
    /**
     * @returns { rebilly.PutKycSettingsResponsePromise } response
     */
    updateKycSettings({ data: t2 }) {
      return e2.put("kyc-settings", t2);
    }
  };
}
function Ke$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetListCollectionRequest } request
     * @returns { rebilly.GetListCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      fields: u = null,
      q: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, filter: n2, sort: r2, fields: u, q: o2 };
      return e2.getAll("lists", l);
    },
    /**
     * @param { rebilly.CreateListRequest } request
     * @returns { rebilly.PostListResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`lists/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetListResponsePromise } response
     */
    getLatestVersion({ id: t2 }) {
      return e2.get(`lists/${t2}`);
    },
    /**
     * @returns { rebilly.PutListResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`lists/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`lists/${t2}`);
    },
    /**
     * @returns { rebilly.GetListVersionResponsePromise } response
     */
    getByVersion({ id: t2, version: s }) {
      return e2.get(`lists/${t2}/${s}`);
    }
  };
}
function Be$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetMembershipCollectionRequest } request
     * @returns { rebilly.GetMembershipCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("memberships", u);
    },
    /**
     * @returns { rebilly.GetMembershipResponsePromise } response
     */
    get({ organizationId: t2, userId: s }) {
      return e2.get(`memberships/${t2}/${s}`);
    },
    /**
     * @returns { rebilly.PutMembershipResponsePromise } response
     */
    update({ organizationId: t2, userId: s, data: n2 }) {
      return e2.put(`memberships/${t2}/${s}`, n2);
    },
    delete({ organizationId: t2, userId: s }) {
      return e2.delete(`memberships/${t2}/${s}`);
    }
  };
}
function Le$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetOrganizationExportCollectionRequest } request
     * @returns { rebilly.GetOrganizationExportCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, q: r2, sort: u };
      return e2.getAll("organization-exports", o2);
    },
    create({ data: t2 }) {
      return e2.post("organization-exports", t2);
    },
    /**
     * @returns { rebilly.GetOrganizationExportResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`organization-exports/${t2}`);
    }
  };
}
function Ne$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetOrganizationCollectionRequest } request
     * @returns { rebilly.GetOrganizationCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, sort: r2, q: u };
      return e2.getAll("organizations", o2);
    },
    create({ data: t2 }) {
      return e2.post("organizations", t2);
    },
    /**
     * @returns { rebilly.GetOrganizationResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`organizations/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`organizations/${t2}`, s);
    }
  };
}
function ze$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetPaymentCardBankNameCollectionRequest } request
     * @returns { rebilly.GetPaymentCardBankNameCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, q: s = null } = {}) {
      const n2 = { limit: t2, q: s };
      return e2.getAll("payment-cards-bank-names", n2);
    }
  };
}
function Ue$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetPaymentInstrumentCollectionRequest } request
     * @returns { rebilly.GetPaymentInstrumentCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("payment-instruments", l);
    },
    create({ data: t2 }) {
      return e2.post("payment-instruments", t2);
    },
    /**
     * @returns { rebilly.GetPaymentInstrumentResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`payment-instruments/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`payment-instruments/${t2}`, s);
    },
    deactivate({ id: t2 }) {
      return e2.post(`payment-instruments/${t2}/deactivation`);
    },
    nameInquiry({ id: t2, data: s }) {
      return e2.post(`payment-instruments/${t2}/name-inquiry`, s);
    }
  };
}
function Ve$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetPaymentMethodCollectionRequest } request
     * @returns { rebilly.GetPaymentMethodCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("payment-methods", n2);
    },
    /**
     * @returns { rebilly.GetPaymentMethodResponsePromise } response
     */
    get({ apiName: t2 }) {
      return e2.get(`payment-methods/${t2}`);
    }
  };
}
function Je$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetTokenCollectionRequest } request
     * @returns { rebilly.GetTokenCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("tokens", n2);
    },
    create({ data: t2 }) {
      return e2.post("tokens", t2);
    },
    /**
     * @returns { rebilly.GetTokenResponsePromise } response
     */
    get({ token: t2 }) {
      return e2.get(`tokens/${t2}`);
    }
  };
}
function We$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetPayoutRequestCollectionRequest } request
     * @returns { rebilly.GetPayoutRequestCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("payout-requests", u);
    },
    /**
     * @param { rebilly.CreatePayoutRequestRequest } request
     * @returns { rebilly.PostPayoutRequestResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`payout-requests/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetPayoutRequestResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`payout-requests/${t2}`);
    },
    /**
     * @returns { rebilly.PutPayoutRequestResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`payout-requests/${t2}`, s);
    },
    cancel({ id: t2, data: s }) {
      return e2.post(`payout-requests/${t2}/cancel`, s);
    },
    /**
     * @returns { rebilly.GetPayoutRequestPaymentInstrumentsResponsePromise } response
     */
    getPaymentInstruments({ id: t2 }) {
      return e2.get(`payout-requests/${t2}/payment-instruments`);
    }
  };
}
function Ge$1({ apiHandler: e2 }) {
  return {
    create({ data: t2 }) {
      return e2.post("payouts", t2);
    }
  };
}
function Ye$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetPlanCollectionRequest } request
     * @returns { rebilly.GetPlanCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("plans", o2);
    },
    /**
     * @param { rebilly.CreatePlanRequest } request
     * @returns { rebilly.PostPlanResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`plans/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetPlanResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`plans/${t2}`);
    },
    /**
     * @returns { rebilly.PutPlanResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`plans/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`plans/${t2}`);
    }
  };
}
function Qe$1({ apiHandler: e2 }) {
  return {
    order({ data: t2 }) {
      return e2.post("previews/orders", t2);
    },
    sendEmailRuleAction({ data: t2 }) {
      return e2.post("previews/rule-actions/send-email", t2);
    },
    webhook({ data: t2 }) {
      return e2.post("previews/webhooks", t2);
    }
  };
}
function Xe$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetProductCollectionRequest } request
     * @returns { rebilly.GetProductCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("products", o2);
    },
    /**
     * @param { rebilly.CreateProductRequest } request
     * @returns { rebilly.PostProductResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`products/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetProductResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`products/${t2}`);
    },
    /**
     * @returns { rebilly.PutProductResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`products/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`products/${t2}`);
    }
  };
}
function Ze$1({ apiHandler: e2 }) {
  return {
    startPermissionsEmulation({ data: t2 }) {
      return e2.post("permissions-emulation", t2);
    },
    stopPermissionsEmulation() {
      return e2.delete("permissions-emulation");
    },
    /**
     * @returns { rebilly.GetProfileResponsePromise } response
     */
    get() {
      return e2.get("profile");
    },
    /**
     * @returns { rebilly.PutProfileResponsePromise } response
     */
    update({ data: t2 }) {
      return e2.put("profile", t2);
    },
    /**
     * @returns { rebilly.GetProfileMfaResponsePromise } response
     */
    getMfa() {
      return e2.get("profile/mfa");
    },
    updateMfa() {
      return e2.post("profile/mfa");
    },
    deleteMfa() {
      return e2.delete("profile/mfa");
    }
  };
}
function _e$1({ apiHandler: e2 }) {
  return {
    readyToPay({ data: t2 }) {
      return e2.post("ready-to-pay", t2);
    }
  };
}
function He$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetQuoteCollectionRequest } request
     * @returns { rebilly.GetQuoteCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      expand: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, expand: u };
      return e2.getAll("quotes", o2);
    },
    /**
     * @param { rebilly.CreateQuoteRequest } request
     * @returns { rebilly.PostQuoteResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`quotes/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetQuoteResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`quotes/${t2}`, n2);
    },
    /**
     * @returns { rebilly.PutQuoteResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`quotes/${t2}`, s);
    },
    patch({ id: t2, data: s }) {
      return e2.patch(`quotes/${t2}`, s);
    },
    accept({ id: t2 }) {
      return e2.post(`quotes/${t2}/accept`);
    },
    cancel({ id: t2 }) {
      return e2.post(`quotes/${t2}/cancel`);
    },
    issue({ id: t2 }) {
      return e2.post(`quotes/${t2}/issue`);
    },
    recall({ id: t2 }) {
      return e2.post(`quotes/${t2}/recall`);
    },
    reject({ id: t2 }) {
      return e2.post(`quotes/${t2}/reject`);
    },
    /**
     * @param { rebilly.GetQuoteTimelineCollectionRequest } request
     * @returns { rebilly.GetQuoteTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`quotes/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`quotes/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetQuoteTimelineMessageResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`quotes/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`quotes/${t2}/timeline/${s}`);
    },
    downloadPDF({ id: t2 }) {
      const s = {
        headers: S$1,
        responseType: "arraybuffer"
      };
      return e2.download(`quotes/${t2}`, s);
    }
  };
}
function ts({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetExternalIdentifierResponsePromise } response
     */
    get({ resource: t2, resourceId: s, service: n2 }) {
      return e2.get(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    },
    sync({ resource: t2, resourceId: s, service: n2 }) {
      return e2.post(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    },
    /**
     * @returns { rebilly.PutExternalIdentifierResponsePromise } response
     */
    update({ resource: t2, resourceId: s, service: n2, data: r2 }) {
      return e2.put(
        `${t2}/${s}/external-identifiers/${n2}`,
        r2
      );
    },
    delete({ resource: t2, resourceId: s, service: n2 }) {
      return e2.delete(
        `${t2}/${s}/external-identifiers/${n2}`
      );
    }
  };
}
function es({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetRiskScoreRulesResponsePromise } response
     */
    getAll() {
      return e2.get("risk-score-rules");
    },
    /**
     * @returns { rebilly.PutRiskScoreRulesResponsePromise } response
     */
    updateRiskScoreRules({ data: t2 }) {
      return e2.put("risk-score-rules", t2);
    },
    /**
     * @returns { rebilly.GetRiskScoreBlocklistRulesResponsePromise } response
     */
    getAllBlocklistRules() {
      return e2.get("risk-score-rules/blocklists");
    },
    /**
     * @returns { rebilly.PutRiskScoreBlocklistRulesResponsePromise } response
     */
    updateRiskScoreBlocklistRules({ data: t2 }) {
      return e2.put("risk-score-rules/blocklists", t2);
    }
  };
}
function ss({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetRiskScoreSimulationJobCollectionRequest } request
     * @returns { rebilly.GetRiskScoreSimulationJobCollectionResponsePromise } response
     */
    getAll({ filter: t2 = null, sort: s = null, limit: n2 = null, offset: r2 = null } = {}) {
      const u = { filter: t2, sort: s, limit: n2, offset: r2 };
      return e2.getAll("risk-score-simulation-jobs", u);
    },
    create({ data: t2 }) {
      return e2.post("risk-score-simulation-jobs", t2);
    },
    /**
     * @returns { rebilly.GetRiskScoreSimulationJobResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`risk-score-simulation-jobs/${t2}`);
    },
    stop({ id: t2 }) {
      return e2.post(`risk-score-simulation-jobs/${t2}/stop`);
    },
    /**
     * @param { rebilly.GetRiskScoreSimulatedTransactionCollectionRequest } request
     * @returns { rebilly.GetRiskScoreSimulatedTransactionCollectionResponsePromise } response
     */
    getTransactions({ id: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(
        `risk-score-simulation-jobs/${t2}/transactions`,
        r2
      );
    }
  };
}
function ns({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetRoleCollectionRequest } request
     * @returns { rebilly.GetRoleCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, filter: n2, sort: r2, q: u, expand: o2 };
      return e2.getAll("roles", l);
    },
    /**
     * @param { rebilly.CreateRoleRequest } request
     * @returns { rebilly.PostRoleResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`roles/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetRoleResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`roles/${t2}`, n2);
    },
    /**
     * @returns { rebilly.PutRoleResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`roles/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`roles/${t2}`);
    }
  };
}
function rs({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetSearchResponsePromise } response
     */
    get({ sort: t2 = null, limit: s = null, offset: n2 = null, q: r2 = null }) {
      const u = { sort: t2, limit: s, offset: n2, q: r2 };
      return e2.get("search", u);
    }
  };
}
function us({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetGridSegmentCollectionRequest } request
     * @returns { rebilly.GetGridSegmentCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("grid-segments", o2);
    },
    /**
     * @param { rebilly.CreateGridSegmentRequest } request
     * @returns { rebilly.PostGridSegmentResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`grid-segments/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetGridSegmentResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`grid-segments/${t2}`);
    },
    /**
     * @returns { rebilly.PutGridSegmentResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`grid-segments/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`grid-segments/${t2}`);
    }
  };
}
function os({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetSendThroughAttributionCollectionResponsePromise } response
     */
    getAll({ eventType: t2 }) {
      return e2.getAll(`send-through-attribution/${t2}`);
    }
  };
}
function ls({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetServiceCredentialCollectionRequest } request
     * @returns { rebilly.GetServiceCredentialCollectionResponsePromise } response
     */
    getAll({
      type: t2,
      filter: s = null,
      limit: n2 = null,
      offset: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { filter: s, limit: n2, offset: r2, sort: u, q: o2 };
      return e2.getAll(`service-credentials/${t2}`, l);
    },
    create({ type: t2, data: s }) {
      return e2.post(`service-credentials/${t2}`, s);
    },
    /**
     * @returns { rebilly.GetServiceCredentialResponsePromise } response
     */
    get({ type: t2, id: s }) {
      return e2.get(`service-credentials/${t2}/${s}`);
    },
    update({ type: t2, id: s, data: n2 }) {
      return e2.patch(`service-credentials/${t2}/${s}`, n2);
    },
    /**
     * @param { rebilly.GetServiceCredentialItemCollectionRequest } request
     * @returns { rebilly.GetServiceCredentialItemCollectionResponsePromise } response
     */
    getItems({
      type: t2,
      id: s,
      limit: n2 = null,
      offset: r2 = null,
      filter: u = null,
      q: o2 = null,
      fields: l = null,
      sort: a = null
    }) {
      const f = { limit: n2, offset: r2, filter: u, q: o2, fields: l, sort: a };
      return e2.getAll(
        `service-credentials/${t2}/${s}/items`,
        f
      );
    }
  };
}
function cs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetShippingRateCollectionRequest } request
     * @returns { rebilly.GetShippingRateCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      sort: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, sort: r2, q: u };
      return e2.getAll("shipping-rates", o2);
    },
    /**
     * @param { rebilly.CreateShippingRateRequest } request
     * @returns { rebilly.PostShippingRateResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`shipping-rates/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetShippingRateResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`shipping-rates/${t2}`);
    },
    /**
     * @returns { rebilly.PutShippingRateResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`shipping-rates/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`shipping-rates/${t2}`);
    }
  };
}
function is({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetStatusResponsePromise } response
     */
    get() {
      return e2.get("status");
    }
  };
}
function gs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetSubscriptionCancellationCollectionRequest } request
     * @returns { rebilly.GetSubscriptionCancellationCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("subscription-cancellations", u);
    },
    /**
     * @param { rebilly.CreateSubscriptionCancellationRequest } request
     * @returns { rebilly.PostSubscriptionCancellationResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`subscription-cancellations/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetSubscriptionCancellationResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`subscription-cancellations/${t2}`);
    },
    delete({ id: t2 }) {
      return e2.delete(`subscription-cancellations/${t2}`);
    },
    patch({ id: t2, data: s }) {
      return e2.patch(`subscription-cancellations/${t2}`, s);
    }
  };
}
function as({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetSubscriptionPauseCollectionRequest } request
     * @returns { rebilly.GetSubscriptionPauseCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("subscription-pauses", u);
    },
    /**
     * @param { rebilly.CreateSubscriptionPauseRequest } request
     * @returns { rebilly.PostSubscriptionPauseResponsePromise } response
     */
    pause({ id: t2 = "", data: s }) {
      return e2.create(`subscription-pauses/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetSubscriptionPauseResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`subscription-pauses/${t2}`);
    },
    /**
     * @returns { rebilly.PutSubscriptionPauseResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`subscription-pauses/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`subscription-pauses/${t2}`);
    }
  };
}
function ms({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetSubscriptionReactivationCollectionRequest } request
     * @returns { rebilly.GetSubscriptionReactivationCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null, sort: r2 = null } = {}) {
      const u = { limit: t2, offset: s, filter: n2, sort: r2 };
      return e2.getAll("subscription-reactivations", u);
    },
    reactivate({ data: t2 }) {
      return e2.post("subscription-reactivations", t2);
    },
    /**
     * @returns { rebilly.GetSubscriptionReactivationResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`subscription-reactivations/${t2}`);
    }
  };
}
function fs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetSubscriptionCollectionRequest } request
     * @returns { rebilly.GetSubscriptionCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("subscriptions", l);
    },
    /**
     * @param { rebilly.CreateSubscriptionRequest } request
     * @returns { rebilly.PostSubscriptionResponsePromise } response
     */
    create({ id: t2 = "", data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.create(`subscriptions/${t2}`, t2, s, r2);
    },
    /**
     * @returns { rebilly.GetSubscriptionResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`subscriptions/${t2}`, n2);
    },
    /**
     * @returns { rebilly.PutSubscriptionResponsePromise } response
     */
    update({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.put(`subscriptions/${t2}`, s, r2);
    },
    delete({ id: t2 }) {
      return e2.delete(`subscriptions/${t2}`);
    },
    void({ id: t2 }) {
      return e2.post(`subscriptions/${t2}/void`);
    },
    changeItems({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.post(`subscriptions/${t2}/change-items`, s, r2);
    },
    updateItem({ id: t2, itemId: s, data: n2 }) {
      return e2.patch(`subscriptions/${t2}/items/${s}`, n2);
    },
    createInterimInvoice({ id: t2, data: s }) {
      return e2.post(`subscriptions/${t2}/interim-invoice`, s);
    },
    /**
     * @param { rebilly.GetSubscriptionUpcomingInvoiceCollectionRequest } request
     * @returns { rebilly.GetSubscriptionUpcomingInvoiceCollectionResponsePromise } response
     */
    getAllUpcomingInvoices({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.getAll(`subscriptions/${t2}/upcoming-invoices`, n2);
    },
    /**
     * @returns { rebilly.GetSubscriptionUpcomingInvoiceResponsePromise } response
     */
    getUpcomingInvoice({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`subscriptions/${t2}/upcoming-invoice`, n2);
    },
    issueEarlyUpcomingInvoice({ id: t2, data: s }) {
      return e2.post(
        `subscriptions/${t2}/upcoming-invoice/issue`,
        s
      );
    },
    issueUpcomingInvoice({ id: t2, invoiceId: s, data: n2 }) {
      return e2.post(
        `subscriptions/${t2}/upcoming-invoices/${s}/issue`,
        n2
      );
    },
    /**
     * @param { rebilly.GetSubscriptionTimelineCollectionRequest } request
     * @returns { rebilly.GetSubscriptionTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`subscriptions/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`subscriptions/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetSubscriptionTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`subscriptions/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`subscriptions/${t2}/timeline/${s}`);
    }
  };
}
function $s({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetTagCollectionRequest } request
     * @returns { rebilly.GetTagCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, q: r2, sort: u };
      return e2.getAll("tags", o2);
    },
    create({ data: t2 }) {
      return e2.post("tags", t2);
    },
    /**
     * @returns { rebilly.GetTagResponsePromise } response
     */
    get({ tag: t2 }) {
      return e2.get(`tags/${t2}`);
    },
    delete({ tag: t2 }) {
      return e2.delete(`tags/${t2}`);
    },
    update({ tag: t2, data: s }) {
      return e2.patch(`tags/${t2}`, s);
    },
    tagCustomers({ tag: t2, data: s }) {
      return e2.post(`tags/${t2}/customers`, s);
    },
    untagCustomers({ tag: t2, data: s }) {
      return e2.delete(`tags/${t2}/customers`, s);
    },
    tagCustomer({ tag: t2, customerId: s }) {
      return e2.post(`tags/${t2}/customers/${s}`);
    },
    untagCustomer({ tag: t2, customerId: s }) {
      return e2.delete(`tags/${t2}/customers/${s}`);
    },
    tagKycDocuments({ tag: t2, data: s }) {
      return e2.post(`tags/${t2}/kyc-documents`, s);
    },
    untagKycDocuments({ tag: t2, data: s }) {
      return e2.delete(`tags/${t2}/kyc-documents`, s);
    },
    tagKycDocument({ tag: t2, kycDocumentId: s }) {
      return e2.post(`tags/${t2}/kyc-documents/${s}`);
    },
    untagKycDocument({ tag: t2, kycDocumentId: s }) {
      return e2.delete(`tags/${t2}/kyc-documents/${s}`);
    },
    tagAmlChecks({ tag: t2, data: s }) {
      return e2.post(`tags/${t2}/aml-checks`, s);
    },
    untagAmlChecks({ tag: t2, data: s }) {
      return e2.delete(`tags/${t2}/aml-checks`, s);
    },
    tagAmlCheck({ tag: t2, amlCheckId: s }) {
      return e2.post(`tags/${t2}/aml-checks/${s}`);
    },
    untagAmlCheck({ tag: t2, amlCheckId: s }) {
      return e2.delete(`tags/${t2}/aml-checks/${s}`);
    }
  };
}
function ps({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetTagsRulesCollectionRequest } request
     * @returns { rebilly.GetTagsRulesCollectionResponsePromise } response
     */
    getAllTagsRules({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("tags-rules", o2);
    },
    /**
     * @param { rebilly.CreateTagRulesRequest } request
     * @returns { rebilly.PostTagRulesResponsePromise } response
     */
    createTagsRule({ id: t2 = "", data: s }) {
      return e2.create(`tags-rules/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetTagsRuleResponsePromise } response
     */
    getTagsRule({ id: t2 }) {
      return e2.get(`tags-rules/${t2}`);
    },
    /**
     * @returns { rebilly.PutTagsRuleResponsePromise } response
     */
    updateTagsRule({ id: t2, data: s }) {
      return e2.put(`tags-rules/${t2}`, s);
    },
    deleteTagsRule({ id: t2 }) {
      return e2.delete(`tags-rules/${t2}`);
    }
  };
}
function hs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetTrackingApiCollectionRequest } request
     * @returns { rebilly.GetTrackingApiCollectionResponsePromise } response
     */
    getAllApiLogs({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, sort: n2, filter: r2, q: u, expand: o2 };
      return e2.getAll("tracking/api", l);
    },
    /**
     * @returns { rebilly.GetTrackingApiResponsePromise } response
     */
    getApiLog({ id: t2 }) {
      return e2.get(`tracking/api/${t2}`);
    },
    /**
     * @param { rebilly.GetTrackingTaxCollectionRequest } request
     * @returns { rebilly.GetTrackingTaxCollectionResponsePromise } response
     */
    getAllTaxTrackingLogs({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("tracking/taxes", o2);
    },
    /**
     * @returns { rebilly.GetTrackingTaxResponsePromise } response
     */
    getTaxTrackingLog({ id: t2 }) {
      return e2.get(`tracking/taxes/${t2}`);
    },
    /**
     * @param { rebilly.GetTrackingListCollectionRequest } request
     * @returns { rebilly.GetTrackingListCollectionResponsePromise } response
     */
    getAllListsChangesHistory({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("tracking/lists", o2);
    },
    /**
     * @param { rebilly.GetTrackingWebhookCollectionRequest } request
     * @returns { rebilly.GetTrackingWebhookCollectionResponsePromise } response
     */
    getAllWebhookTrackingLogs({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("tracking/webhooks", o2);
    },
    /**
     * @returns { rebilly.GetTrackingWebhookResponsePromise } response
     */
    getWebhookTrackingLog({ id: t2 }) {
      return e2.get(`tracking/webhooks/${t2}`);
    },
    resendWebhook({ id: t2 }) {
      return e2.post(`tracking/webhooks/${t2}/resend`);
    }
  };
}
function ys({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetTransactionCollectionRequest } request
     * @returns { rebilly.GetTransactionCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null,
      expand: o2 = null
    } = {}) {
      const l = { limit: t2, offset: s, filter: n2, q: r2, sort: u, expand: o2 };
      return e2.getAll("transactions", l);
    },
    create({ data: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.post("transactions", t2, n2);
    },
    /**
     * @returns { rebilly.GetTransactionResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`transactions/${t2}`, n2);
    },
    patch({ id: t2, data: s }) {
      return e2.patch(`transactions/${t2}`, s);
    },
    query({ id: t2 }) {
      return e2.post(`transactions/${t2}/query`);
    },
    update({ id: t2, data: s }) {
      return e2.post(`transactions/${t2}/update`, s);
    },
    refund({ id: t2, data: s }) {
      return e2.post(`transactions/${t2}/refund`, s);
    },
    /**
     * @param { rebilly.GetTransactionTimelineCollectionRequest } request
     * @returns { rebilly.GetTransactionTimelineCollectionResponsePromise } response
     */
    getAllTimelineMessages({
      id: t2,
      limit: s = null,
      offset: n2 = null,
      filter: r2 = null,
      sort: u = null,
      q: o2 = null
    }) {
      const l = { limit: s, offset: n2, filter: r2, sort: u, q: o2 };
      return e2.getAll(`transactions/${t2}/timeline`, l);
    },
    createTimelineComment({ id: t2, data: s }) {
      return e2.post(`transactions/${t2}/timeline`, s);
    },
    /**
     * @returns { rebilly.GetTransactionTimelineResponsePromise } response
     */
    getTimelineMessage({ id: t2, messageId: s }) {
      return e2.get(`transactions/${t2}/timeline/${s}`);
    },
    deleteTimelineMessage({ id: t2, messageId: s }) {
      return e2.delete(`transactions/${t2}/timeline/${s}`);
    }
  };
}
function As({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetUsageCollectionRequest } request
     * @returns { rebilly.GetUsageCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("usages", o2);
    },
    /**
     * @param { rebilly.CreateUsageRequest } request
     * @returns { rebilly.PostUsageResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`usages/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetUsageResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`usages/${t2}`);
    },
    /**
     * @returns { rebilly.PutUsageResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`usages/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`usages/${t2}`);
    }
  };
}
function Rs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetUserCollectionRequest } request
     * @returns { rebilly.GetUserCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      filter: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, sort: n2, filter: r2, q: u };
      return e2.getAll("users", o2);
    },
    /**
     * @param { rebilly.CreateUserRequest } request
     * @returns { rebilly.PostUserResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`users/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetUserResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`users/${t2}`);
    },
    /**
     * @returns { rebilly.PutUserResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`users/${t2}`, s);
    },
    /**
     * @returns { rebilly.GetUserMfaResponsePromise } response
     */
    getMfa({ id: t2 }) {
      return e2.get(`users/${t2}/mfa`);
    }
  };
}
function bs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetWebhookCollectionRequest } request
     * @returns { rebilly.GetWebhookCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null, filter: n2 = null } = {}) {
      const r2 = { limit: t2, offset: s, filter: n2 };
      return e2.getAll("webhooks", r2);
    },
    /**
     * @param { rebilly.CreateWebhookRequest } request
     * @returns { rebilly.PostWebhookResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`webhooks/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetWebhookResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`webhooks/${t2}`);
    },
    /**
     * @returns { rebilly.PutWebhookResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`webhooks/${t2}`, s);
    }
  };
}
function ws$1({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetWebsiteCollectionRequest } request
     * @returns { rebilly.GetWebsiteCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      q: n2 = null,
      filter: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, q: n2, filter: r2, sort: u };
      return e2.getAll("websites", o2);
    },
    /**
     * @param { rebilly.CreateWebsiteRequest } request
     * @returns { rebilly.PostWebsiteResponsePromise } response
     */
    create({ id: t2 = "", data: s }) {
      return e2.create(`websites/${t2}`, t2, s);
    },
    /**
     * @returns { rebilly.GetWebsiteResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`websites/${t2}`);
    },
    /**
     * @returns { rebilly.PutWebsiteResponsePromise } response
     */
    update({ id: t2, data: s }) {
      return e2.put(`websites/${t2}`, s);
    },
    delete({ id: t2 }) {
      return e2.delete(`websites/${t2}`);
    }
  };
}
class ks {
  constructor({ apiHandler: t2 }) {
    this.account = Ht$1({ apiHandler: t2 }), this.allowlists = te$1({ apiHandler: t2 }), this.amlChecks = ee$1({ apiHandler: t2 }), this.amlSettings = se$1({ apiHandler: t2 }), this.apiKeys = ne$1({ apiHandler: t2 }), this.applicationInstances = re$1({ apiHandler: t2 }), this.applications = ue$1({ apiHandler: t2 }), this.balanceTransactions = oe$1({ apiHandler: t2 }), this.billingPortals = le$1({ apiHandler: t2 }), this.blocklists = ce$1({ apiHandler: t2 }), this.broadcastMessages = ie$1({ apiHandler: t2 }), this.checkoutForms = ge({ apiHandler: t2 }), this.coupons = ae$1({ apiHandler: t2 }), this.creditMemos = me$1({ apiHandler: t2 }), this.customDomains = fe$1({ apiHandler: t2 }), this.customFields = $e$1({ apiHandler: t2 }), this.customerAuthentication = pe$1({ apiHandler: t2 }), this.customers = he$1({ apiHandler: t2 }), this.depositCustomPropertySets = ye$1({
      apiHandler: t2
    }), this.depositRequests = Ae$1({ apiHandler: t2 }), this.depositStrategies = Re$1({ apiHandler: t2 }), this.digitalWallets = be({ apiHandler: t2 }), this.disputes = we$1({ apiHandler: t2 }), this.emailDeliverySettings = ke$1({ apiHandler: t2 }), this.emailMessages = ve$1({ apiHandler: t2 }), this.emailNotifications = Te$1({ apiHandler: t2 }), this.events = de$1({ apiHandler: t2 }), this.externalIdentifiers = Se$1({ apiHandler: t2 }), this.externalServicesSettings = Ee$1({
      apiHandler: t2
    }), this.fees = Ie$1({ apiHandler: t2 }), this.files = qe$1({ apiHandler: t2 }), this.gatewayAccounts = xe$1({ apiHandler: t2 }), this.integrations = Pe$1({ apiHandler: t2 }), this.invoices = Ce$1({ apiHandler: t2 }), this.journalAccounts = je$1({ apiHandler: t2 }), this.journalEntries = De$1({ apiHandler: t2 }), this.kycDocuments = Me$1({ apiHandler: t2 }), this.kycRequests = Oe$1({ apiHandler: t2 }), this.kycSettings = Fe$1({ apiHandler: t2 }), this.lists = Ke$1({ apiHandler: t2 }), this.memberships = Be$1({ apiHandler: t2 }), this.organizationExports = Le$1({ apiHandler: t2 }), this.organizations = Ne$1({ apiHandler: t2 }), this.paymentCardsBankNames = ze$1({ apiHandler: t2 }), this.paymentInstruments = Ue$1({ apiHandler: t2 }), this.paymentMethods = Ve$1({ apiHandler: t2 }), this.paymentTokens = Je$1({ apiHandler: t2 }), this.payoutRequests = We$1({ apiHandler: t2 }), this.payouts = Ge$1({ apiHandler: t2 }), this.plans = Ye$1({ apiHandler: t2 }), this.previews = Qe$1({ apiHandler: t2 }), this.products = Xe$1({ apiHandler: t2 }), this.profile = Ze$1({ apiHandler: t2 }), this.purchase = _e$1({ apiHandler: t2 }), this.quotes = He$1({ apiHandler: t2 }), this.resource = ts({ apiHandler: t2 }), this.riskScoreRules = es({ apiHandler: t2 }), this.riskScoreSimulationJobs = ss({
      apiHandler: t2
    }), this.roles = ns({ apiHandler: t2 }), this.search = rs({ apiHandler: t2 }), this.segments = us({ apiHandler: t2 }), this.sendThroughAttribution = os({ apiHandler: t2 }), this.serviceCredentials = ls({ apiHandler: t2 }), this.shippingRates = cs({ apiHandler: t2 }), this.status = is({ apiHandler: t2 }), this.subscriptionCancellations = gs({
      apiHandler: t2
    }), this.subscriptionPauses = as({ apiHandler: t2 }), this.subscriptionReactivations = ms({
      apiHandler: t2
    }), this.subscriptions = fs({ apiHandler: t2 }), this.tags = $s({ apiHandler: t2 }), this.tagsRules = ps({ apiHandler: t2 }), this.tracking = hs({ apiHandler: t2 }), this.transactions = ys({ apiHandler: t2 }), this.usages = As({ apiHandler: t2 }), this.users = Rs({ apiHandler: t2 }), this.webhooks = bs({ apiHandler: t2 }), this.websites = ws$1({ apiHandler: t2 }), this.addRequestInterceptor = t2.addRequestInterceptor, this.removeRequestInterceptor = t2.removeRequestInterceptor, this.addResponseInterceptor = t2.addResponseInterceptor, this.removeResponseInterceptor = t2.removeResponseInterceptor, this.setTimeout = t2.setTimeout, this.setProxyAgent = t2.setProxyAgent, this.setSessionToken = t2.setSessionToken, this.setPublishableKey = t2.setPublishableKey, this.setEndpoints = t2.setEndpoints, this.getCancellationToken = t2.getCancellationToken, this.generateSignature = t2.generateSignature;
  }
}
function vs({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetCustomerSummaryMetricReportResponsePromise } response
     */
    getCustomerLifetimeSummaryMetrics({ customerId: t2 }) {
      return e2.get(`customers/${t2}/summary-metrics`);
    }
  };
}
function Ts({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.GetDataExportCollectionRequest } request
     * @returns { rebilly.GetDataExportCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      sort: n2 = null,
      expand: r2 = null,
      filter: u = null,
      q: o2 = null,
      criteria: l = null
    } = {}) {
      const a = { limit: t2, offset: s, sort: n2, expand: r2, filter: u, q: o2, criteria: l };
      return e2.getAll("data-exports", a);
    },
    /**
     * @param { rebilly.CreateDataExportRequest } request
     * @returns { rebilly.PostDataExportResponsePromise } response
     */
    queue({ id: t2 = "", data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.create(`data-exports/${t2}`, t2, s, r2);
    },
    /**
     * @returns { rebilly.GetDataExportResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`data-exports/${t2}`, n2);
    },
    /**
     * @returns { rebilly.PutDataExportResponsePromise } response
     */
    update({ id: t2, data: s, expand: n2 = null }) {
      const r2 = { expand: n2 };
      return e2.put(`data-exports/${t2}`, s, r2);
    },
    delete({ id: t2 }) {
      return e2.delete(`data-exports/${t2}`);
    }
  };
}
function ds({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetHistogramTransactionReportResponsePromise } response
     */
    getTransactionHistogramReport({
      periodStart: t2,
      periodEnd: s,
      aggregationPeriod: n2,
      metric: r2,
      filter: u = null
    }) {
      const o2 = {
        periodStart: t2,
        periodEnd: s,
        aggregationPeriod: n2,
        metric: r2,
        filter: u
      };
      return e2.get("histograms/transactions", o2);
    }
  };
}
function Ss({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetApiLogSummaryReportResponsePromise } response
     */
    getApiLogSummary({ periodStart: t2, periodEnd: s, limit: n2 = null, offset: r2 = null }) {
      const u = { periodStart: t2, periodEnd: s, limit: n2, offset: r2 };
      return e2.get("reports/api-log-summary", u);
    },
    /**
     * @returns { rebilly.GetCumulativeSubscriptionReportResponsePromise } response
     */
    getCumulativeSubscriptions({
      aggregationField: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        aggregationField: t2,
        periodStart: s,
        periodEnd: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/cumulative-subscriptions", l);
    },
    /**
     * @returns { rebilly.GetDashboardReportResponsePromise } response
     */
    getDashboardMetrics({
      periodStart: t2,
      periodEnd: s,
      metrics: n2 = null,
      segments: r2 = null
    }) {
      const u = { periodStart: t2, periodEnd: s, metrics: n2, segments: r2 };
      return e2.get("reports/dashboard", u);
    },
    /**
     * @returns { rebilly.GetDccMarkupReportResponsePromise } response
     */
    getDccMarkup({
      aggregationField: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        aggregationField: t2,
        periodStart: s,
        periodEnd: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/dcc-markup", l);
    },
    /**
     * @returns { rebilly.GetDeclinedTransactionsReportResponsePromise } response
     */
    getDeclinedTransactions({
      aggregationField: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        aggregationField: t2,
        periodStart: s,
        periodEnd: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/declined-transactions", l);
    },
    /**
     * @returns { rebilly.GetDisputeReportResponsePromise } response
     */
    getDisputes({
      aggregationField: t2,
      periodMonth: s,
      limit: n2 = null,
      offset: r2 = null,
      filter: u = null
    }) {
      const o2 = { aggregationField: t2, periodMonth: s, limit: n2, offset: r2, filter: u };
      return e2.get("reports/disputes", o2);
    },
    /**
     * @returns { rebilly.GetTriggeredEventReportResponsePromise } response
     */
    getEventsTriggeredSummary({
      periodStart: t2,
      periodEnd: s,
      limit: n2 = null,
      offset: r2 = null
    }) {
      const u = { periodStart: t2, periodEnd: s, limit: n2, offset: r2 };
      return e2.get("reports/events-triggered", u);
    },
    /**
     * @returns { rebilly.GetTriggeredEventRuleReportResponsePromise } response
     */
    getTriggeredEventRuleReport({
      eventType: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null
    }) {
      const o2 = { periodStart: s, periodEnd: n2, limit: r2, offset: u };
      return e2.get(
        `reports/events-triggered/${t2}/rules`,
        o2
      );
    },
    /**
     * @returns { rebilly.GetFutureRenewalReportResponsePromise } response
     */
    getFutureRenewals({ periodStart: t2, periodEnd: s, limit: n2 = null, offset: r2 = null }) {
      const u = { periodStart: t2, periodEnd: s, limit: n2, offset: r2 };
      return e2.get("reports/future-renewals", u);
    },
    /**
     * @returns { rebilly.GetJournalReportResponsePromise } response
     */
    getJournal({
      currency: t2,
      bookedFrom: s = null,
      bookedTo: n2 = null,
      recognizedAt: r2,
      aggregationField: u,
      limit: o2 = null,
      offset: l = null,
      filter: a = null
    }) {
      const f = {
        currency: t2,
        bookedFrom: s,
        bookedTo: n2,
        recognizedAt: r2,
        aggregationField: u,
        limit: o2,
        offset: l,
        filter: a
      };
      return e2.get("reports/journal", f);
    },
    /**
     * @returns { rebilly.GetKycAcceptanceSummaryReportResponsePromise } response
     */
    getKycAcceptanceSummary({ periodStart: t2, periodEnd: s }) {
      const n2 = { periodStart: t2, periodEnd: s };
      return e2.get("reports/kyc-acceptance-summary", n2);
    },
    /**
     * @returns { rebilly.GetKycRejectionSummaryReportResponsePromise } response
     */
    getKycRejectionSummary({ periodStart: t2, periodEnd: s }) {
      const n2 = { periodStart: t2, periodEnd: s };
      return e2.get("reports/kyc-rejection-summary", n2);
    },
    /**
     * @returns { rebilly.GetKycRequestSummaryReportResponsePromise } response
     */
    getKycRequestSummary({ periodStart: t2, periodEnd: s }) {
      const n2 = { periodStart: t2, periodEnd: s };
      return e2.get("reports/kyc-request-summary", n2);
    },
    /**
     * @returns { rebilly.GetMonthlyRecurringRevenueReportResponsePromise } response
     */
    getMonthlyRecurringRevenue({
      currency: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null
    }) {
      const o2 = { currency: t2, periodStart: s, periodEnd: n2, limit: r2, offset: u };
      return e2.get("reports/monthly-recurring-revenue", o2);
    },
    /**
     * @returns { rebilly.GetRenewalSaleReportResponsePromise } response
     */
    getRenewalSales({ periodStart: t2, periodEnd: s, limit: n2 = null, offset: r2 = null }) {
      const u = { periodStart: t2, periodEnd: s, limit: n2, offset: r2 };
      return e2.get("reports/renewal-sales", u);
    },
    /**
     * @returns { rebilly.GetRetentionPercentageReportResponsePromise } response
     */
    getRetentionPercentage({
      aggregationField: t2,
      aggregationPeriod: s,
      includeSwitchedSubscriptions: n2 = null,
      periodStart: r2,
      periodEnd: u,
      limit: o2 = null,
      offset: l = null,
      filter: a = null,
      criteria: f = null
    }) {
      const y = {
        aggregationField: t2,
        aggregationPeriod: s,
        includeSwitchedSubscriptions: n2,
        periodStart: r2,
        periodEnd: u,
        limit: o2,
        offset: l,
        filter: a,
        criteria: f
      };
      return e2.get("reports/retention-percentage", y);
    },
    /**
     * @returns { rebilly.GetRetentionValueReportResponsePromise } response
     */
    getRetentionValue({
      aggregationField: t2,
      aggregationPeriod: s,
      includeRefunds: n2 = null,
      includeDisputes: r2 = null,
      periodStart: u,
      periodEnd: o2,
      limit: l = null,
      offset: a = null,
      filter: f = null,
      sort: y = null,
      criteria: E2 = null
    }) {
      const I2 = {
        aggregationField: t2,
        aggregationPeriod: s,
        includeRefunds: n2,
        includeDisputes: r2,
        periodStart: u,
        periodEnd: o2,
        limit: l,
        offset: a,
        filter: f,
        sort: y,
        criteria: E2
      };
      return e2.get("reports/retention-value", I2);
    },
    /**
     * @returns { rebilly.GetRevenueWaterfallReportResponsePromise } response
     */
    getRevenueWaterfall({ currency: t2, issuedFrom: s, issuedTo: n2, recognizedTo: r2 }) {
      const u = { currency: t2, issuedFrom: s, issuedTo: n2, recognizedTo: r2 };
      return e2.get("reports/revenue-waterfall", u);
    },
    /**
     * @returns { rebilly.GetRevenueAuditReportResponsePromise } response
     */
    getRevenueAudit({ filter: t2 = null, sort: s = null, limit: n2 = null, offset: r2 = null }) {
      const u = { filter: t2, sort: s, limit: n2, offset: r2 };
      return e2.get("reports/revenue-audit", u);
    },
    /**
     * @returns { rebilly.GetSubscriptionCancellationReportResponsePromise } response
     */
    getSubscriptionCancellation({
      periodStart: t2,
      periodEnd: s,
      aggregationField: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        periodStart: t2,
        periodEnd: s,
        aggregationField: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/subscription-cancellation", l);
    },
    /**
     * @returns { rebilly.GetSubscriptionRenewalReportResponsePromise } response
     */
    getSubscriptionRenewal({
      periodStart: t2,
      periodEnd: s,
      limit: n2 = null,
      offset: r2 = null
    }) {
      const u = { periodStart: t2, periodEnd: s, limit: n2, offset: r2 };
      return e2.get("reports/subscription-renewal", u);
    },
    /**
     * @returns { rebilly.GetTaxReportResponsePromise } response
     */
    getTax({
      periodStart: t2,
      periodEnd: s,
      accountingMethod: n2,
      limit: r2 = null,
      offset: u = null
    }) {
      const o2 = { periodStart: t2, periodEnd: s, accountingMethod: n2, limit: r2, offset: u };
      return e2.get("reports/tax", o2);
    },
    /**
     * @returns { rebilly.GetTimeSeriesTransactionReportResponsePromise } response
     */
    getTimeSeriesTransaction({
      type: t2,
      subaggregate: s,
      periodStart: n2,
      periodEnd: r2,
      limit: u = null,
      offset: o2 = null
    }) {
      const l = {
        type: t2,
        subaggregate: s,
        periodStart: n2,
        periodEnd: r2,
        limit: u,
        offset: o2
      };
      return e2.get("reports/time-series-transaction", l);
    },
    /**
     * @returns { rebilly.GetTransactionTimeDisputeReportResponsePromise } response
     */
    getTransactionsTimeDispute({
      aggregationField: t2,
      periodStart: s,
      periodEnd: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        aggregationField: t2,
        periodStart: s,
        periodEnd: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/transactions-time-dispute", l);
    },
    /**
     * @returns { rebilly.GetTransactionReportResponsePromise } response
     */
    getTransactions({
      periodStart: t2,
      periodEnd: s,
      aggregationField: n2,
      limit: r2 = null,
      offset: u = null,
      filter: o2 = null
    }) {
      const l = {
        periodStart: t2,
        periodEnd: s,
        aggregationField: n2,
        limit: r2,
        offset: u,
        filter: o2
      };
      return e2.get("reports/transactions", l);
    }
  };
}
function Es({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.GetSubscriptionSummaryMetricReportResponsePromise } response
     */
    getSubscriptionSummaryMetrics({ subscriptionId: t2 }) {
      return e2.get(`subscriptions/${t2}/summary-metrics`);
    }
  };
}
function Is({ apiHandler: e2 }) {
  return {
    getActivityFeed({ eventTypes: t2 = null, limit: s = 1e3, offset: n2 = 0 }) {
      const r2 = {
        eventTypes: t2,
        limit: s,
        offset: n2
      };
      return e2.getAll("activity-feed", r2);
    },
    getTransaction({ id: t2 = "", eventTypes: s = null, limit: n2 = 1e3, offset: r2 = 0 }) {
      const u = {
        eventTypes: s,
        limit: n2,
        offset: r2
      };
      return e2.getAll(`transactions/${t2}/timeline`, u);
    },
    getCustomer({ id: t2 = "", eventTypes: s = null, limit: n2 = 1e3, offset: r2 = 0 }) {
      const u = {
        eventTypes: s,
        limit: n2,
        offset: r2
      };
      return e2.getAll(`customers/${t2}/timeline`, u);
    }
  };
}
function qs({ apiHandler: e2 }) {
  return {
    query() {
      return e2.get("location");
    }
  };
}
const R = {
  CustomersResource: vs,
  DataExportsResource: Ts,
  HistogramsResource: ds,
  ReportsResource: Ss,
  SubscriptionsResource: Es,
  TimelinesResource: Is,
  LocationResource: qs
};
class xs {
  constructor({ apiHandler: t2 }) {
    this.customers = R.CustomersResource({ apiHandler: t2 }), this.dataExports = R.DataExportsResource({
      apiHandler: t2
    }), this.histograms = R.HistogramsResource({ apiHandler: t2 }), this.reports = R.ReportsResource({ apiHandler: t2 }), this.subscriptions = R.SubscriptionsResource({
      apiHandler: t2
    }), this.timelines = R.TimelinesResource({ apiHandler: t2 }), this.location = R.LocationResource({ apiHandler: t2 }), this.addRequestInterceptor = t2.addRequestInterceptor, this.removeRequestInterceptor = t2.removeRequestInterceptor, this.addResponseInterceptor = t2.addResponseInterceptor, this.removeResponseInterceptor = t2.removeResponseInterceptor, this.setTimeout = t2.setTimeout, this.setProxyAgent = t2.setProxyAgent, this.setSessionToken = t2.setSessionToken, this.setEndpoints = t2.setEndpoints, this.getCancellationToken = t2.getCancellationToken;
  }
}
function Ps({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetAccountResponsePromise } response
     */
    get({ expand: t2 = null } = {}) {
      const s = { expand: t2 };
      return e2.get("account", s);
    },
    update({ data: t2 }) {
      return e2.patch("account", t2);
    },
    requestPasswordReset({ data: t2 }) {
      return e2.post("account/forgot-password", t2);
    },
    changePassword({ data: t2 }) {
      return e2.patch("account/password", t2);
    },
    resendEmailVerification({ data: t2 }) {
      return e2.post("account/resend-verification", t2);
    },
    confirmPasswordReset({ token: t2, data: s }) {
      return e2.post(`account/reset-password/${t2}`, s);
    },
    verifyEmail({ token: t2 }) {
      return e2.post(`account/verification/${t2}`);
    },
    register({ data: t2 }) {
      return e2.post("register", t2);
    }
  };
}
function Cs({ apiHandler: e2 }) {
  return {
    login({ data: t2 }) {
      return e2.post("login", t2);
    },
    logout() {
      return e2.post("logout");
    }
  };
}
function js({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetBillingPortalResponsePromise } response
     */
    get({ slug: t2 }) {
      return e2.get(`billing-portals/${t2}`);
    }
  };
}
function Ds({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetCheckoutFormResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`checkout-forms/${t2}`);
    }
  };
}
function Ms({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetCustomFieldCollectionRequest } request
     * @returns { rebilly.StorefrontGetCustomFieldCollectionResponsePromise } response
     */
    getAll({ resource: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.getAll(`custom-fields/${t2}`, r2);
    }
  };
}
function Os({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetDepositRequestResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`deposit-requests/${t2}`, n2);
    }
  };
}
function Fs({ apiHandler: e2 }) {
  return {
    create({ data: t2 }) {
      return e2.post("deposit", t2);
    }
  };
}
function Ks({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetDepositStrategyResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`deposit-strategies/${t2}`);
    }
  };
}
function Bs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetInvoiceCollectionRequest } request
     * @returns { rebilly.StorefrontGetInvoiceCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("invoices", l);
    },
    /**
     * @returns { rebilly.StorefrontGetInvoiceResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`invoices/${t2}`);
    },
    downloadPDF({ id: t2 }) {
      const s = {
        headers: S$1,
        responseType: "arraybuffer"
      };
      return e2.download(`invoices/${t2}`, s);
    }
  };
}
function Ls({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetKycDocumentCollectionRequest } request
     * @returns { rebilly.StorefrontGetKycDocumentCollectionResponsePromise } response
     */
    getAll({ limit: t2 = null, offset: s = null } = {}) {
      const n2 = { limit: t2, offset: s };
      return e2.getAll("kyc-documents", n2);
    },
    create({ data: t2 }) {
      return e2.post("kyc-documents", t2);
    },
    /**
     * @returns { rebilly.StorefrontGetKycDocumentResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`kyc-documents/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`kyc-documents/${t2}`, s);
    }
  };
}
function Ns({ apiHandler: e2 }) {
  return {
    create({ data: t2 }) {
      return e2.post("kyc-liveness-sessions", t2);
    },
    /**
     * @returns { rebilly.StorefrontGetKycLivenessSessionResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`kyc-liveness-sessions/${t2}`);
    },
    finish({ id: t2 }) {
      return e2.post(`kyc-liveness-sessions/${t2}/finish`);
    }
  };
}
function zs({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetKycRequestResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`kyc-requests/${t2}`, n2);
    }
  };
}
function Us({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetOrderUpcomingInvoiceResponsePromise } response
     */
    getUpcomingInvoice({ id: t2 }) {
      return e2.get(`orders/${t2}/upcoming-invoice`);
    },
    /**
     * @param { rebilly.StorefrontGetOrderCollectionRequest } request
     * @returns { rebilly.StorefrontGetOrderCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("orders", l);
    },
    /**
     * @returns { rebilly.StorefrontGetOrderResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`orders/${t2}`, n2);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`orders/${t2}`, s);
    },
    cancel({ id: t2, data: s }) {
      return e2.post(`orders/${t2}/cancellation`, s);
    },
    pause({ id: t2, data: s }) {
      return e2.post(`orders/${t2}/pause`, s);
    }
  };
}
function Vs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetPaymentInstrumentCollectionRequest } request
     * @returns { rebilly.StorefrontGetPaymentInstrumentCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("payment-instruments", o2);
    },
    create({ data: t2 }) {
      return e2.post("payment-instruments", t2);
    },
    /**
     * @returns { rebilly.StorefrontGetPaymentInstrumentResponsePromise } response
     */
    get({ id: t2, limit: s = null, offset: n2 = null }) {
      const r2 = { limit: s, offset: n2 };
      return e2.get(`payment-instruments/${t2}`, r2);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`payment-instruments/${t2}`, s);
    },
    deactivate({ id: t2 }) {
      return e2.post(`payment-instruments/${t2}/deactivation`);
    },
    /**
     * @returns { rebilly.StorefrontGetPaymentInstrumentSetupResponsePromise } response
     */
    getSetupTransaction({ id: t2 }) {
      return e2.get(`payment-instruments/${t2}/setup`);
    },
    setup({ id: t2, data: s }) {
      return e2.post(`payment-instruments/${t2}/setup`, s);
    }
  };
}
function Js({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetPayoutRequestCollectionRequest } request
     * @returns { rebilly.StorefrontGetPayoutRequestCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("payout-requests", o2);
    },
    /**
     * @returns { rebilly.StorefrontGetPayoutRequestResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`payout-requests/${t2}`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`payout-requests/${t2}`, s);
    }
  };
}
function Ws({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetPlanCollectionRequest } request
     * @returns { rebilly.StorefrontGetPlanCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null,
      expand: o2 = null
    } = {}) {
      const l = { filter: t2, sort: s, limit: n2, offset: r2, q: u, expand: o2 };
      return e2.getAll("plans", l);
    },
    /**
     * @returns { rebilly.StorefrontGetPlanResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`plans/${t2}`, n2);
    }
  };
}
function Gs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetProductCollectionRequest } request
     * @returns { rebilly.StorefrontGetProductCollectionResponsePromise } response
     */
    getAll({
      filter: t2 = null,
      sort: s = null,
      limit: n2 = null,
      offset: r2 = null,
      q: u = null
    } = {}) {
      const o2 = { filter: t2, sort: s, limit: n2, offset: r2, q: u };
      return e2.getAll("products", o2);
    },
    /**
     * @returns { rebilly.StorefrontGetProductResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`products/${t2}`);
    }
  };
}
function Ys({ apiHandler: e2 }) {
  return {
    payment({ data: t2 }) {
      return e2.post("payment", t2);
    },
    purchase({ data: t2 }) {
      return e2.post("purchase", t2);
    },
    preview({ data: t2 }) {
      return e2.post("preview-purchase", t2);
    },
    readyToPay({ data: t2 }) {
      return e2.post("ready-to-pay", t2);
    }
  };
}
function Qs({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetQuoteResponsePromise } response
     */
    get({ id: t2, expand: s = null }) {
      const n2 = { expand: s };
      return e2.get(`quotes/${t2}`, n2);
    },
    accept({ id: t2 }) {
      return e2.post(`quotes/${t2}/accept`);
    },
    reject({ id: t2 }) {
      return e2.post(`quotes/${t2}/reject`);
    },
    downloadPDF({ id: t2 }) {
      const s = {
        headers: S$1,
        responseType: "arraybuffer"
      };
      return e2.download(`quotes/${t2}`, s);
    }
  };
}
function Xs({ apiHandler: e2 }) {
  return {
    readyToPayout({ data: t2 }) {
      return e2.post("ready-to-payout", t2);
    }
  };
}
function Zs({ apiHandler: e2 }) {
  return {
    reactivation({ data: t2 }) {
      return e2.post("subscription-reactivations", t2);
    }
  };
}
function _s({ apiHandler: e2 }) {
  return {
    changeItems({ id: t2, data: s }) {
      return e2.post(`subscriptions/${t2}/change-items`, s);
    },
    create({ data: t2 }) {
      return e2.post("subscriptions", t2);
    }
  };
}
function Hs({ apiHandler: e2 }) {
  return {
    /**
     * @param { rebilly.StorefrontGetTransactionCollectionRequest } request
     * @returns { rebilly.StorefrontGetTransactionCollectionResponsePromise } response
     */
    getAll({
      limit: t2 = null,
      offset: s = null,
      filter: n2 = null,
      q: r2 = null,
      sort: u = null
    } = {}) {
      const o2 = { limit: t2, offset: s, filter: n2, q: r2, sort: u };
      return e2.getAll("transactions", o2);
    },
    /**
     * @returns { rebilly.StorefrontGetTransactionResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`transactions/${t2}`);
    },
    finishKyc({ id: t2, token: s }) {
      return e2.post(`transactions/${t2}/${s}/continue`);
    },
    skipKyc({ id: t2, token: s }) {
      return e2.post(`transactions/${t2}/${s}/bypass`);
    },
    update({ id: t2, data: s }) {
      return e2.patch(`transactions/${t2}`, s);
    }
  };
}
function tn$1({ apiHandler: e2 }) {
  return {
    /**
     * @returns { rebilly.StorefrontGetWebsiteResponsePromise } response
     */
    get({ id: t2 }) {
      return e2.get(`websites/${t2}`);
    }
  };
}
let en$1 = class en {
  constructor({ apiHandler: t2 }) {
    this.account = Ps({ apiHandler: t2 }), this.authorization = Cs({ apiHandler: t2 }), this.billingPortals = js({ apiHandler: t2 }), this.checkoutForms = Ds({ apiHandler: t2 }), this.customFields = Ms({ apiHandler: t2 }), this.depositRequests = Os({ apiHandler: t2 }), this.deposit = Fs({ apiHandler: t2 }), this.depositStrategies = Ks({ apiHandler: t2 }), this.invoices = Bs({ apiHandler: t2 }), this.kycDocuments = Ls({ apiHandler: t2 }), this.kycLivenessSessions = Ns({ apiHandler: t2 }), this.kycRequests = zs({ apiHandler: t2 }), this.orders = Us({ apiHandler: t2 }), this.paymentInstruments = Vs({ apiHandler: t2 }), this.payoutRequests = Js({ apiHandler: t2 }), this.plans = Ws({ apiHandler: t2 }), this.products = Gs({ apiHandler: t2 }), this.purchase = Ys({ apiHandler: t2 }), this.quotes = Qs({ apiHandler: t2 }), this.readyToPayout = Xs({ apiHandler: t2 }), this.subscriptionReactivations = Zs({
      apiHandler: t2
    }), this.subscriptions = _s({ apiHandler: t2 }), this.transactions = Hs({ apiHandler: t2 }), this.websites = tn$1({ apiHandler: t2 }), this.checkoutForm = this.checkoutForms, this.billingPortal = this.billingPortals, this.addRequestInterceptor = t2.addRequestInterceptor, this.removeRequestInterceptor = t2.removeRequestInterceptor, this.addResponseInterceptor = t2.addResponseInterceptor, this.removeResponseInterceptor = t2.removeResponseInterceptor, this.setTimeout = t2.setTimeout, this.setProxyAgent = t2.setProxyAgent, this.setSessionToken = t2.setSessionToken, this.setPublishableKey = t2.setPublishableKey, this.setEndpoints = t2.setEndpoints, this.getCancellationToken = t2.getCancellationToken, this.generateSignature = t2.generateSignature;
  }
};
function sn({ apiHandler: e2 }) {
  return new ks({ apiHandler: e2 });
}
function nn$1({ apiHandler: e2 }) {
  return new xs({ apiHandler: e2 });
}
function rn$1({ apiHandler: e2 }) {
  return new en$1({ apiHandler: e2 });
}
const j$1 = {
  live: "https://api.rebilly.com",
  sandbox: "https://api-sandbox.rebilly.com"
}, D = 6e3;
function gn({
  apiKey: e2 = null,
  sandbox: t2 = false,
  timeout: s = D,
  organizationId: n2 = null,
  urls: r2 = j$1
} = {}) {
  if (!r2.live || !r2.sandbox)
    throw new Error(
      "RebillyAPI urls config must include a key for both `live` and `sandbox`"
    );
  if (typeof r2.live != "string" || typeof r2.sandbox != "string")
    throw new Error(
      "RebillyAPI urls config `live` and `sandbox` must be strings"
    );
  const o2 = C$1({ options: {
    apiEndpoints: r2,
    apiKey: e2,
    apiVersion: "",
    isSandbox: t2,
    requestTimeout: s,
    jwt: null,
    organizationId: n2
  } });
  return sn({ apiHandler: o2 });
}
function an$1({
  apiKey: e2 = null,
  sandbox: t2 = false,
  timeout: s = D,
  organizationId: n2 = null,
  urls: r2 = j$1
} = {}) {
  if (!r2.live || !r2.sandbox)
    throw new Error(
      "RebillyAPI urls config must include a key for both `live` and `sandbox`"
    );
  if (typeof r2.live != "string" || typeof r2.sandbox != "string")
    throw new Error(
      "RebillyAPI urls config `live` and `sandbox` must be strings"
    );
  const o2 = C$1({ options: {
    apiEndpoints: r2,
    apiKey: e2,
    apiVersion: "experimental",
    isSandbox: t2,
    requestTimeout: s,
    jwt: null,
    organizationId: n2
  } });
  return nn$1({ apiHandler: o2 });
}
function mn({
  publishableKey: e2 = null,
  jwt: t2 = null,
  sandbox: s = false,
  timeout: n2 = D,
  organizationId: r2 = null,
  urls: u = j$1
} = {}) {
  if (!u.live || !u.sandbox)
    throw new Error(
      "RebillyAPI urls config must include a key for both `live` and `sandbox`"
    );
  if (typeof u.live != "string" || typeof u.sandbox != "string")
    throw new Error(
      "RebillyAPI urls config `live` and `sandbox` must be strings"
    );
  const o2 = {
    apiEndpoints: u,
    publishableKey: e2,
    jwt: t2,
    apiVersion: "storefront",
    isSandbox: s,
    requestTimeout: n2,
    organizationId: r2
  }, l = C$1({ options: o2 });
  return l.setSessionToken(o2.jwt), rn$1({ apiHandler: l });
}
const TIMEOUT = 6e4;
function validateStateForStorefront() {
  validateStorefront(state.storefront);
  validateOptions$1(state.options);
}
async function Endpoint(callback) {
  try {
    validateStateForStorefront();
    return await callback();
  } catch (error2) {
    showError(error2);
    throw error2;
  }
}
class StorefrontInstance {
  constructor({
    publishableKey = null,
    jwt = null,
    organizationId = null,
    mode = "live",
    timeout = TIMEOUT,
    liveUrl = null,
    sandboxUrl = null
  } = {}) {
    const urls = {
      live: liveUrl || "https://api.rebilly.com",
      sandbox: sandboxUrl || "https://api-sandbox.rebilly.com"
    };
    const parsedTimeout = typeof timeout === "string" ? parseInt(timeout, 10) : timeout;
    const config = {
      organizationId: organizationId ? organizationId : void 0,
      sandbox: mode === "sandbox",
      timeout: Number.isNaN(parsedTimeout) ? TIMEOUT : parsedTimeout,
      urls
    };
    const api = mn(config);
    const rebilly = (
      // @ts-ignore refactor with above todo
      typeof gn.default === "function" ? (
        // @ts-ignore refactor with above todo
        gn.default(config)
      ) : gn(config)
    );
    const experimental = an$1(config);
    api.setSessionToken(publishableKey || jwt);
    rebilly.setSessionToken(publishableKey || jwt);
    experimental.setSessionToken(publishableKey || jwt);
    this.api = api;
    this.api.rebilly = rebilly;
    if (this.api.rebilly) {
      this.api.rebilly.experimental = experimental;
    }
    return this.api;
  }
}
const Storefront = (config = {}) => {
  return new StorefrontInstance(config);
};
const isObject = (val) => val != null && typeof val === "object";
const defaultOptions = {
  default: 1,
  minimum: 1,
  maximum: Number.MAX_SAFE_INTEGER,
  multipleOf: 1
};
function parseQuantity({ quantity }) {
  return isObject(quantity) ? { ...defaultOptions, ...quantity } : quantity;
}
function getQuantityValue(quantity) {
  return isObject(quantity) ? quantity.default : quantity;
}
function mapItemsQuantities(items2) {
  return items2.map(({ planId, quantity }) => ({
    planId,
    quantity: quantity && getQuantityValue(quantity)
  }));
}
function createQuantitiesMap(items2) {
  return items2.reduce((map, item) => {
    if (!item.planId || !item.quantity) return map;
    map.set(item.planId, toRaw(item.quantity));
    return map;
  }, /* @__PURE__ */ new Map());
}
function updateItemQuantityFromMap(quantitiesByPlanId) {
  return function updateQuantity(item) {
    if (!item.planId) return;
    const quantity = quantitiesByPlanId.get(item.planId) || item.quantity;
    if (item.quantity && isObject(quantity)) {
      quantity.default = getQuantityValue(item.quantity);
      item.quantity = quantity;
    }
  };
}
async function fetchSummary({
  data = null
} = {}) {
  return Endpoint(async () => {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s2, _t3, _u, _v, _w, _x, _y, _z;
    const items2 = (_a = state.options) == null ? void 0 : _a.items;
    const websiteId = ((_b = state.options) == null ? void 0 : _b.websiteId) || null;
    const bumpOfferProductsIds = ((_d = (_c = state.options) == null ? void 0 : _c.bumpOffer) == null ? void 0 : _d.map(({ planId }) => planId)) || [];
    const payload = {
      data: {
        websiteId: websiteId ?? void 0
      }
    };
    const isBumpOfferSummary = () => {
      var _a2, _b2;
      return (_b2 = (_a2 = state.data) == null ? void 0 : _a2.summaryLineItems) == null ? void 0 : _b2.every((item) => {
        if (item.planId == null) {
          return false;
        }
        return bumpOfferProductsIds.includes(item.planId);
      });
    };
    if (!isBumpOfferSummary() && !((_e2 = state.data) == null ? void 0 : _e2.acceptBumpOffer) && ((_f = state.data) == null ? void 0 : _f.summaryLineItems)) {
      payload.data.items = mapItemsQuantities(
        (_g = state.data) == null ? void 0 : _g.summaryLineItems
      );
    } else if (items2) {
      if ((_h = state.data) == null ? void 0 : _h.acceptBumpOffer) {
        payload.data.items = (_i = state.options) == null ? void 0 : _i.bumpOffer;
      } else {
        payload.data.items = mapItemsQuantities(items2 ?? []);
      }
    } else {
      if ((_j = state.data) == null ? void 0 : _j.summaryLineItems) {
        payload.data.items = mapItemsQuantities(
          state.data.summaryLineItems
        );
      }
      if (!((_k = state.data) == null ? void 0 : _k.acceptBumpOffer) && // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
      ((_n = (_m = (_l = state.data) == null ? void 0 : _l.previewPurchase) == null ? void 0 : _m.addonLineItems) == null ? void 0 : _n.length) > 0) {
        payload.data.items = (_p = (_o = payload.data) == null ? void 0 : _o.items) == null ? void 0 : _p.concat(
          // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
          state.data.previewPurchase.addonLineItems
        );
      }
    }
    if (!((_q = state.data) == null ? void 0 : _q.acceptBumpOffer) && // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
    ((_t3 = (_s2 = (_r = state.data) == null ? void 0 : _r.previewPurchase) == null ? void 0 : _s2.addonLineItems) == null ? void 0 : _t3.length) > 0) {
      payload.data.items = (_u = payload.data.items) == null ? void 0 : _u.concat(
        // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
        state.data.previewPurchase.addonLineItems
      );
    }
    if (payload.data.items && payload.data.items.length > 1) {
      const itemsStringified = payload.data.items.map(
        (item) => JSON.stringify(item)
      );
      const itemsSet = new Set(itemsStringified);
      const uniqueItems2 = Array.from(itemsSet).map(
        (item) => JSON.parse(item)
      );
      payload.data.items = uniqueItems2;
    }
    if ((_v = state.data) == null ? void 0 : _v.amountAndCurrency) {
      payload.data = {
        ...payload.data,
        ...state.data.amountAndCurrency
      };
    }
    if (data == null ? void 0 : data.billingAddress) {
      payload.data.billingAddress = data.billingAddress;
    }
    if (data == null ? void 0 : data.deliveryAddress) {
      payload.data.deliveryAddress = data.deliveryAddress;
    }
    if ((_w = state.data) == null ? void 0 : _w.couponIds) {
      payload.data.couponIds = state.data.couponIds;
    }
    validateStorefront(state.storefront);
    const { fields: summaryFields } = await state.storefront.purchase.preview(payload);
    let transformedFields = summaryFields;
    if (!((_x = state.data) == null ? void 0 : _x.acceptBumpOffer)) {
      const quantitiesByPlanId = createQuantitiesMap(items2 ?? []);
      transformedFields = cloneDeep$1(summaryFields);
      if (transformedFields.lineItems) {
        if ((_z = (_y = state.data) == null ? void 0 : _y.previewPurchase) == null ? void 0 : _z.addonLineItems) {
          const addonsMap = (
            // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
            state.data.previewPurchase.addonLineItems.reduce(
              // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
              (map, curr) => {
                map.set(curr.planId, curr);
                return map;
              },
              /* @__PURE__ */ new Map()
            )
          );
          transformedFields.lineItems = transformedFields.lineItems.filter(
            (item) => !addonsMap.has(item.planId)
          );
          transformedFields.addonLineItems = // @ts-ignore TODO: type "addonLineItems" once "views/common/iframe/events/update-addons-handler.js" is typed.
          state.data.previewPurchase.addonLineItems;
        }
        transformedFields.lineItems.forEach(
          updateItemQuantityFromMap(quantitiesByPlanId)
        );
      }
    }
    if (state.data) {
      state.data.previewPurchase = transformedFields;
    }
    return new SummaryModel(transformedFields);
  });
}
let loading = false;
async function itemsUpdatedHandler(iframe) {
  iframe.component.on(`${iframe.name}-update-items`, async (lineItems) => {
    try {
      if (loading) return;
      loading = true;
      const mappedItems = createQuantitiesMap(lineItems);
      state.data.summaryLineItems.forEach((item) => {
        const quantity = getQuantityValue(mappedItems.get(item.planId));
        if (isObject(item.quantity)) {
          item.quantity.default = quantity;
        } else {
          item.quantity = quantity;
        }
      });
      await fetchSummary();
      state.updateModel();
      loading = false;
    } catch (err) {
      console.error(err);
      loading = false;
    }
  });
}
async function mountSummary() {
  var _a, _b;
  const modelSafeState = state.toModel();
  const model = {
    options: modelSafeState.options,
    data: modelSafeState.data,
    mainStyleVars: modelSafeState.mainStyleVars
  };
  const paymentMethodsUrl = (_b = (_a = state.options) == null ? void 0 : _a._computed) == null ? void 0 : _b.paymentMethodsUrl;
  const name = "rebilly-instruments-summary";
  const iframe = await new ViewIframe2({
    name,
    url: `${paymentMethodsUrl}?name=${name}`,
    container: state.summary,
    model,
    route: {
      name: "summary"
    }
  });
  iframe.bindEventListeners({ loader: state.loader });
  iframes.summary = iframe;
  itemsUpdatedHandler(iframe);
  return {
    then: (callback) => callback()
  };
}
async function updateSummary({ instrument } = {}) {
  await fetchSummary({ data: instrument });
  state.updateModel();
}
var define_process_env_default = { NODE_ENV: "production" };
var z = function() {
  return z = Object.assign || function(t2) {
    for (var n2, a = 1, o2 = arguments.length; a < o2; a++) {
      n2 = arguments[a];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (t2[r2] = n2[r2]);
    }
    return t2;
  }, z.apply(this, arguments);
};
function F(e2, t2, n2, a) {
  function o2(r2) {
    return r2 instanceof n2 ? r2 : new n2(function(i) {
      i(r2);
    });
  }
  return new (n2 || (n2 = Promise))(function(r2, i) {
    function c(u) {
      try {
        s(a.next(u));
      } catch (f) {
        i(f);
      }
    }
    function l(u) {
      try {
        s(a.throw(u));
      } catch (f) {
        i(f);
      }
    }
    function s(u) {
      u.done ? r2(u.value) : o2(u.value).then(c, l);
    }
    s((a = a.apply(e2, [])).next());
  });
}
function W(e2, t2) {
  var n2 = { label: 0, sent: function() {
    if (r2[0] & 1) throw r2[1];
    return r2[1];
  }, trys: [], ops: [] }, a, o2, r2, i;
  return i = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function c(s) {
    return function(u) {
      return l([s, u]);
    };
  }
  function l(s) {
    if (a) throw new TypeError("Generator is already executing.");
    for (; i && (i = 0, s[0] && (n2 = 0)), n2; ) try {
      if (a = 1, o2 && (r2 = s[0] & 2 ? o2.return : s[0] ? o2.throw || ((r2 = o2.return) && r2.call(o2), 0) : o2.next) && !(r2 = r2.call(o2, s[1])).done) return r2;
      switch (o2 = 0, r2 && (s = [s[0] & 2, r2.value]), s[0]) {
        case 0:
        case 1:
          r2 = s;
          break;
        case 4:
          return n2.label++, { value: s[1], done: false };
        case 5:
          n2.label++, o2 = s[1], s = [0];
          continue;
        case 7:
          s = n2.ops.pop(), n2.trys.pop();
          continue;
        default:
          if (r2 = n2.trys, !(r2 = r2.length > 0 && r2[r2.length - 1]) && (s[0] === 6 || s[0] === 2)) {
            n2 = 0;
            continue;
          }
          if (s[0] === 3 && (!r2 || s[1] > r2[0] && s[1] < r2[3])) {
            n2.label = s[1];
            break;
          }
          if (s[0] === 6 && n2.label < r2[1]) {
            n2.label = r2[1], r2 = s;
            break;
          }
          if (r2 && n2.label < r2[2]) {
            n2.label = r2[2], n2.ops.push(s);
            break;
          }
          r2[2] && n2.ops.pop(), n2.trys.pop();
          continue;
      }
      s = t2.call(e2, n2);
    } catch (u) {
      s = [6, u], o2 = 0;
    } finally {
      a = r2 = 0;
    }
    if (s[0] & 5) throw s[1];
    return { value: s[0] ? s[1] : void 0, done: true };
  }
}
function ue(e2, t2, n2) {
  for (var a = 0, o2 = t2.length, r2; a < o2; a++)
    (r2 || !(a in t2)) && (r2 || (r2 = Array.prototype.slice.call(t2, 0, a)), r2[a] = t2[a]);
  return e2.concat(r2 || Array.prototype.slice.call(t2));
}
var se = "3.4.2";
function G2(e2, t2) {
  return new Promise(function(n2) {
    return setTimeout(n2, e2, t2);
  });
}
function ye(e2, t2) {
  t2 === void 0 && (t2 = 1 / 0);
  var n2 = window.requestIdleCallback;
  return n2 ? new Promise(function(a) {
    return n2.call(window, function() {
      return a();
    }, { timeout: t2 });
  }) : G2(Math.min(e2, t2));
}
function le(e2) {
  return !!e2 && typeof e2.then == "function";
}
function K(e2, t2) {
  try {
    var n2 = e2();
    le(n2) ? n2.then(function(a) {
      return t2(true, a);
    }, function(a) {
      return t2(false, a);
    }) : t2(true, n2);
  } catch (a) {
    t2(false, a);
  }
}
function _(e2, t2, n2) {
  return n2 === void 0 && (n2 = 16), F(this, void 0, void 0, function() {
    var a, o2, r2, i;
    return W(this, function(c) {
      switch (c.label) {
        case 0:
          a = Array(e2.length), o2 = Date.now(), r2 = 0, c.label = 1;
        case 1:
          return r2 < e2.length ? (a[r2] = t2(e2[r2], r2), i = Date.now(), i >= o2 + n2 ? (o2 = i, [4, G2(0)]) : [3, 3]) : [3, 4];
        case 2:
          c.sent(), c.label = 3;
        case 3:
          return ++r2, [3, 1];
        case 4:
          return [2, a];
      }
    });
  });
}
function Y(e2) {
  e2.then(void 0, function() {
  });
}
function Z(e2, t2) {
  e2 = [e2[0] >>> 16, e2[0] & 65535, e2[1] >>> 16, e2[1] & 65535], t2 = [t2[0] >>> 16, t2[0] & 65535, t2[1] >>> 16, t2[1] & 65535];
  var n2 = [0, 0, 0, 0];
  return n2[3] += e2[3] + t2[3], n2[2] += n2[3] >>> 16, n2[3] &= 65535, n2[2] += e2[2] + t2[2], n2[1] += n2[2] >>> 16, n2[2] &= 65535, n2[1] += e2[1] + t2[1], n2[0] += n2[1] >>> 16, n2[1] &= 65535, n2[0] += e2[0] + t2[0], n2[0] &= 65535, [n2[0] << 16 | n2[1], n2[2] << 16 | n2[3]];
}
function C(e2, t2) {
  e2 = [e2[0] >>> 16, e2[0] & 65535, e2[1] >>> 16, e2[1] & 65535], t2 = [t2[0] >>> 16, t2[0] & 65535, t2[1] >>> 16, t2[1] & 65535];
  var n2 = [0, 0, 0, 0];
  return n2[3] += e2[3] * t2[3], n2[2] += n2[3] >>> 16, n2[3] &= 65535, n2[2] += e2[2] * t2[3], n2[1] += n2[2] >>> 16, n2[2] &= 65535, n2[2] += e2[3] * t2[2], n2[1] += n2[2] >>> 16, n2[2] &= 65535, n2[1] += e2[1] * t2[3], n2[0] += n2[1] >>> 16, n2[1] &= 65535, n2[1] += e2[2] * t2[2], n2[0] += n2[1] >>> 16, n2[1] &= 65535, n2[1] += e2[3] * t2[1], n2[0] += n2[1] >>> 16, n2[1] &= 65535, n2[0] += e2[0] * t2[3] + e2[1] * t2[2] + e2[2] * t2[1] + e2[3] * t2[0], n2[0] &= 65535, [n2[0] << 16 | n2[1], n2[2] << 16 | n2[3]];
}
function A(e2, t2) {
  return t2 %= 64, t2 === 32 ? [e2[1], e2[0]] : t2 < 32 ? [e2[0] << t2 | e2[1] >>> 32 - t2, e2[1] << t2 | e2[0] >>> 32 - t2] : (t2 -= 32, [e2[1] << t2 | e2[0] >>> 32 - t2, e2[0] << t2 | e2[1] >>> 32 - t2]);
}
function L(e2, t2) {
  return t2 %= 64, t2 === 0 ? e2 : t2 < 32 ? [e2[0] << t2 | e2[1] >>> 32 - t2, e2[1] << t2] : [e2[1] << t2 - 32, 0];
}
function b(e2, t2) {
  return [e2[0] ^ t2[0], e2[1] ^ t2[1]];
}
function q(e2) {
  return e2 = b(e2, [0, e2[0] >>> 1]), e2 = C(e2, [4283543511, 3981806797]), e2 = b(e2, [0, e2[0] >>> 1]), e2 = C(e2, [3301882366, 444984403]), e2 = b(e2, [0, e2[0] >>> 1]), e2;
}
function we(e2, t2) {
  e2 = e2 || "", t2 = t2 || 0;
  var n2 = e2.length % 16, a = e2.length - n2, o2 = [0, t2], r2 = [0, t2], i = [0, 0], c = [0, 0], l = [2277735313, 289559509], s = [1291169091, 658871167], u;
  for (u = 0; u < a; u = u + 16)
    i = [
      e2.charCodeAt(u + 4) & 255 | (e2.charCodeAt(u + 5) & 255) << 8 | (e2.charCodeAt(u + 6) & 255) << 16 | (e2.charCodeAt(u + 7) & 255) << 24,
      e2.charCodeAt(u) & 255 | (e2.charCodeAt(u + 1) & 255) << 8 | (e2.charCodeAt(u + 2) & 255) << 16 | (e2.charCodeAt(u + 3) & 255) << 24
    ], c = [
      e2.charCodeAt(u + 12) & 255 | (e2.charCodeAt(u + 13) & 255) << 8 | (e2.charCodeAt(u + 14) & 255) << 16 | (e2.charCodeAt(u + 15) & 255) << 24,
      e2.charCodeAt(u + 8) & 255 | (e2.charCodeAt(u + 9) & 255) << 8 | (e2.charCodeAt(u + 10) & 255) << 16 | (e2.charCodeAt(u + 11) & 255) << 24
    ], i = C(i, l), i = A(i, 31), i = C(i, s), o2 = b(o2, i), o2 = A(o2, 27), o2 = Z(o2, r2), o2 = Z(C(o2, [0, 5]), [0, 1390208809]), c = C(c, s), c = A(c, 33), c = C(c, l), r2 = b(r2, c), r2 = A(r2, 31), r2 = Z(r2, o2), r2 = Z(C(r2, [0, 5]), [0, 944331445]);
  switch (i = [0, 0], c = [0, 0], n2) {
    case 15:
      c = b(c, L([0, e2.charCodeAt(u + 14)], 48));
    case 14:
      c = b(c, L([0, e2.charCodeAt(u + 13)], 40));
    case 13:
      c = b(c, L([0, e2.charCodeAt(u + 12)], 32));
    case 12:
      c = b(c, L([0, e2.charCodeAt(u + 11)], 24));
    case 11:
      c = b(c, L([0, e2.charCodeAt(u + 10)], 16));
    case 10:
      c = b(c, L([0, e2.charCodeAt(u + 9)], 8));
    case 9:
      c = b(c, [0, e2.charCodeAt(u + 8)]), c = C(c, s), c = A(c, 33), c = C(c, l), r2 = b(r2, c);
    case 8:
      i = b(i, L([0, e2.charCodeAt(u + 7)], 56));
    case 7:
      i = b(i, L([0, e2.charCodeAt(u + 6)], 48));
    case 6:
      i = b(i, L([0, e2.charCodeAt(u + 5)], 40));
    case 5:
      i = b(i, L([0, e2.charCodeAt(u + 4)], 32));
    case 4:
      i = b(i, L([0, e2.charCodeAt(u + 3)], 24));
    case 3:
      i = b(i, L([0, e2.charCodeAt(u + 2)], 16));
    case 2:
      i = b(i, L([0, e2.charCodeAt(u + 1)], 8));
    case 1:
      i = b(i, [0, e2.charCodeAt(u)]), i = C(i, l), i = A(i, 31), i = C(i, s), o2 = b(o2, i);
  }
  return o2 = b(o2, [0, e2.length]), r2 = b(r2, [0, e2.length]), o2 = Z(o2, r2), r2 = Z(r2, o2), o2 = q(o2), r2 = q(r2), o2 = Z(o2, r2), r2 = Z(r2, o2), ("00000000" + (o2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (o2[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (r2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (r2[1] >>> 0).toString(16)).slice(-8);
}
function Se(e2) {
  var t2;
  return z({ name: e2.name, message: e2.message, stack: (t2 = e2.stack) === null || t2 === void 0 ? void 0 : t2.split(`
`) }, e2);
}
function Le(e2, t2) {
  for (var n2 = 0, a = e2.length; n2 < a; ++n2)
    if (e2[n2] === t2)
      return true;
  return false;
}
function Ce(e2, t2) {
  return !Le(e2, t2);
}
function O(e2) {
  return parseInt(e2);
}
function x(e2) {
  return parseFloat(e2);
}
function V(e2, t2) {
  return typeof e2 == "number" && isNaN(e2) ? t2 : e2;
}
function k(e2) {
  return e2.reduce(function(t2, n2) {
    return t2 + (n2 ? 1 : 0);
  }, 0);
}
function fe(e2, t2) {
  if (t2 === void 0 && (t2 = 1), Math.abs(t2) >= 1)
    return Math.round(e2 / t2) * t2;
  var n2 = 1 / t2;
  return Math.round(e2 * n2) / n2;
}
function xe(e2) {
  for (var t2, n2, a = "Unexpected syntax '".concat(e2, "'"), o2 = /^\s*([a-z-]*)(.*)$/i.exec(e2), r2 = o2[1] || void 0, i = {}, c = /([.:#][\w-]+|\[.+?\])/gi, l = function(d2, v2) {
    i[d2] = i[d2] || [], i[d2].push(v2);
  }; ; ) {
    var s = c.exec(o2[2]);
    if (!s)
      break;
    var u = s[0];
    switch (u[0]) {
      case ".":
        l("class", u.slice(1));
        break;
      case "#":
        l("id", u.slice(1));
        break;
      case "[": {
        var f = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(u);
        if (f)
          l(f[1], (n2 = (t2 = f[4]) !== null && t2 !== void 0 ? t2 : f[5]) !== null && n2 !== void 0 ? n2 : "");
        else
          throw new Error(a);
        break;
      }
      default:
        throw new Error(a);
    }
  }
  return [r2, i];
}
function $(e2) {
  return e2 && typeof e2 == "object" && "message" in e2 ? e2 : { message: e2 };
}
function ke(e2) {
  return typeof e2 != "function";
}
function Ve(e2, t2) {
  var n2 = new Promise(function(a) {
    var o2 = Date.now();
    K(e2.bind(null, t2), function() {
      for (var r2 = [], i = 0; i < arguments.length; i++)
        r2[i] = arguments[i];
      var c = Date.now() - o2;
      if (!r2[0])
        return a(function() {
          return { error: $(r2[1]), duration: c };
        });
      var l = r2[1];
      if (ke(l))
        return a(function() {
          return { value: l, duration: c };
        });
      a(function() {
        return new Promise(function(s) {
          var u = Date.now();
          K(l, function() {
            for (var f = [], d2 = 0; d2 < arguments.length; d2++)
              f[d2] = arguments[d2];
            var v2 = c + Date.now() - u;
            if (!f[0])
              return s({ error: $(f[1]), duration: v2 });
            s({ value: f[1], duration: v2 });
          });
        });
      });
    });
  });
  return Y(n2), function() {
    return n2.then(function(o2) {
      return o2();
    });
  };
}
function Fe(e2, t2, n2) {
  var a = Object.keys(e2).filter(function(r2) {
    return Ce(n2, r2);
  }), o2 = _(a, function(r2) {
    return Ve(e2[r2], t2);
  });
  return Y(o2), function() {
    return F(this, void 0, void 0, function() {
      var i, c, l, s, u;
      return W(this, function(f) {
        switch (f.label) {
          case 0:
            return [4, o2];
          case 1:
            return i = f.sent(), [4, _(i, function(d2) {
              var v2 = d2();
              return Y(v2), v2;
            })];
          case 2:
            return c = f.sent(), [
              4,
              Promise.all(c)
              // Keeping the component keys order the same as the source keys order
            ];
          case 3:
            for (l = f.sent(), s = {}, u = 0; u < a.length; ++u)
              s[a[u]] = l[u];
            return [2, s];
        }
      });
    });
  };
}
function de() {
  var e2 = window, t2 = navigator;
  return k([
    "MSCSSMatrix" in e2,
    "msSetImmediate" in e2,
    "msIndexedDB" in e2,
    "msMaxTouchPoints" in t2,
    "msPointerEnabled" in t2
  ]) >= 4;
}
function We() {
  var e2 = window, t2 = navigator;
  return k(["msWriteProfilerMark" in e2, "MSStream" in e2, "msLaunchUri" in t2, "msSaveBlob" in t2]) >= 3 && !de();
}
function U() {
  var e2 = window, t2 = navigator;
  return k([
    "webkitPersistentStorage" in t2,
    "webkitTemporaryStorage" in t2,
    t2.vendor.indexOf("Google") === 0,
    "webkitResolveLocalFileSystemURL" in e2,
    "BatteryManager" in e2,
    "webkitMediaStream" in e2,
    "webkitSpeechGrammar" in e2
  ]) >= 5;
}
function j() {
  var e2 = window, t2 = navigator;
  return k([
    "ApplePayError" in e2,
    "CSSPrimitiveValue" in e2,
    "Counter" in e2,
    t2.vendor.indexOf("Apple") === 0,
    "getStorageUpdates" in t2,
    "WebKitMediaKeys" in e2
  ]) >= 4;
}
function Q() {
  var e2 = window;
  return k([
    "safari" in e2,
    !("DeviceMotionEvent" in e2),
    !("ongestureend" in e2),
    !("standalone" in navigator)
  ]) >= 3;
}
function Ze() {
  var e2, t2, n2 = window;
  return k([
    "buildID" in navigator,
    "MozAppearance" in ((t2 = (e2 = document.documentElement) === null || e2 === void 0 ? void 0 : e2.style) !== null && t2 !== void 0 ? t2 : {}),
    "onmozfullscreenchange" in n2,
    "mozInnerScreenX" in n2,
    "CSSMozDocumentRule" in n2,
    "CanvasCaptureMediaStream" in n2
  ]) >= 4;
}
function Re() {
  var e2 = window;
  return k([
    !("MediaSettingsRange" in e2),
    "RTCEncodedAudioFrame" in e2,
    "" + e2.Intl == "[object Intl]",
    "" + e2.Reflect == "[object Reflect]"
  ]) >= 3;
}
function Ae() {
  var e2 = window;
  return k([
    "DOMRectList" in e2,
    "RTCPeerConnectionIceEvent" in e2,
    "SVGGeometryElement" in e2,
    "ontransitioncancel" in e2
  ]) >= 3;
}
function Me() {
  if (navigator.platform === "iPad")
    return true;
  var e2 = screen, t2 = e2.width / e2.height;
  return k([
    "MediaSource" in window,
    !!Element.prototype.webkitRequestFullscreen,
    // iPhone 4S that runs iOS 9 matches this. But it won't match the criteria above, so it won't be detected as iPad.
    t2 > 0.65 && t2 < 1.53
  ]) >= 2;
}
function Ie() {
  var e2 = document;
  return e2.fullscreenElement || e2.msFullscreenElement || e2.mozFullScreenElement || e2.webkitFullscreenElement || null;
}
function Ge() {
  var e2 = document;
  return (e2.exitFullscreen || e2.msExitFullscreen || e2.mozCancelFullScreen || e2.webkitExitFullscreen).call(e2);
}
function me() {
  var e2 = U(), t2 = Ze();
  if (!e2 && !t2)
    return false;
  var n2 = window;
  return k([
    "onorientationchange" in n2,
    "orientation" in n2,
    e2 && !("SharedWorker" in n2),
    t2 && /android/i.test(navigator.appVersion)
  ]) >= 2;
}
function Ye() {
  var e2 = window, t2 = e2.OfflineAudioContext || e2.webkitOfflineAudioContext;
  if (!t2)
    return -2;
  if (je())
    return -1;
  var n2 = 4500, a = 5e3, o2 = new t2(1, a, 44100), r2 = o2.createOscillator();
  r2.type = "triangle", r2.frequency.value = 1e4;
  var i = o2.createDynamicsCompressor();
  i.threshold.value = -50, i.knee.value = 40, i.ratio.value = 12, i.attack.value = 0, i.release.value = 0.25, r2.connect(i), i.connect(o2.destination), r2.start(0);
  var c = Pe(o2), l = c[0], s = c[1], u = l.then(function(f) {
    return Xe(f.getChannelData(0).subarray(n2));
  }, function(f) {
    if (f.name === "timeout" || f.name === "suspended")
      return -3;
    throw f;
  });
  return Y(u), function() {
    return s(), u;
  };
}
function je() {
  return j() && !Q() && !Ae();
}
function Pe(e2) {
  var t2 = 3, n2 = 500, a = 500, o2 = 5e3, r2 = function() {
  }, i = new Promise(function(c, l) {
    var s = false, u = 0, f = 0;
    e2.oncomplete = function(h) {
      return c(h.renderedBuffer);
    };
    var d2 = function() {
      setTimeout(function() {
        return l(ee(
          "timeout"
          /* InnerErrorName.Timeout */
        ));
      }, Math.min(a, f + o2 - Date.now()));
    }, v2 = function() {
      try {
        var h = e2.startRendering();
        switch (le(h) && Y(h), e2.state) {
          case "running":
            f = Date.now(), s && d2();
            break;
          case "suspended":
            document.hidden || u++, s && u >= t2 ? l(ee(
              "suspended"
              /* InnerErrorName.Suspended */
            )) : setTimeout(v2, n2);
            break;
        }
      } catch (y) {
        l(y);
      }
    };
    v2(), r2 = function() {
      s || (s = true, f > 0 && d2());
    };
  });
  return [i, r2];
}
function Xe(e2) {
  for (var t2 = 0, n2 = 0; n2 < e2.length; ++n2)
    t2 += Math.abs(e2[n2]);
  return t2;
}
function ee(e2) {
  var t2 = new Error(e2);
  return t2.name = e2, t2;
}
function ve(e2, t2, n2) {
  var a, o2, r2;
  return n2 === void 0 && (n2 = 50), F(this, void 0, void 0, function() {
    var i, c;
    return W(this, function(l) {
      switch (l.label) {
        case 0:
          i = document, l.label = 1;
        case 1:
          return i.body ? [3, 3] : [4, G2(n2)];
        case 2:
          return l.sent(), [3, 1];
        case 3:
          c = i.createElement("iframe"), l.label = 4;
        case 4:
          return l.trys.push([4, , 10, 11]), [4, new Promise(function(s, u) {
            var f = false, d2 = function() {
              f = true, s();
            }, v2 = function(g) {
              f = true, u(g);
            };
            c.onload = d2, c.onerror = v2;
            var h = c.style;
            h.setProperty("display", "block", "important"), h.position = "absolute", h.top = "0", h.left = "0", h.visibility = "hidden", t2 && "srcdoc" in c ? c.srcdoc = t2 : c.src = "about:blank", i.body.appendChild(c);
            var y = function() {
              var g, w2;
              f || (((w2 = (g = c.contentWindow) === null || g === void 0 ? void 0 : g.document) === null || w2 === void 0 ? void 0 : w2.readyState) === "complete" ? d2() : setTimeout(y, 10));
            };
            y();
          })];
        case 5:
          l.sent(), l.label = 6;
        case 6:
          return !((o2 = (a = c.contentWindow) === null || a === void 0 ? void 0 : a.document) === null || o2 === void 0) && o2.body ? [3, 8] : [4, G2(n2)];
        case 7:
          return l.sent(), [3, 6];
        case 8:
          return [4, e2(c, c.contentWindow)];
        case 9:
          return [2, l.sent()];
        case 10:
          return (r2 = c.parentNode) === null || r2 === void 0 || r2.removeChild(c), [
            7
            /*endfinally*/
          ];
        case 11:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function De(e2) {
  for (var t2 = xe(e2), n2 = t2[0], a = t2[1], o2 = document.createElement(n2 ?? "div"), r2 = 0, i = Object.keys(a); r2 < i.length; r2++) {
    var c = i[r2], l = a[c].join(" ");
    c === "style" ? Te(o2.style, l) : o2.setAttribute(c, l);
  }
  return o2;
}
function Te(e2, t2) {
  for (var n2 = 0, a = t2.split(";"); n2 < a.length; n2++) {
    var o2 = a[n2], r2 = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(o2);
    if (r2) {
      var i = r2[1], c = r2[2], l = r2[4];
      e2.setProperty(i, c, l || "");
    }
  }
}
var Ee = "mmMwWLliI0O&1", He = "48px", M = ["monospace", "sans-serif", "serif"], te = [
  // This is android-specific font from "Roboto" family
  "sans-serif-thin",
  "ARNO PRO",
  "Agency FB",
  "Arabic Typesetting",
  "Arial Unicode MS",
  "AvantGarde Bk BT",
  "BankGothic Md BT",
  "Batang",
  "Bitstream Vera Sans Mono",
  "Calibri",
  "Century",
  "Century Gothic",
  "Clarendon",
  "EUROSTILE",
  "Franklin Gothic",
  "Futura Bk BT",
  "Futura Md BT",
  "GOTHAM",
  "Gill Sans",
  "HELV",
  "Haettenschweiler",
  "Helvetica Neue",
  "Humanst521 BT",
  "Leelawadee",
  "Letter Gothic",
  "Levenim MT",
  "Lucida Bright",
  "Lucida Sans",
  "Menlo",
  "MS Mincho",
  "MS Outlook",
  "MS Reference Specialty",
  "MS UI Gothic",
  "MT Extra",
  "MYRIAD PRO",
  "Marlett",
  "Meiryo UI",
  "Microsoft Uighur",
  "Minion Pro",
  "Monotype Corsiva",
  "PMingLiU",
  "Pristina",
  "SCRIPTINA",
  "Segoe UI Light",
  "Serifa",
  "SimHei",
  "Small Fonts",
  "Staccato222 BT",
  "TRAJAN PRO",
  "Univers CE 55 Medium",
  "Vrinda",
  "ZWAdobeF"
];
function Je() {
  return ve(function(e2, t2) {
    var n2 = t2.document, a = n2.body;
    a.style.fontSize = He;
    var o2 = n2.createElement("div"), r2 = {}, i = {}, c = function(y) {
      var g = n2.createElement("span"), w2 = g.style;
      return w2.position = "absolute", w2.top = "0", w2.left = "0", w2.fontFamily = y, g.textContent = Ee, o2.appendChild(g), g;
    }, l = function(y, g) {
      return c("'".concat(y, "',").concat(g));
    }, s = function() {
      return M.map(c);
    }, u = function() {
      for (var y = {}, g = function(P2) {
        y[P2] = M.map(function(T2) {
          return l(P2, T2);
        });
      }, w2 = 0, R2 = te; w2 < R2.length; w2++) {
        var D2 = R2[w2];
        g(D2);
      }
      return y;
    }, f = function(y) {
      return M.some(function(g, w2) {
        return y[w2].offsetWidth !== r2[g] || y[w2].offsetHeight !== i[g];
      });
    }, d2 = s(), v2 = u();
    a.appendChild(o2);
    for (var h = 0; h < M.length; h++)
      r2[M[h]] = d2[h].offsetWidth, i[M[h]] = d2[h].offsetHeight;
    return te.filter(function(y) {
      return f(v2[y]);
    });
  });
}
function ze() {
  var e2 = navigator.plugins;
  if (e2) {
    for (var t2 = [], n2 = 0; n2 < e2.length; ++n2) {
      var a = e2[n2];
      if (a) {
        for (var o2 = [], r2 = 0; r2 < a.length; ++r2) {
          var i = a[r2];
          o2.push({
            type: i.type,
            suffixes: i.suffixes
          });
        }
        t2.push({
          name: a.name,
          description: a.description,
          mimeTypes: o2
        });
      }
    }
    return t2;
  }
}
function Ne() {
  var e2 = false, t2, n2, a = Be(), o2 = a[0], r2 = a[1];
  if (!Oe(o2, r2))
    t2 = n2 = "";
  else {
    e2 = Ue(r2), Qe(o2, r2);
    var i = E(o2), c = E(o2);
    i !== c ? t2 = n2 = "unstable" : (n2 = i, Ke(o2, r2), t2 = E(o2));
  }
  return { winding: e2, geometry: t2, text: n2 };
}
function Be() {
  var e2 = document.createElement("canvas");
  return e2.width = 1, e2.height = 1, [e2, e2.getContext("2d")];
}
function Oe(e2, t2) {
  return !!(t2 && e2.toDataURL);
}
function Ue(e2) {
  return e2.rect(0, 0, 10, 10), e2.rect(2, 2, 6, 6), !e2.isPointInPath(5, 5, "evenodd");
}
function Qe(e2, t2) {
  e2.width = 240, e2.height = 60, t2.textBaseline = "alphabetic", t2.fillStyle = "#f60", t2.fillRect(100, 1, 62, 20), t2.fillStyle = "#069", t2.font = '11pt "Times New Roman"';
  var n2 = "Cwm fjordbank gly ".concat(
    ""
    /*  */
  );
  t2.fillText(n2, 2, 15), t2.fillStyle = "rgba(102, 204, 0, 0.2)", t2.font = "18pt Arial", t2.fillText(n2, 4, 45);
}
function Ke(e2, t2) {
  e2.width = 122, e2.height = 110, t2.globalCompositeOperation = "multiply";
  for (var n2 = 0, a = [
    ["#f2f", 40, 40],
    ["#2ff", 80, 40],
    ["#ff2", 60, 80]
  ]; n2 < a.length; n2++) {
    var o2 = a[n2], r2 = o2[0], i = o2[1], c = o2[2];
    t2.fillStyle = r2, t2.beginPath(), t2.arc(i, c, 40, 0, Math.PI * 2, true), t2.closePath(), t2.fill();
  }
  t2.fillStyle = "#f9c", t2.arc(60, 60, 60, 0, Math.PI * 2, true), t2.arc(60, 60, 20, 0, Math.PI * 2, true), t2.fill("evenodd");
}
function E(e2) {
  return e2.toDataURL();
}
function _e() {
  var e2 = navigator, t2 = 0, n2;
  e2.maxTouchPoints !== void 0 ? t2 = O(e2.maxTouchPoints) : e2.msMaxTouchPoints !== void 0 && (t2 = e2.msMaxTouchPoints);
  try {
    document.createEvent("TouchEvent"), n2 = true;
  } catch {
    n2 = false;
  }
  var a = "ontouchstart" in window;
  return {
    maxTouchPoints: t2,
    touchEvent: n2,
    touchStart: a
  };
}
function qe() {
  return navigator.oscpu;
}
function $e() {
  var e2 = navigator, t2 = [], n2 = e2.language || e2.userLanguage || e2.browserLanguage || e2.systemLanguage;
  if (n2 !== void 0 && t2.push([n2]), Array.isArray(e2.languages))
    U() && Re() || t2.push(e2.languages);
  else if (typeof e2.languages == "string") {
    var a = e2.languages;
    a && t2.push(a.split(","));
  }
  return t2;
}
function et() {
  return window.screen.colorDepth;
}
function tt() {
  return V(x(navigator.deviceMemory), void 0);
}
function nt() {
  var e2 = screen, t2 = function(a) {
    return V(O(a), null);
  }, n2 = [t2(e2.width), t2(e2.height)];
  return n2.sort().reverse(), n2;
}
var rt = 2500, at2 = 10, X, H;
function ot() {
  if (H === void 0) {
    var e2 = function() {
      var t2 = N();
      B(t2) ? H = setTimeout(e2, rt) : (X = t2, H = void 0);
    };
    e2();
  }
}
function it() {
  var e2 = this;
  return ot(), function() {
    return F(e2, void 0, void 0, function() {
      var t2;
      return W(this, function(n2) {
        switch (n2.label) {
          case 0:
            return t2 = N(), B(t2) ? X ? [2, ue([], X)] : Ie() ? [4, Ge()] : [3, 2] : [3, 2];
          case 1:
            n2.sent(), t2 = N(), n2.label = 2;
          case 2:
            return B(t2) || (X = t2), [2, t2];
        }
      });
    });
  };
}
function ct() {
  var e2 = this, t2 = it();
  return function() {
    return F(e2, void 0, void 0, function() {
      var n2, a;
      return W(this, function(o2) {
        switch (o2.label) {
          case 0:
            return [4, t2()];
          case 1:
            return n2 = o2.sent(), a = function(r2) {
              return r2 === null ? null : fe(r2, at2);
            }, [2, [a(n2[0]), a(n2[1]), a(n2[2]), a(n2[3])]];
        }
      });
    });
  };
}
function N() {
  var e2 = screen;
  return [
    V(x(e2.availTop), null),
    V(x(e2.width) - x(e2.availWidth) - V(x(e2.availLeft), 0), null),
    V(x(e2.height) - x(e2.availHeight) - V(x(e2.availTop), 0), null),
    V(x(e2.availLeft), null)
  ];
}
function B(e2) {
  for (var t2 = 0; t2 < 4; ++t2)
    if (e2[t2])
      return false;
  return true;
}
function ut() {
  return V(O(navigator.hardwareConcurrency), void 0);
}
function st() {
  var e2, t2 = (e2 = window.Intl) === null || e2 === void 0 ? void 0 : e2.DateTimeFormat;
  if (t2) {
    var n2 = new t2().resolvedOptions().timeZone;
    if (n2)
      return n2;
  }
  var a = -lt();
  return "UTC".concat(a >= 0 ? "+" : "").concat(Math.abs(a));
}
function lt() {
  var e2 = (/* @__PURE__ */ new Date()).getFullYear();
  return Math.max(
    // `getTimezoneOffset` returns a number as a string in some unidentified cases
    x(new Date(e2, 0, 1).getTimezoneOffset()),
    x(new Date(e2, 6, 1).getTimezoneOffset())
  );
}
function ft2() {
  try {
    return !!window.sessionStorage;
  } catch {
    return true;
  }
}
function dt() {
  try {
    return !!window.localStorage;
  } catch {
    return true;
  }
}
function mt2() {
  if (!(de() || We()))
    try {
      return !!window.indexedDB;
    } catch {
      return true;
    }
}
function vt() {
  return !!window.openDatabase;
}
function ht2() {
  return navigator.cpuClass;
}
function pt2() {
  var e2 = navigator.platform;
  return e2 === "MacIntel" && j() && !Q() ? Me() ? "iPad" : "iPhone" : e2;
}
function gt() {
  return navigator.vendor || "";
}
function bt2() {
  for (var e2 = [], t2 = 0, n2 = [
    // Blink and some browsers on iOS
    "chrome",
    // Safari on macOS
    "safari",
    // Chrome on iOS (checked in 85 on 13 and 87 on 14)
    "__crWeb",
    "__gCrWeb",
    // Yandex Browser on iOS, macOS and Android (checked in 21.2 on iOS 14, macOS and Android)
    "yandex",
    // Yandex Browser on iOS (checked in 21.2 on 14)
    "__yb",
    "__ybro",
    // Firefox on iOS (checked in 32 on 14)
    "__firefox__",
    // Edge on iOS (checked in 46 on 14)
    "__edgeTrackingPreventionStatistics",
    "webkit",
    // Opera Touch on iOS (checked in 2.6 on 14)
    "oprt",
    // Samsung Internet on Android (checked in 11.1)
    "samsungAr",
    // UC Browser on Android (checked in 12.10 and 13.0)
    "ucweb",
    "UCShellJava",
    // Puffin on Android (checked in 9.0)
    "puffinDevice"
    // UC on iOS and Opera on Android have no specific global variables
    // Edge for Android isn't checked
  ]; t2 < n2.length; t2++) {
    var a = n2[t2], o2 = window[a];
    o2 && typeof o2 == "object" && e2.push(a);
  }
  return e2.sort();
}
function yt2() {
  var e2 = document;
  try {
    e2.cookie = "cookietest=1; SameSite=Strict;";
    var t2 = e2.cookie.indexOf("cookietest=") !== -1;
    return e2.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", t2;
  } catch {
    return false;
  }
}
function wt() {
  var e2 = atob;
  return {
    abpIndo: [
      "#Iklan-Melayang",
      "#Kolom-Iklan-728",
      "#SidebarIklan-wrapper",
      '[title="ALIENBOLA" i]',
      e2("I0JveC1CYW5uZXItYWRz")
    ],
    abpvn: [".quangcao", "#mobileCatfish", e2("LmNsb3NlLWFkcw=="), '[id^="bn_bottom_fixed_"]', "#pmadv"],
    adBlockFinland: [
      ".mainostila",
      e2("LnNwb25zb3JpdA=="),
      ".ylamainos",
      e2("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")
    ],
    adBlockPersian: [
      "#navbar_notice_50",
      ".kadr",
      'TABLE[width="140px"]',
      "#divAgahi",
      e2("YVtocmVmXj0iaHR0cDovL2cxLnYuZndtcm0ubmV0L2FkLyJd")
    ],
    adBlockWarningRemoval: [
      "#adblock-honeypot",
      ".adblocker-root",
      ".wp_adblock_detect",
      e2("LmhlYWRlci1ibG9ja2VkLWFk"),
      e2("I2FkX2Jsb2NrZXI=")
    ],
    adGuardAnnoyances: [
      ".hs-sosyal",
      "#cookieconsentdiv",
      'div[class^="app_gdpr"]',
      ".as-oil",
      '[data-cypress="soft-push-notification-modal"]'
    ],
    adGuardBase: [
      ".BetterJsPopOverlay",
      e2("I2FkXzMwMFgyNTA="),
      e2("I2Jhbm5lcmZsb2F0MjI="),
      e2("I2NhbXBhaWduLWJhbm5lcg=="),
      e2("I0FkLUNvbnRlbnQ=")
    ],
    adGuardChinese: [
      e2("LlppX2FkX2FfSA=="),
      e2("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"),
      "#widget-quan",
      e2("YVtocmVmKj0iLzg0OTkyMDIwLnh5eiJd"),
      e2("YVtocmVmKj0iLjE5NTZobC5jb20vIl0=")
    ],
    adGuardFrench: [
      "#pavePub",
      e2("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"),
      ".mobile_adhesion",
      ".widgetadv",
      e2("LmFkc19iYW4=")
    ],
    adGuardGerman: ['aside[data-portal-id="leaderboard"]'],
    adGuardJapanese: [
      "#kauli_yad_1",
      e2("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="),
      e2("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="),
      e2("LmFkZ29vZ2xl"),
      e2("Ll9faXNib29zdFJldHVybkFk")
    ],
    adGuardMobile: [
      e2("YW1wLWF1dG8tYWRz"),
      e2("LmFtcF9hZA=="),
      'amp-embed[type="24smi"]',
      "#mgid_iframe1",
      e2("I2FkX2ludmlld19hcmVh")
    ],
    adGuardRussian: [
      e2("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="),
      e2("LnJlY2xhbWE="),
      'div[id^="smi2adblock"]',
      e2("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"),
      "#psyduckpockeball"
    ],
    adGuardSocial: [
      e2("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="),
      e2("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="),
      ".etsy-tweet",
      "#inlineShare",
      ".popup-social"
    ],
    adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", ".cnt-publi"],
    adGuardTrackingProtection: [
      "#qoo-counter",
      e2("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="),
      e2("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="),
      e2("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="),
      "#top100counter"
    ],
    adGuardTurkish: [
      "#backkapat",
      e2("I3Jla2xhbWk="),
      e2("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="),
      e2("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"),
      e2("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")
    ],
    bulgarian: [e2("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers"],
    easyList: [
      ".yb-floorad",
      e2("LndpZGdldF9wb19hZHNfd2lkZ2V0"),
      e2("LnRyYWZmaWNqdW5reS1hZA=="),
      ".textad_headline",
      e2("LnNwb25zb3JlZC10ZXh0LWxpbmtz")
    ],
    easyListChina: [
      e2("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="),
      e2("LmZyb250cGFnZUFkdk0="),
      "#taotaole",
      "#aafoot.top_box",
      ".cfa_popup"
    ],
    easyListCookie: [
      ".ezmob-footer",
      ".cc-CookieWarning",
      "[data-cookie-number]",
      e2("LmF3LWNvb2tpZS1iYW5uZXI="),
      ".sygnal24-gdpr-modal-wrap"
    ],
    easyListCzechSlovak: [
      "#onlajny-stickers",
      e2("I3Jla2xhbW5pLWJveA=="),
      e2("LnJla2xhbWEtbWVnYWJvYXJk"),
      ".sklik",
      e2("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")
    ],
    easyListDutch: [
      e2("I2FkdmVydGVudGll"),
      e2("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="),
      ".adstekst",
      e2("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="),
      "#semilo-lrectangle"
    ],
    easyListGermany: [
      "#SSpotIMPopSlider",
      e2("LnNwb25zb3JsaW5rZ3J1ZW4="),
      e2("I3dlcmJ1bmdza3k="),
      e2("I3Jla2xhbWUtcmVjaHRzLW1pdHRl"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9iZDc0Mi5jb20vIl0=")
    ],
    easyListItaly: [
      e2("LmJveF9hZHZfYW5udW5jaQ=="),
      ".sb-box-pubbliredazionale",
      e2("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")
    ],
    easyListLithuania: [
      e2("LnJla2xhbW9zX3RhcnBhcw=="),
      e2("LnJla2xhbW9zX251b3JvZG9z"),
      e2("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"),
      e2("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"),
      e2("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")
    ],
    estonian: [e2("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
    fanboyAnnoyances: ["#ac-lre-player", ".navigate-to-top", "#subscribe_popup", ".newsletter_holder", "#back-top"],
    fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
    fanboyEnhancedTrackers: [
      ".open.pushModal",
      "#issuem-leaky-paywall-articles-zero-remaining-nag",
      "#sovrn_container",
      'div[class$="-hide"][zoompage-fontsize][style="display: block;"]',
      ".BlockNag__Card"
    ],
    fanboySocial: ["#FollowUs", "#meteored_share", "#social_follow", ".article-sharer", ".community__social-desc"],
    frellwitSwedish: [
      e2("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="),
      e2("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="),
      "article.category-samarbete",
      e2("ZGl2LmhvbGlkQWRz"),
      "ul.adsmodern"
    ],
    greekAdBlock: [
      e2("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"),
      e2("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="),
      e2("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"),
      "DIV.agores300",
      "TABLE.advright"
    ],
    hungarian: [
      "#cemp_doboz",
      ".optimonk-iframe-container",
      e2("LmFkX19tYWlu"),
      e2("W2NsYXNzKj0iR29vZ2xlQWRzIl0="),
      "#hirdetesek_box"
    ],
    iDontCareAboutCookies: [
      '.alert-info[data-block-track*="CookieNotice"]',
      ".ModuleTemplateCookieIndicator",
      ".o--cookies--container",
      "#cookies-policy-sticky",
      "#stickyCookieBar"
    ],
    icelandicAbp: [e2("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
    latvian: [
      e2("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="),
      e2("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")
    ],
    listKr: [
      e2("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="),
      e2("I2xpdmVyZUFkV3JhcHBlcg=="),
      e2("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="),
      e2("aW5zLmZhc3R2aWV3LWFk"),
      ".revenue_unit_item.dable"
    ],
    listeAr: [
      e2("LmdlbWluaUxCMUFk"),
      ".right-and-left-sponsers",
      e2("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="),
      e2("YVtocmVmKj0iYm9vcmFxLm9yZyJd"),
      e2("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")
    ],
    listeFr: [
      e2("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="),
      e2("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="),
      e2("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="),
      ".site-pub-interstitiel",
      'div[id^="crt-"][data-criteo-id]'
    ],
    officialPolish: [
      "#ceneo-placeholder-ceneo-12",
      e2("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"),
      e2("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="),
      e2("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="),
      e2("ZGl2I3NrYXBpZWNfYWQ=")
    ],
    ro: [
      e2("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"),
      e2("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="),
      e2("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd"),
      'a[href^="/url/"]'
    ],
    ruAd: [
      e2("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"),
      e2("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="),
      e2("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="),
      "#pgeldiz",
      ".yandex-rtb-block"
    ],
    thaiAds: [
      "a[href*=macau-uta-popup]",
      e2("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="),
      e2("LmFkczMwMHM="),
      ".bumq",
      ".img-kosana"
    ],
    webAnnoyancesUltralist: [
      "#mod-social-share-2",
      "#social-tools",
      e2("LmN0cGwtZnVsbGJhbm5lcg=="),
      ".zergnet-recommend",
      ".yt.btn-link.btn-md.btn"
    ]
  };
}
function St(e2) {
  var t2 = e2 === void 0 ? {} : e2, n2 = t2.debug;
  return F(this, void 0, void 0, function() {
    var a, o2, r2, i, c, l;
    return W(this, function(s) {
      switch (s.label) {
        case 0:
          return Lt() ? (a = wt(), o2 = Object.keys(a), r2 = (l = []).concat.apply(l, o2.map(function(u) {
            return a[u];
          })), [4, Ct(r2)]) : [2, void 0];
        case 1:
          return i = s.sent(), n2 && xt(a, i), c = o2.filter(function(u) {
            var f = a[u], d2 = k(f.map(function(v2) {
              return i[v2];
            }));
            return d2 > f.length * 0.6;
          }), c.sort(), [2, c];
      }
    });
  });
}
function Lt() {
  return j() || me();
}
function Ct(e2) {
  var t2;
  return F(this, void 0, void 0, function() {
    var n2, a, o2, r2, l, i, c, l;
    return W(this, function(s) {
      switch (s.label) {
        case 0:
          for (n2 = document, a = n2.createElement("div"), o2 = new Array(e2.length), r2 = {}, ne(a), l = 0; l < e2.length; ++l)
            i = De(e2[l]), i.tagName === "DIALOG" && i.show(), c = n2.createElement("div"), ne(c), c.appendChild(i), a.appendChild(c), o2[l] = i;
          s.label = 1;
        case 1:
          return n2.body ? [3, 3] : [4, G2(50)];
        case 2:
          return s.sent(), [3, 1];
        case 3:
          n2.body.appendChild(a);
          try {
            for (l = 0; l < e2.length; ++l)
              o2[l].offsetParent || (r2[e2[l]] = true);
          } finally {
            (t2 = a.parentNode) === null || t2 === void 0 || t2.removeChild(a);
          }
          return [2, r2];
      }
    });
  });
}
function ne(e2) {
  e2.style.setProperty("display", "block", "important");
}
function xt(e2, t2) {
  for (var n2 = "DOM blockers debug:\n```", a = 0, o2 = Object.keys(e2); a < o2.length; a++) {
    var r2 = o2[a];
    n2 += `
`.concat(r2, ":");
    for (var i = 0, c = e2[r2]; i < c.length; i++) {
      var l = c[i];
      n2 += `
  `.concat(t2[l] ? "" : "", " ").concat(l);
    }
  }
  console.log("".concat(n2, "\n```"));
}
function kt() {
  for (var e2 = 0, t2 = ["rec2020", "p3", "srgb"]; e2 < t2.length; e2++) {
    var n2 = t2[e2];
    if (matchMedia("(color-gamut: ".concat(n2, ")")).matches)
      return n2;
  }
}
function Vt() {
  if (re("inverted"))
    return true;
  if (re("none"))
    return false;
}
function re(e2) {
  return matchMedia("(inverted-colors: ".concat(e2, ")")).matches;
}
function Ft() {
  if (ae("active"))
    return true;
  if (ae("none"))
    return false;
}
function ae(e2) {
  return matchMedia("(forced-colors: ".concat(e2, ")")).matches;
}
var Wt = 100;
function Zt() {
  if (matchMedia("(min-monochrome: 0)").matches) {
    for (var e2 = 0; e2 <= Wt; ++e2)
      if (matchMedia("(max-monochrome: ".concat(e2, ")")).matches)
        return e2;
    throw new Error("Too high value");
  }
}
function Rt2() {
  if (I("no-preference"))
    return 0;
  if (I("high") || I("more"))
    return 1;
  if (I("low") || I("less"))
    return -1;
  if (I("forced"))
    return 10;
}
function I(e2) {
  return matchMedia("(prefers-contrast: ".concat(e2, ")")).matches;
}
function At2() {
  if (oe("reduce"))
    return true;
  if (oe("no-preference"))
    return false;
}
function oe(e2) {
  return matchMedia("(prefers-reduced-motion: ".concat(e2, ")")).matches;
}
function Mt() {
  if (ie("high"))
    return true;
  if (ie("standard"))
    return false;
}
function ie(e2) {
  return matchMedia("(dynamic-range: ".concat(e2, ")")).matches;
}
var m = Math, S = function() {
  return 0;
};
function It() {
  var e2 = m.acos || S, t2 = m.acosh || S, n2 = m.asin || S, a = m.asinh || S, o2 = m.atanh || S, r2 = m.atan || S, i = m.sin || S, c = m.sinh || S, l = m.cos || S, s = m.cosh || S, u = m.tan || S, f = m.tanh || S, d2 = m.exp || S, v2 = m.expm1 || S, h = m.log1p || S, y = function(p2) {
    return m.pow(m.PI, p2);
  }, g = function(p2) {
    return m.log(p2 + m.sqrt(p2 * p2 - 1));
  }, w2 = function(p2) {
    return m.log(p2 + m.sqrt(p2 * p2 + 1));
  }, R2 = function(p2) {
    return m.log((1 + p2) / (1 - p2)) / 2;
  }, D2 = function(p2) {
    return m.exp(p2) - 1 / m.exp(p2) / 2;
  }, P2 = function(p2) {
    return (m.exp(p2) + 1 / m.exp(p2)) / 2;
  }, T2 = function(p2) {
    return m.exp(p2) - 1;
  }, ge2 = function(p2) {
    return (m.exp(2 * p2) - 1) / (m.exp(2 * p2) + 1);
  }, be2 = function(p2) {
    return m.log(1 + p2);
  };
  return {
    acos: e2(0.12312423423423424),
    acosh: t2(1e308),
    acoshPf: g(1e154),
    asin: n2(0.12312423423423424),
    asinh: a(1),
    asinhPf: w2(1),
    atanh: o2(0.5),
    atanhPf: R2(0.5),
    atan: r2(0.5),
    sin: i(-1e300),
    sinh: c(1),
    sinhPf: D2(1),
    cos: l(10.000000000123),
    cosh: s(1),
    coshPf: P2(1),
    tan: u(-1e300),
    tanh: f(1),
    tanhPf: ge2(1),
    exp: d2(1),
    expm1: v2(1),
    expm1Pf: T2(1),
    log1p: h(10),
    log1pPf: be2(10),
    powPI: y(-100)
  };
}
var Gt = "mmMwWLliI0fiflO&1", J = {
  /**
   * The default font. User can change it in desktop Chrome, desktop Firefox, IE 11,
   * Android Chrome (but only when the size is  than the default) and Android Firefox.
   */
  default: [],
  /** OS font on macOS. User can change its size and weight. Applies after Safari restart. */
  apple: [{ font: "-apple-system-body" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  serif: [{ fontFamily: "serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  sans: [{ fontFamily: "sans-serif" }],
  /** User can change it in desktop Chrome and desktop Firefox. */
  mono: [{ fontFamily: "monospace" }],
  /**
   * Check the smallest allowed font size. User can change it in desktop Chrome, desktop Firefox and desktop Safari.
   * The height can be 0 in Chrome on a retina display.
   */
  min: [{ fontSize: "1px" }],
  /** Tells one OS from another in desktop Chrome. */
  system: [{ fontFamily: "system-ui" }]
};
function Yt() {
  return jt(function(e2, t2) {
    for (var n2 = {}, a = {}, o2 = 0, r2 = Object.keys(J); o2 < r2.length; o2++) {
      var i = r2[o2], c = J[i], l = c[0], s = l === void 0 ? {} : l, u = c[1], f = u === void 0 ? Gt : u, d2 = e2.createElement("span");
      d2.textContent = f, d2.style.whiteSpace = "nowrap";
      for (var v2 = 0, h = Object.keys(s); v2 < h.length; v2++) {
        var y = h[v2], g = s[y];
        g !== void 0 && (d2.style[y] = g);
      }
      n2[i] = d2, t2.appendChild(e2.createElement("br")), t2.appendChild(d2);
    }
    for (var w2 = 0, R2 = Object.keys(J); w2 < R2.length; w2++) {
      var i = R2[w2];
      a[i] = n2[i].getBoundingClientRect().width;
    }
    return a;
  });
}
function jt(e2, t2) {
  return t2 === void 0 && (t2 = 4e3), ve(function(n2, a) {
    var o2 = a.document, r2 = o2.body, i = r2.style;
    i.width = "".concat(t2, "px"), i.webkitTextSizeAdjust = i.textSizeAdjust = "none", U() ? r2.style.zoom = "".concat(1 / a.devicePixelRatio) : j() && (r2.style.zoom = "reset");
    var c = o2.createElement("div");
    return c.textContent = ue([], Array(t2 / 20 << 0)).map(function() {
      return "word";
    }).join(" "), r2.appendChild(c), e2(o2, r2);
  }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">');
}
function Pt() {
  var e2, t2 = document.createElement("canvas"), n2 = (e2 = t2.getContext("webgl")) !== null && e2 !== void 0 ? e2 : t2.getContext("experimental-webgl");
  if (n2 && "getExtension" in n2) {
    var a = n2.getExtension("WEBGL_debug_renderer_info");
    if (a)
      return {
        vendor: (n2.getParameter(a.UNMASKED_VENDOR_WEBGL) || "").toString(),
        renderer: (n2.getParameter(a.UNMASKED_RENDERER_WEBGL) || "").toString()
      };
  }
}
function Xt() {
  return navigator.pdfViewerEnabled;
}
function Dt() {
  var e2 = new Float32Array(1), t2 = new Uint8Array(e2.buffer);
  return e2[0] = 1 / 0, e2[0] = e2[0] - e2[0], t2[3];
}
var Tt = {
  // READ FIRST:
  // See https://github.com/fingerprintjs/fingerprintjs/blob/master/contributing.md#how-to-make-an-entropy-source
  // to learn how entropy source works and how to make your own.
  // The sources run in this exact order.
  // The asynchronous sources are at the start to run in parallel with other sources.
  fonts: Je,
  domBlockers: St,
  fontPreferences: Yt,
  audio: Ye,
  screenFrame: ct,
  osCpu: qe,
  languages: $e,
  colorDepth: et,
  deviceMemory: tt,
  screenResolution: nt,
  hardwareConcurrency: ut,
  timezone: st,
  sessionStorage: ft2,
  localStorage: dt,
  indexedDB: mt2,
  openDatabase: vt,
  cpuClass: ht2,
  platform: pt2,
  plugins: ze,
  canvas: Ne,
  touchSupport: _e,
  vendor: gt,
  vendorFlavors: bt2,
  cookiesEnabled: yt2,
  colorGamut: kt,
  invertedColors: Vt,
  forcedColors: Ft,
  monochrome: Zt,
  contrast: Rt2,
  reducedMotion: At2,
  hdr: Mt,
  math: It,
  videoCard: Pt,
  pdfViewerEnabled: Xt,
  architecture: Dt
};
function Et(e2) {
  return Fe(Tt, e2, []);
}
var Ht = "$ if upgrade to Pro: https://fpjs.dev/pro";
function Jt(e2) {
  var t2 = zt(e2), n2 = Nt(t2);
  return { score: t2, comment: Ht.replace(/\$/g, "".concat(n2)) };
}
function zt(e2) {
  if (me())
    return 0.4;
  if (j())
    return Q() ? 0.5 : 0.3;
  var t2 = e2.platform.value || "";
  return /^Win/.test(t2) ? 0.6 : /^Mac/.test(t2) ? 0.5 : 0.7;
}
function Nt(e2) {
  return fe(0.99 + 0.01 * e2, 1e-4);
}
function Bt(e2) {
  for (var t2 = "", n2 = 0, a = Object.keys(e2).sort(); n2 < a.length; n2++) {
    var o2 = a[n2], r2 = e2[o2], i = r2.error ? "error" : JSON.stringify(r2.value);
    t2 += "".concat(t2 ? "|" : "").concat(o2.replace(/([:|\\])/g, "\\$1"), ":").concat(i);
  }
  return t2;
}
function he(e2) {
  return JSON.stringify(e2, function(t2, n2) {
    return n2 instanceof Error ? Se(n2) : n2;
  }, 2);
}
function pe(e2) {
  return we(Bt(e2));
}
function Ot(e2) {
  var t2, n2 = Jt(e2);
  return {
    get visitorId() {
      return t2 === void 0 && (t2 = pe(this.components)), t2;
    },
    set visitorId(a) {
      t2 = a;
    },
    confidence: n2,
    components: e2,
    version: se
  };
}
function Ut(e2) {
  return e2 === void 0 && (e2 = 50), ye(e2, e2 * 2);
}
function Qt(e2, t2) {
  var n2 = Date.now();
  return {
    get: function(a) {
      return F(this, void 0, void 0, function() {
        var o2, r2, i;
        return W(this, function(c) {
          switch (c.label) {
            case 0:
              return o2 = Date.now(), [4, e2()];
            case 1:
              return r2 = c.sent(), i = Ot(r2), (t2 || a != null && a.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: ".concat(i.version, `
userAgent: `).concat(navigator.userAgent, `
timeBetweenLoadAndGet: `).concat(o2 - n2, `
visitorId: `).concat(i.visitorId, `
components: `).concat(he(r2), "\n```")), [2, i];
          }
        });
      });
    }
  };
}
function Kt() {
  if (!(window.__fpjs_d_m || Math.random() >= 1e-3))
    try {
      var e2 = new XMLHttpRequest();
      e2.open("get", "https://m1.openfpcdn.io/fingerprintjs/v".concat(se, "/npm-monitoring"), true), e2.send();
    } catch (t2) {
      console.error(t2);
    }
}
function _t2(e2) {
  var t2 = e2 === void 0 ? {} : e2, n2 = t2.delayFallback, a = t2.debug, o2 = t2.monitoring, r2 = o2 === void 0 ? true : o2;
  return F(this, void 0, void 0, function() {
    var i;
    return W(this, function(c) {
      switch (c.label) {
        case 0:
          return r2 && Kt(), [4, Ut(n2)];
        case 1:
          return c.sent(), i = Et({ debug: a }), [2, Qt(i, a)];
      }
    });
  });
}
var qt = { load: _t2, hashComponents: pe, componentsToDebugString: he };
async function ce() {
  try {
    const e2 = typeof Cypress == "object", t2 = typeof process == "object" && define_process_env_default.NODE_ENV === "test";
    return e2 || t2 ? "a-mock-visitor-id" : (await (await qt.load()).get()).visitorId;
  } catch (e2) {
    return console.error(e2), {};
  }
}
async function $t2() {
  return new Promise((e2) => {
    window.requestIdleCallback ? requestIdleCallback(async () => {
      const t2 = await ce();
      e2(t2);
    }) : setTimeout(async () => {
      const t2 = await ce();
      e2(t2);
    }, 500);
  });
}
const en2 = "https://tst.kaptcha.com", tn = "https://ssl.kaptcha.com", nn = (e2) => e2 === "production", rn = ({ env: e2, kountAccountId: t2, kountSessionId: n2 }) => {
  const a = nn(e2) ? tn : en2, o2 = new URL(`${a}/collect/sdk`);
  o2.searchParams.append("m", t2), n2 && o2.searchParams.append("m", n2);
  const r2 = document.createElement("script");
  return r2.setAttribute("class", "kaxsdc"), r2.setAttribute("data-event", "load"), r2.setAttribute("type", "text/javascript"), r2.setAttribute("src", o2.href), document.body.append(r2), r2;
};
async function an({
  env: e2,
  kountAccountId: t2,
  kountSessionId: n2
}) {
  return new Promise((a, o2) => {
    const r2 = rn({
      env: e2,
      kountAccountId: t2,
      kountSessionId: n2
    });
    r2.onload = () => {
      const i = new ka.ClientSDK();
      i.setupCallback({
        "collect-begin": (c) => {
          const { MercSessId: l } = c;
          a(l);
        }
      }), i.autoLoadEvents();
    }, r2.onerror = () => {
      o2(new Error("Error attempting to mount Kount script"));
    };
  });
}
const on$1 = () => {
  const e2 = document.createElement("script");
  return e2.src = "https://cdn.rebilly.com/risk-data-collector/@latest/google-adsense.js", new Promise((t2) => {
    e2.onload = () => {
      t2(document.getElementById("fj2xFkdsoQIQna") === null);
    }, e2.onerror = () => t2(true), document.head.appendChild(e2);
  }).catch(() => true);
};
async function cn({
  env: e2 = null,
  screen: t2,
  navigator: n2,
  kountAccountId: a = null,
  kountSessionId: o2 = null,
  getFingerprint: r2,
  getFraudSessionId: i
}) {
  const { colorDepth: c, height: l, width: s } = t2 || {}, { javaEnabled: u, language: f } = n2 || {};
  let d2, v2, h;
  try {
    [h, d2, v2] = await Promise.all([
      on$1(),
      r2 == null ? void 0 : r2(),
      a ? i({
        env: e2,
        kountAccountId: a,
        kountSessionId: o2
      }) : void 0
    ]);
  } catch (g) {
    console.error(g);
  }
  return {
    riskMetadata: {
      fingerprint: d2 || null,
      extraData: {
        kountFraudSessionId: v2 || null
      },
      browserData: {
        colorDepth: c || null,
        isJavaEnabled: u ? u.call(n2) : null,
        language: f || null,
        screenHeight: l || null,
        screenWidth: s || null,
        timeZoneOffset: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
        isAdBlockEnabled: h
      }
    }
  };
}
async function un({
  env: e2 = null,
  kountAccountId: t2 = null,
  kountSessionId: n2 = null
} = {}) {
  return cn({
    env: e2,
    screen,
    navigator,
    kountAccountId: t2,
    kountSessionId: n2,
    getFingerprint: $t2,
    getFraudSessionId: an
  });
}
function getPaymentMethods() {
  var _a;
  const result = {
    expressMethods: [],
    methods: []
  };
  let methods = state.data.readyToPay;
  if ((_a = state.options) == null ? void 0 : _a.payout) {
    methods = state.data.readyToPayout;
  }
  methods == null ? void 0 : methods.forEach((method) => {
    if (method.metadata.isExpressMethod) {
      result.expressMethods.push(method);
    } else {
      result.methods.push(method);
    }
  });
  if (!window.ApplePaySession) {
    result.expressMethods = result.expressMethods.filter(
      (method) => {
        var _a2;
        return ((_a2 = method == null ? void 0 : method.feature) == null ? void 0 : _a2.name) !== "Apple Pay";
      }
    );
    state.loader.stopLoading({ id: "applePay-express" });
  }
  return result;
}
class ProductModel extends BaseModel {
}
async function fetchProductsFromPlans() {
  return Endpoint(async () => {
    var _a, _b, _c, _d;
    let lineItems;
    if (((_a = state.data) == null ? void 0 : _a.summaryLineItems) && state.data.summaryLineItems.length > 0) {
      lineItems = state.data.summaryLineItems;
    } else {
      lineItems = ((_b = state.options) == null ? void 0 : _b.items) ?? [];
    }
    const filterByPlanId = {
      filter: "",
      expand: "product"
    };
    if (lineItems.length) {
      let ids = lineItems.map((item) => item.planId);
      if ((_c = state.options) == null ? void 0 : _c.addons) {
        ids = ids.concat(
          state.options.addons.map((item) => item.planId)
        );
      }
      if ((_d = state.options) == null ? void 0 : _d.bumpOffer) {
        ids = ids.concat(
          state.options.bumpOffer.map((item) => item.planId)
        );
      }
      filterByPlanId.filter = `id:${Array.from(new Set(ids)).join(",")}`;
    }
    if (filterByPlanId.filter.length) {
      try {
        validateStorefront(state.storefront);
        const { items: planItems } = await state.storefront.plans.getAll(filterByPlanId);
        const products = [];
        planItems.map(
          ({ fields }) => {
            var _a2;
            return new ProductModel((_a2 = fields._embedded) == null ? void 0 : _a2.product);
          }
        ).forEach((product) => {
          if (products.every((item) => item.id !== product.id)) {
            products.push(product);
          }
        });
        return products;
      } catch (e2) {
      }
    }
    return [];
  });
}
function parsePrice(price) {
  if (price == null) {
    return null;
  }
  if (typeof price === "string") {
    return !Number.isNaN(parseFloat(price)) ? parseFloat(price) : null;
  }
  return price;
}
class PlanPricingBracketModel {
  constructor({
    maxQuantity = null,
    price = null
  } = {}) {
    this.maxQuantity = maxQuantity || Number.MAX_SAFE_INTEGER;
    this.price = parsePrice(price);
  }
}
const _PlanPricingModel = class _PlanPricingModel {
  constructor(data = {}) {
    this.formula = data.formula ?? _PlanPricingModel.Formulas.fixedFee;
    switch (data.formula) {
      case _PlanPricingModel.Formulas.stairstep:
      case _PlanPricingModel.Formulas.tiered:
      case _PlanPricingModel.Formulas.volume:
        if (data.brackets == null) {
          throw new Error("Invalid brackets.");
        }
        this.brackets = data.brackets.map(
          (bracket) => new PlanPricingBracketModel(bracket)
        );
        break;
      case _PlanPricingModel.Formulas.flatRate:
        this.price = parsePrice(data.price) ?? 0;
        this.maxQuantity = data.maxQuantity ?? null;
        break;
      case _PlanPricingModel.Formulas.fixedFee:
      default:
        this.price = parsePrice(data.price) ?? 0;
        break;
    }
  }
  get isSimple() {
    return Object.values(_PlanPricingModel.SimpleFormulas).includes(
      this.formula
    );
  }
  get isBracket() {
    return Object.values(_PlanPricingModel.BracketFormulas).includes(
      this.formula
    );
  }
  toPayload() {
    return {
      ...this,
      isSimple: this.isSimple,
      isBracket: this.isBracket
    };
  }
};
_PlanPricingModel.SimpleFormulas = {
  fixedFee: "fixed-fee",
  flatRate: "flat-rate"
};
_PlanPricingModel.BracketFormulas = {
  stairstep: "stairstep",
  tiered: "tiered",
  volume: "volume"
};
_PlanPricingModel.Formulas = {
  ..._PlanPricingModel.SimpleFormulas,
  ..._PlanPricingModel.BracketFormulas
};
let PlanPricingModel = _PlanPricingModel;
class PlanModel extends BaseModel {
  constructor(fields = {}) {
    super(fields);
    this.pricing = new PlanPricingModel(fields.pricing || {});
  }
  toPayload() {
    return {
      ...this,
      pricing: this.pricing.toPayload()
    };
  }
}
async function fetchPlansFromAddonsBumpOffer() {
  return Endpoint(async () => {
    var _a, _b;
    let ids = [];
    if ((_a = state.options) == null ? void 0 : _a.addons) {
      ids = ids.concat(state.options.addons.map((item) => item.planId));
    }
    if ((_b = state.options) == null ? void 0 : _b.bumpOffer) {
      ids = ids.concat(
        state.options.bumpOffer.map((item) => item.planId)
      );
    }
    if (ids.length > 0) {
      validateStorefront(state.storefront);
      const { items: planItems } = await state.storefront.plans.getAll({
        filter: `id:${ids.join(",")}`
      });
      return planItems.map(
        ({ fields }) => new PlanModel(fields).toPayload()
      );
    }
    return [];
  });
}
const paymentMethods = [
  {
    apiName: "ach",
    name: "ACH",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/BankAccount.svg",
    summary: "ACH is a network used for processing transactions across the United States.",
    description: "ACH is a network used for processing transactions across the United States.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ach"
      }
    ]
  },
  {
    apiName: "AdvCash",
    name: "AdvCash",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/AdvCash.svg",
    summary: "AdvCash is an online payment system offering prepaid cards for individuals and\nonline businesses.\n",
    description: "AdvCash is an online payment system offering prepaid cards for individuals and\nonline businesses.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/AdvCash"
      }
    ]
  },
  {
    apiName: "Aircash",
    name: "Aircash",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Aircash is a mobile payment wallet that allows customers to pay for goods and services using their mobile phone.\n",
    description: "Aircash is a mobile payment wallet that allows customers to pay for goods and services using their mobile phone.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Aircash"
      }
    ]
  },
  {
    apiName: "Airpay",
    name: "Airpay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Airpay is an e-wallet that elevates you to an easier and more convenient\nlifestyle with all in one services.\n",
    description: "Airpay is an e-wallet that elevates you to an easier and more convenient\nlifestyle with all in one services.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Airpay"
      }
    ]
  },
  {
    apiName: "Alfa-click",
    name: "Alfa-click",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Alfa-click combines digital and physical payment experiences and is among the\nhighest ranking Russian private banks.\n",
    description: "Alfa-click combines digital and physical payment experiences and is among the\nhighest ranking Russian private banks.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Alfa-click"
      }
    ]
  },
  {
    apiName: "Alipay",
    name: "Alipay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Alipay is the most popular e-wallet and payment platform in Asia. Millions of\ntransactions are processed each day in China.\n",
    description: "Alipay is the most popular e-wallet and payment platform in Asia. Millions of\ntransactions are processed each day in China.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Alipay"
      }
    ]
  },
  {
    apiName: "AmazonPay",
    name: "AmazonPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The AmazonPay method.",
    description: "The AmazonPay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/AmazonPay"
      }
    ]
  },
  {
    apiName: "Apple Pay",
    name: "Apple Pay",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Applepay.svg",
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Applepay.svg",
    summary: "Apple Pay is a digital wallet that also allows users to make payments in\nperson using a one-step payment process.\n",
    description: "Apple Pay is a digital wallet that also allows users to make payments in\nperson using a one-step payment process.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Apple%20Pay"
      }
    ]
  },
  {
    apiName: "AstroPay Card",
    name: "AstroPay Card",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "AstroPay Card allows consumers to purchase online at international websites,\nusing the most effective local payment methods in local currency.\n",
    description: "AstroPay Card allows consumers to purchase online at international websites,\nusing the most effective local payment methods in local currency.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/AstroPay%20Card"
      }
    ]
  },
  {
    apiName: "AstroPay-GO",
    name: "AstroPay Go",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "AstroPay allows consumers to purchase online at international websites, using\nthe most effective local payment methods in local currency.\n",
    description: "AstroPay allows consumers to purchase online at international websites, using\nthe most effective local payment methods in local currency.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/AstroPay-GO"
      }
    ]
  },
  {
    apiName: "Baloto",
    name: "Baloto",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Baloto is Colombia's largest lottery and payment service and is used by 80% of\nthe Colombian population.\n",
    description: "Baloto is Colombia's largest lottery and payment service and is used by 80% of\nthe Colombian population.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Baloto"
      }
    ]
  },
  {
    apiName: "Bancontact-mobile",
    name: "Bancontact-mobile",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Bancontact mobile allows the shopper to complete a payment with the mobile\napp. installed on their device.\n",
    description: "Bancontact mobile allows the shopper to complete a payment with the mobile\napp. installed on their device.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Bancontact-mobile"
      }
    ]
  },
  {
    apiName: "Bancontact",
    name: "Bancontact",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Bancontact is a payment system offered by more than 80% of online Belgian\nbusinesses and functions like a regular card payment.\n",
    description: "Bancontact is a payment system offered by more than 80% of online Belgian\nbusinesses and functions like a regular card payment.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Bancontact"
      }
    ]
  },
  {
    apiName: "BankReferenced",
    name: "BankReferenced",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The BankReferenced method.",
    description: "The BankReferenced method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/BankReferenced"
      }
    ]
  },
  {
    apiName: "BankSEND",
    name: "BankSEND",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "With the BankSEND platform, customers pay with their online banking data using direct bank transfer.\n",
    description: "With the BankSEND platform, customers pay with their online banking data using direct bank transfer.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/BankSEND"
      }
    ]
  },
  {
    apiName: "bank-transfer",
    name: "Bank Transfer",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "A bank transfer is the direct, electronic transfer of funds from one bank\naccount to another.\n",
    description: "A bank transfer is the direct, electronic transfer of funds from one bank\naccount to another.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/bank-transfer"
      }
    ]
  },
  {
    apiName: "Beeline",
    name: "Beeline",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Beeline offers a universal payment card and a mobile prepaid network system\nthat allows money transfers between Beeline subscribers.\n",
    description: "Beeline offers a universal payment card and a mobile prepaid network system\nthat allows money transfers between Beeline subscribers.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Beeline"
      }
    ]
  },
  {
    apiName: "Belfius-direct-net",
    name: "Belfius Direct Net",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Belfius is one of the leading online private banks in Belgium. They are used\nby 1 in 3 Belgians and have over 3.6 million customers.\n",
    description: "Belfius is one of the leading online private banks in Belgium. They are used\nby 1 in 3 Belgians and have over 3.6 million customers.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Belfius-direct-net"
      }
    ]
  },
  {
    apiName: "bitcoin",
    name: "Bitcoin",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Bitcoin.svg",
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Bitcoin.svg",
    summary: "Bitcoin payment method provides a borderless payment network and a seamless\ntransfer of bitcoins from anywhere in the world through any online devices.\n",
    description: "Bitcoin payment method provides a borderless payment network and a seamless\ntransfer of bitcoins from anywhere in the world through any online devices.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/bitcoin"
      }
    ]
  },
  {
    apiName: "Bizum",
    name: "Bizum",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Bizum is the immediate, fast, convenient and universal mobile payment solution promoted by Spanish banks.",
    description: "Bizum is the immediate, fast, convenient and universal mobile payment solution promoted by Spanish banks.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Bizum"
      }
    ]
  },
  {
    apiName: "Blik",
    name: "Blik",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Blik is a Polish payment system that allows users to make instant payments and\nwithdraw cash using a mobile banking app.\n",
    description: "Blik is a Polish payment system that allows users to make instant payments and\nwithdraw cash using a mobile banking app.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Blik"
      }
    ]
  },
  {
    apiName: "Boleto",
    name: "Boleto",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Boleto is Brazil's most popular cash-based payment method. It's the only\npayment option available for 35% of Brazillian consumers without a bank\naccount.\n",
    description: "Boleto is Brazil's most popular cash-based payment method. It's the only\npayment option available for 35% of Brazillian consumers without a bank\naccount.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Boleto"
      }
    ]
  },
  {
    apiName: "CASHlib",
    name: "CASHlib",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "CASHlib is a voucher based payment method that allows you to make online\npayments without the need of a credit or debit card.\n",
    description: "CASHlib is a voucher based payment method that allows you to make online\npayments without the need of a credit or debit card.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/CASHlib"
      }
    ]
  },
  {
    apiName: "CCAvenue",
    name: "CCAvenue",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/portrait/PaymentCard.svg",
    portraitLogo: null,
    summary: "CCAvenue Checkout offers a smooth, fast and frictionless buying experience.\n",
    description: "CCAvenue Checkout offers a smooth, fast and frictionless buying experience.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/CCAvenue"
      }
    ]
  },
  {
    apiName: "CODVoucher",
    name: "CODVoucher",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "CODVoucher offers a digital voucher that the customer can scan at an\nauthorized location and pay with cash.\n",
    description: "CODVoucher offers a digital voucher that the customer can scan at an\nauthorized location and pay with cash.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/CODVoucher"
      }
    ]
  },
  {
    apiName: "cash",
    name: "Cash",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Cash is money in a physical form like coins or notes.",
    description: "Cash is money in a physical form like coins or notes.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/cash"
      }
    ]
  },
  {
    apiName: "cash-deposit",
    name: "Cash Deposit",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "A cash deposit is money put into a bank account in the form of cash, checks,\nor bank transfers.\n",
    description: "A cash deposit is money put into a bank account in the form of cash, checks,\nor bank transfers.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/cash-deposit"
      }
    ]
  },
  {
    apiName: "CashToCode",
    name: "CashToCode",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "CashToCode is an instant cash payment service that does not require a bank\naccount or credit card.\n",
    description: "CashToCode is an instant cash payment service that does not require a bank\naccount or credit card.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/CashToCode"
      }
    ]
  },
  {
    apiName: "Cashterminal",
    name: "Cash Terminal",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "A Bulgarian based service, which provides the ability to pay in cash and in real time.\n",
    description: "A Bulgarian based service, which provides the ability to pay in cash and in real time.\n",
    countries: {
      mode: "subset",
      values: [
        "BG"
      ]
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Cashterminal"
      }
    ]
  },
  {
    apiName: "check",
    name: "Check",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Checks are physical documents that direct a bank to pay a specific amount of\nmoney to the recipient of the check.\n",
    description: "Checks are physical documents that direct a bank to pay a specific amount of\nmoney to the recipient of the check.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/check"
      }
    ]
  },
  {
    apiName: "China UnionPay",
    name: "China UnionPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "China UnionPay is the largest card scheme in China while also offering mobile\nand online payments. China UnionPay has over 7 billion cards in use and is\nconnected to all the ATMs across the country.\n",
    description: "China UnionPay is the largest card scheme in China while also offering mobile\nand online payments. China UnionPay has over 7 billion cards in use and is\nconnected to all the ATMs across the country.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/China%20UnionPay"
      }
    ]
  },
  {
    apiName: "Conekta-oxxo",
    name: "Conekta OXXO",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/ConektaOxxo.svg",
    portraitLogo: null,
    summary: "Conekta OXXO Pay allows customers to purchase online or instore with a\ncash-based voucher. 30% of transactions in Mexico are with OXXO and they offer\nreal-time payment confirmation.\n",
    description: "Conekta OXXO Pay allows customers to purchase online or instore with a\ncash-based voucher. 30% of transactions in Mexico are with OXXO and they offer\nreal-time payment confirmation.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Conekta-oxxo"
      }
    ]
  },
  {
    apiName: "Conekta-spei",
    name: "Conekta SPEI",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/ConektaOxxo.svg",
    portraitLogo: null,
    summary: "Conekta SPEI allows its customers to send and receive interbank electronic\ntransfers and obtain real-time payment confirmation in seconds.\n",
    description: "Conekta SPEI allows its customers to send and receive interbank electronic\ntransfers and obtain real-time payment confirmation in seconds.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Conekta-spei"
      }
    ]
  },
  {
    apiName: "cryptocurrency",
    name: "Cryptocurrency",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Cryptocurrency is a decentralized, digital currency based on blockchain\ntechnology which makes it nearly impossible to counterfeit or double-spend.\n",
    description: "Cryptocurrency is a decentralized, digital currency based on blockchain\ntechnology which makes it nearly impossible to counterfeit or double-spend.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/cryptocurrency"
      }
    ]
  },
  {
    apiName: "Cupon-de-pagos",
    name: "Cupon de Pagos",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Cupon de Pagos method.",
    description: "The Cupon de Pagos method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Cupon-de-pagos"
      }
    ]
  },
  {
    apiName: "CyberSource",
    name: "CyberSource",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "CyberSource ia an e-commerce credit card payment system that allows customers\nto process online payments.\n",
    description: "CyberSource ia an e-commerce credit card payment system that allows customers\nto process online payments.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/CyberSource"
      }
    ]
  },
  {
    apiName: "Dimoco-pay-smart",
    name: "Dimoco pay smart",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Dimoco pay smart method.\n",
    description: "The Dimoco pay smart method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Dimoco-pay-smart"
      }
    ]
  },
  {
    apiName: "Directa24Card",
    name: "Directa24Card",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Directa24Card.svg",
    portraitLogo: null,
    summary: "Directa24 was formerly known as Astropay and specialized in Latin American local payment methods. They have expanded to include other emerging markets.\n",
    description: "Directa24 was formerly known as Astropay and specialized in Latin American local payment methods. They have expanded to include other emerging markets.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Directa24Card"
      }
    ]
  },
  {
    apiName: "domestic-cards",
    name: "Domestic Cards",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Domestic Cards method.",
    description: "The Domestic Cards method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/domestic-cards"
      }
    ]
  },
  {
    apiName: "EPS",
    name: "EPS",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/EPS.svg",
    portraitLogo: null,
    summary: "EPS is an online transfer payment method accepted by 80% of all online\nbusinesses in Austria.\n",
    description: "EPS is an online transfer payment method accepted by 80% of all online\nbusinesses in Austria.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/EPS"
      }
    ]
  },
  {
    apiName: "e-wallet",
    name: "eWallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "An e-Wallet is an electronic system that securely stores payment information\nthat allows for quick and easy digital transactions.\n",
    description: "An e-Wallet is an electronic system that securely stores payment information\nthat allows for quick and easy digital transactions.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/e-wallet"
      }
    ]
  },
  {
    apiName: "eZeeWallet",
    name: "eZeeWallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "eZeeWallet is a digital wallet that offers secure, customer-focused payment services that make paying\nand getting paid simple and hassle-free.\n",
    description: "eZeeWallet is a digital wallet that offers secure, customer-focused payment services that make paying\nand getting paid simple and hassle-free.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/eZeeWallet"
      }
    ]
  },
  {
    apiName: "echeck",
    name: "eCheck",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Echeck.svg",
    portraitLogo: null,
    summary: "An eCheck is a digital version of a traditional paper check.",
    description: "An eCheck is a digital version of a traditional paper check.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/echeck"
      }
    ]
  },
  {
    apiName: "ecoPayz",
    name: "ecoPayz",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ecoPAYZ is one of the oldest e-wallets and allows its customers to receive,\nsend, and spend money worldwide all from one online account.\n",
    description: "ecoPAYZ is one of the oldest e-wallets and allows its customers to receive,\nsend, and spend money worldwide all from one online account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ecoPayz"
      }
    ]
  },
  {
    apiName: "ecoVoucher",
    name: "ecoVoucher",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Ecovoucher.svg",
    portraitLogo: null,
    summary: "ecoVoucher is offered by ecoPayz and is a prepaid payment method that allows\ncustomers to pay online securely.\n",
    description: "ecoVoucher is offered by ecoPayz and is a prepaid payment method that allows\ncustomers to pay online securely.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ecoVoucher"
      }
    ]
  },
  {
    apiName: "Efecty",
    name: "Efecty",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Efecty is a Colombian-based offline cash payment voucher option. It is one of\nthe most popular payment methods in Colombia to pay utility bills and online\npurchases.\n",
    description: "Efecty is a Colombian-based offline cash payment voucher option. It is one of\nthe most popular payment methods in Colombia to pay utility bills and online\npurchases.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Efecty"
      }
    ]
  },
  {
    apiName: "Ethereum",
    name: "Ethereum",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Ethereum is a decentralizaed blockchain platform that offers open access to\ndigital money and data-friendly services. It is the second largest\ncryptocurrency in the market after Bitcoin.\n",
    description: "Ethereum is a decentralizaed blockchain platform that offers open access to\ndigital money and data-friendly services. It is the second largest\ncryptocurrency in the market after Bitcoin.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Ethereum"
      }
    ]
  },
  {
    apiName: "FasterPay",
    name: "FasterPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The FasterPay method\n",
    description: "The FasterPay method\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/FasterPay"
      }
    ]
  },
  {
    apiName: "Flexepin",
    name: "Flexepin",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Flexepin.svg",
    portraitLogo: null,
    summary: "Flexepin is owned and operated by FlexeWallet and their vouchers are issued\nunder an Australian Financial Services License.\n",
    description: "Flexepin is owned and operated by FlexeWallet and their vouchers are issued\nunder an Australian Financial Services License.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Flexepin"
      }
    ]
  },
  {
    apiName: "Giropay",
    name: "Giropay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Giropay is an online payment method offered by more than 1,500 banks in\nGermany. Giropay uses real-time bank transfers and thier payments are 100%\nguaranteed.\n",
    description: "Giropay is an online payment method offered by more than 1,500 banks in\nGermany. Giropay uses real-time bank transfers and thier payments are 100%\nguaranteed.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Giropay"
      }
    ]
  },
  {
    apiName: "Google Pay",
    name: "Google Pay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Google Pay enables customers to pay with any payment method that is saved to\ntheir Google account.\n",
    description: "Google Pay enables customers to pay with any payment method that is saved to\ntheir Google account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Google%20Pay"
      }
    ]
  },
  {
    apiName: "Gpaysafe",
    name: "Gpaysafe",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Gpaysafe allows merchants to do business globally with a single API solution.",
    description: "Gpaysafe allows merchants to do business globally with a single API solution.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Gpaysafe"
      }
    ]
  },
  {
    apiName: "iDEAL",
    name: "iDEAL",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/iDEAL.svg",
    summary: "iDEAL allows customers to complete transactions online using their bank\ncredentials. It is the most popular payment method in the Netherlands with a\nuse of nearly 55%.\n",
    description: "iDEAL allows customers to complete transactions online using their bank\ncredentials. It is the most popular payment method in the Netherlands with a\nuse of nearly 55%.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/iDEAL"
      }
    ]
  },
  {
    apiName: "iDebit",
    name: "iDebit",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "iDebit is an online banking based payment method made available to consumers\nin Canada, connecting them to secure, real-time payments without a credit\ncard.\n",
    description: "iDebit is an online banking based payment method made available to consumers\nin Canada, connecting them to secure, real-time payments without a credit\ncard.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/iDebit"
      }
    ]
  },
  {
    apiName: "ING-homepay",
    name: "ING Homepay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ING Homepay is an online payment method that allows payments over online\nbanking with the Belgian ING branch.\n",
    description: "ING Homepay is an online payment method that allows payments over online\nbanking with the Belgian ING branch.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ING-homepay"
      }
    ]
  },
  {
    apiName: "INOVAPAY-pin",
    name: "INOVAPAY Pin",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The INOVAPAY Pin method.",
    description: "The INOVAPAY Pin method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/INOVAPAY-pin"
      }
    ]
  },
  {
    apiName: "INOVAPAY-wallet",
    name: "INOVAPAY Wallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "INOVAPAY Wallet is an international e-money transfer service used to transfer\nmoney to and from merchants.\n",
    description: "INOVAPAY Wallet is an international e-money transfer service used to transfer\nmoney to and from merchants.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/INOVAPAY-wallet"
      }
    ]
  },
  {
    apiName: "InstaDebit",
    name: "InsataDebit",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Instadebit.svg",
    portraitLogo: null,
    summary: "The InstaDebit method.\n",
    description: "The InstaDebit method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/InstaDebit"
      }
    ]
  },
  {
    apiName: "instant-bank-transfer",
    name: "Instant Bank Transfer",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Instant bank transfers allow consumers to make payments instantly. Both\nconsumers and merchants can receive and send funds immediately.\n",
    description: "Instant bank transfers allow consumers to make payments instantly. Both\nconsumers and merchants can receive and send funds immediately.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/instant-bank-transfer"
      }
    ]
  },
  {
    apiName: "Instant Banking",
    name: "Instant Banking",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Instant Banking enables consumers to make payments to merchants using funds from their bank account.\n",
    description: "Instant Banking enables consumers to make payments to merchants using funds from their bank account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Instant%20Banking"
      }
    ]
  },
  {
    apiName: "InstantPayments",
    name: "Instant Payments",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Instant Payments enables consumers to make payments to merchants using funds from their bank account.\n",
    description: "Instant Payments enables consumers to make payments to merchants using funds from their bank account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/InstantPayments"
      }
    ]
  },
  {
    apiName: "Interac",
    name: "Interac",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Interac.svg",
    summary: "Interac is a Canadian debit card system that allows funds to be sent via its\ne-Transfer service.\n",
    description: "Interac is a Canadian debit card system that allows funds to be sent via its\ne-Transfer service.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Interac"
      }
    ]
  },
  {
    apiName: "Interac-eTransfer",
    name: "Interac eTransfer",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Interac.svg",
    summary: "Interac eTransfer is a Canadian interbank network that allows merchants,\nfinancial institutions, and consumers to exchange electronic funds.\n",
    description: "Interac eTransfer is a Canadian interbank network that allows merchants,\nfinancial institutions, and consumers to exchange electronic funds.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Interac-eTransfer"
      }
    ]
  },
  {
    apiName: "Interac-express-connect",
    name: "Interac Express Connect",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Interac.svg",
    summary: "Interac Express Connect is an e-wallet that allows payments via multiple\nchannels including paypal, Interac e-transfer, and credit cards.\n",
    description: "Interac Express Connect is an e-wallet that allows payments via multiple\nchannels including paypal, Interac e-transfer, and credit cards.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Interac-express-connect"
      }
    ]
  },
  {
    apiName: "Interac-online",
    name: "Interac Online",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Interac.svg",
    summary: "Interac Online is a payment option that enables consumers to shop online and\npay for goods through the RBC online banking account.\n",
    description: "Interac Online is a payment option that enables consumers to shop online and\npay for goods through the RBC online banking account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Interac-online"
      }
    ]
  },
  {
    apiName: "invoice",
    name: "Invoice",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "An invoice is a document issued by a merchant to a consumer relating to a sale\ntransaction and can inform products, prices, quantities, or services.\n",
    description: "An invoice is a document issued by a merchant to a consumer relating to a sale\ntransaction and can inform products, prices, quantities, or services.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/invoice"
      }
    ]
  },
  {
    apiName: "Jeton",
    name: "Jeton",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Jeton is a digital wallet that allows users to exchange money, make secure\nmoney transfers and purchases online.\n",
    description: "Jeton is a digital wallet that allows users to exchange money, make secure\nmoney transfers and purchases online.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Jeton"
      }
    ]
  },
  {
    apiName: "jpay",
    name: "Jpay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Jpay method.",
    description: "The Jpay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/jpay"
      }
    ]
  },
  {
    apiName: "KNET",
    name: "KNET",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The KNET method.\n",
    description: "The KNET method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/KNET"
      }
    ]
  },
  {
    apiName: "KakaoPay",
    name: "KakaoPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "KakaoPay is a mobile payment and digital wallet service by Kakao and based in South Korea. It enables users make mobile payments and online transactions.\n",
    description: "KakaoPay is a mobile payment and digital wallet service by Kakao and based in South Korea. It enables users make mobile payments and online transactions.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/KakaoPay"
      }
    ]
  },
  {
    apiName: "Khelocard",
    name: "Khelocard",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Khelo Card is a virtual prepaid card that allows for deposits and withdrawals\nand is accepted at partnered online sites around the world.\n",
    description: "Khelo Card is a virtual prepaid card that allows for deposits and withdrawals\nand is accepted at partnered online sites around the world.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Khelocard"
      }
    ]
  },
  {
    apiName: "Klarna",
    name: "Klarna",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Klarna offers flexible payment plans that provides payment solutions for 85\nmillion customers and over 200,000 merchants across 19 markets.\n",
    description: "Klarna offers flexible payment plans that provides payment solutions for 85\nmillion customers and over 200,000 merchants across 19 markets.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Klarna"
      }
    ]
  },
  {
    apiName: "LPG-online",
    name: "LPG Online",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Latam Payment Group (LPG Online) specializes in the development of\ntechnological solutions for the operation of eCommerce in the Latin American\nmarket.\n",
    description: "Latam Payment Group (LPG Online) specializes in the development of\ntechnological solutions for the operation of eCommerce in the Latin American\nmarket.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/LPG-online"
      }
    ]
  },
  {
    apiName: "LPG-payment-card",
    name: "LPG Payment Card",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The LPG Payment Card method.",
    description: "The LPG Payment Card method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/LPG-payment-card"
      }
    ]
  },
  {
    apiName: "Litecoin",
    name: "Litecoin",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Litecoin is a peer-to-peer cryptocurrency and open-source software project.",
    description: "Litecoin is a peer-to-peer cryptocurrency and open-source software project.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Litecoin"
      }
    ]
  },
  {
    apiName: "MTS",
    name: "MTS",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "MTS allows users to make payments and money transfers from their e-wallet\nthrough a smartphone or MTS website.\n",
    description: "MTS allows users to make payments and money transfers from their e-wallet\nthrough a smartphone or MTS website.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MTS"
      }
    ]
  },
  {
    apiName: "Matrix",
    name: "Matrix",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Matrix method.",
    description: "The Matrix method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Matrix"
      }
    ]
  },
  {
    apiName: "MaxiCash",
    name: "MaxiCash",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The MaxiCash method.",
    description: "The MaxiCash method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MaxiCash"
      }
    ]
  },
  {
    apiName: "Megafon",
    name: "Megafon",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Megafon can be used to pay like a normal bank card online and in person at\nphysical locations.\n",
    description: "Megafon can be used to pay like a normal bank card online and in person at\nphysical locations.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Megafon"
      }
    ]
  },
  {
    apiName: "MercadoPago",
    name: "MercadoPago",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/MercadoPago.svg",
    portraitLogo: null,
    summary: "Mercado hosts the largest online commerce and payments ecosystem in Latin America. They are present in 18 countries including: Argentina, Brazil, Mexico, Colombia, Chile, Venezuela and Peru. [www.mercadopago.com](https://www.mercadopago.com/)\n",
    description: "Mercado hosts the largest online commerce and payments ecosystem in Latin America. They are present in 18 countries including: Argentina, Brazil, Mexico, Colombia, Chile, Venezuela and Peru. [www.mercadopago.com](https://www.mercadopago.com/)\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MercadoPago"
      }
    ]
  },
  {
    apiName: "MiFinity-eWallet",
    name: "MiFinity-eWallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "MiFinity eWallet allows users to send money from their account directly to a\nrecipient's bank account.\n",
    description: "MiFinity eWallet allows users to send money from their account directly to a\nrecipient's bank account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MiFinity-eWallet"
      }
    ]
  },
  {
    apiName: "miscellaneous",
    name: "Miscellaneous",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The miscellaneous method.\n",
    description: "The miscellaneous method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/miscellaneous"
      }
    ]
  },
  {
    apiName: "MobilePay",
    name: "MobilePay",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/MobilePay.svg",
    portraitLogo: null,
    summary: "Fast, easy payments are handled with a simple swipe, and all thats needed to make them is a phone number.\n",
    description: "Fast, easy payments are handled with a simple swipe, and all thats needed to make them is a phone number.\n",
    countries: {
      mode: "subset",
      values: [
        "DK"
      ]
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MobilePay"
      }
    ]
  },
  {
    apiName: "MuchBetter",
    name: "MuchBetter",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Muchbetter.svg",
    portraitLogo: null,
    summary: "MuchBetter is a payment application with free transfers and multiple contact\npayment devices.\n",
    description: "MuchBetter is a payment application with free transfers and multiple contact\npayment devices.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MuchBetter"
      }
    ]
  },
  {
    apiName: "Multibanco",
    name: "Multibanco",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Multibanco method.\n",
    description: "The Multibanco method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Multibanco"
      }
    ]
  },
  {
    apiName: "MyFatoorah",
    name: "MyFatoorah",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The MyFatoorah method.",
    description: "The MyFatoorah method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/MyFatoorah"
      }
    ]
  },
  {
    apiName: "Neosurf",
    name: "Neosurf",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Neosurf vouchers make online payments possible for thoe without bank accounts\nor credit cards.\n",
    description: "Neosurf vouchers make online payments possible for thoe without bank accounts\nor credit cards.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Neosurf"
      }
    ]
  },
  {
    apiName: "Netbanking",
    name: "Netbanking",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Netbanking allows merchants to accept UPI transactions in India.",
    description: "Netbanking allows merchants to accept UPI transactions in India.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Netbanking"
      }
    ]
  },
  {
    apiName: "Neteller",
    name: "Neteller",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Neteller.svg",
    portraitLogo: null,
    summary: "Neteller offers payments or withdrawals via bank transfer, member wires, money\ntransfers, and merchant sites.\n",
    description: "Neteller offers payments or withdrawals via bank transfer, member wires, money\ntransfers, and merchant sites.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Neteller"
      }
    ]
  },
  {
    apiName: "Nordea-Solo",
    name: "Nordea Solo",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Nordea Solo method.",
    description: "The Nordea Solo method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Nordea-Solo"
      }
    ]
  },
  {
    apiName: "NordikCoin",
    name: "NordikCoin",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/NordikCoin.svg",
    summary: "NordikCoin customers can buy Bitcoin in under 5 minutes.",
    description: "NordikCoin is a crypto currency exchange that specializes in Bitcoin.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/NordikCoin"
      }
    ]
  },
  {
    apiName: "OXXO",
    name: "OXXO",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/OXXO.svg",
    portraitLogo: null,
    summary: "OXXO is a Mexican convenience store chain with thousands of locations across\nLatin America. OXXO enables customers to pay bills and online purchases with\ncash.\n",
    description: "OXXO is a Mexican convenience store chain with thousands of locations across\nLatin America. OXXO enables customers to pay bills and online purchases with\ncash.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/OXXO"
      }
    ]
  },
  {
    apiName: "OchaPay",
    name: "OchaPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The OchaPay method.",
    description: "The OchaPay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/OchaPay"
      }
    ]
  },
  {
    apiName: "online-bank-transfer",
    name: "Online Bank Transfer",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "An online bank transfer is an electronic funds transfer of money from one bank\naccount to another.\n",
    description: "An online bank transfer is an electronic funds transfer of money from one bank\naccount to another.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/online-bank-transfer"
      }
    ]
  },
  {
    apiName: "Onlineueberweisen",
    name: "OnlineUeberweisen",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Onlineueberweisen.svg",
    portraitLogo: null,
    summary: "OnlineUeberweisen is an online banking ePayment company located in Munich,\nGermany.\n",
    description: "OnlineUeberweisen is an online banking ePayment company located in Munich,\nGermany.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Onlineueberweisen"
      }
    ]
  },
  {
    apiName: "oriental-wallet",
    name: "Oriental Wallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Oriental Wallet method.",
    description: "The Oriental Wallet method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/oriental-wallet"
      }
    ]
  },
  {
    apiName: "P24",
    name: "P24",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Przelewy24 (P24) is a payment method in Poland that allows the transfer of funds\nbetween more than 90,000 businesses and Polish banks.\n",
    description: "Przelewy24 (P24) is a payment method in Poland that allows the transfer of funds\nbetween more than 90,000 businesses and Polish banks.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/P24"
      }
    ]
  },
  {
    apiName: "PIX",
    name: "PIX",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "PIX is a new payment method in Brazil for instant bank transfers and is\noperated by Brazilian banks, digital accounts, and wallets.\n",
    description: "PIX is a new payment method in Brazil for instant bank transfers and is\noperated by Brazilian banks, digital accounts, and wallets.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PIX"
      }
    ]
  },
  {
    apiName: "POLi",
    name: "POLi",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The POLi method.",
    description: "The POLi method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/POLi"
      }
    ]
  },
  {
    apiName: "Pagadito",
    name: "Pagadito",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Pagadito method.",
    description: "The Pagadito method.",
    countries: {
      mode: "subset",
      values: [
        "BZ",
        "CR",
        "DO",
        "GT",
        "HN",
        "NI",
        "PA",
        "PR",
        "SV",
        "US"
      ]
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Pagadito"
      }
    ]
  },
  {
    apiName: "PagoEffectivo",
    name: "PagoEffectivo",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PagoEffectivo method.",
    description: "The PagoEffectivo method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PagoEffectivo"
      }
    ]
  },
  {
    apiName: "Pagsmile-deposit-express",
    name: "Pagsmile Deposit Express",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Pagsmile Deposit Express is a money transfer system. After an online purchase,\nthe client can pay at a bank, ATM, or via internet banking.\n",
    description: "Pagsmile Deposit Express is a money transfer system. After an online purchase,\nthe client can pay at a bank, ATM, or via internet banking.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Pagsmile-deposit-express"
      }
    ]
  },
  {
    apiName: "Pagsmile-lottery",
    name: "Pagsmile Lottery",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Pagsmile Lottery offers betting services as well as banking services such as\nwithdrawals, deposits, and bank checking.\n",
    description: "Pagsmile Lottery offers betting services as well as banking services such as\nwithdrawals, deposits, and bank checking.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Pagsmile-lottery"
      }
    ]
  },
  {
    apiName: "Pay4Fun",
    name: "Pay4Fun",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Pay4Fun is a prepaid e-wallet that is connected to a bank account and can be\nused for deposits and withdrawls.\n",
    description: "Pay4Fun is a prepaid e-wallet that is connected to a bank account and can be\nused for deposits and withdrawls.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Pay4Fun"
      }
    ]
  },
  {
    apiName: "PayCash",
    name: "PayCash",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "PayCash is an electronic payment platformfor making anonymous internet\npurchases with cash via kiosks.\n",
    description: "PayCash is an electronic payment platformfor making anonymous internet\npurchases with cash via kiosks.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PayCash"
      }
    ]
  },
  {
    apiName: "PayRedeem",
    name: "PayRedeem",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/PayRedeem.svg",
    portraitLogo: null,
    summary: "PayRedeem eCards can be purchased online with credit/debit card, wire transfer, cryptocurrency, and over 200 alternative payment methods.\n",
    description: "PayRedeem eCards can be purchased online with credit/debit card, wire transfer, cryptocurrency, and over 200 alternative payment methods.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PayRedeem"
      }
    ]
  },
  {
    apiName: "PayTabs",
    name: "PayTabs",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PayTabs method.",
    description: "The PayTabs method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PayTabs"
      }
    ]
  },
  {
    apiName: "PayU",
    name: "PayU",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PayU method.",
    description: "The PayU method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PayU"
      }
    ]
  },
  {
    apiName: "PayULatam",
    name: "PayULatam",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PayULatam method.",
    description: "The PayULatam method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PayULatam"
      }
    ]
  },
  {
    apiName: "Payco",
    name: "Payco",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Payco is one of the most popular forms of payment in South Korea and offers your shoppers convenience and familiarity when shopping online.\n",
    description: "Payco is one of the most popular forms of payment in South Korea and offers your shoppers convenience and familiarity when shopping online.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Payco"
      }
    ]
  },
  {
    apiName: "Payeer",
    name: "Payeer",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Payeer is an e-wallet designed to manage cryptocurrencies and fiat currencies\nwith a built-in payment exchange for systems such as MasterCard, VISA, or\nPaypal.\n",
    description: "Payeer is an e-wallet designed to manage cryptocurrencies and fiat currencies\nwith a built-in payment exchange for systems such as MasterCard, VISA, or\nPaypal.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Payeer"
      }
    ]
  },
  {
    apiName: "PaymentAsia-crypto",
    name: "PaymentAsia-crypto",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PaymentAsia-crypto method.",
    description: "The PaymentAsia-crypto method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PaymentAsia-crypto"
      }
    ]
  },
  {
    apiName: "payment-card",
    name: "Payment Card",
    landscapeLogo: null,
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/PaymentCard.svg",
    summary: "Payment cards are physical cards used for cashless payments and are issued by\nfinancial institiutions, such as banks, to a customer.\n",
    description: "Payment cards are physical cards used for cashless payments and are issued by\nfinancial institiutions, such as banks, to a customer.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/payment-card"
      }
    ]
  },
  {
    apiName: "Paymero-QR",
    name: "Paymero-QR",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Paymero-QR helps online merchants to accept alternative methods such as\ncontactless payments through a QR code.\n",
    description: "Paymero-QR helps online merchants to accept alternative methods such as\ncontactless payments through a QR code.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Paymero-QR"
      }
    ]
  },
  {
    apiName: "Paymero",
    name: "Paymero",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Paymero is an instant bank transfer that allows customers to make UnionPay\nbank transfers to merchants.\n",
    description: "Paymero is an instant bank transfer that allows customers to make UnionPay\nbank transfers to merchants.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Paymero"
      }
    ]
  },
  {
    apiName: "paypal",
    name: "Paypal",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Paypal.svg",
    portraitLogo: "https://app.rebilly.com/static/payment-methods/portrait/Paypal.svg",
    summary: "Paypal is currently one of the most popular online payment processors, with\nover 300 million account holders.\n",
    description: "Paypal is currently one of the most popular online payment processors, with\nover 300 million account holders.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/paypal"
      }
    ]
  },
  {
    apiName: "Paysafecard",
    name: "Paysafecard",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Paysafecard is a closed loop gift card that allows users to pay safely online.",
    description: "Paysafecard is a closed loop gift card that allows users to pay safely online.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Paysafecard"
      }
    ]
  },
  {
    apiName: "Paysafecash",
    name: "Paysafecash",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Paysafecash is an online payment method that allows users to make secure digital payments using cash.",
    description: "Paysafecash is an online payment method that allows users to make secure digital payments using cash.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Paysafecash"
      }
    ]
  },
  {
    apiName: "Perfect-money",
    name: "Perfect Money",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Perfect oney allows users to make instant payments and money transfers\nsecurely online through an online portal.\n",
    description: "Perfect oney allows users to make instant payments and money transfers\nsecurely online through an online portal.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Perfect-money"
      }
    ]
  },
  {
    apiName: "phone",
    name: "Phone",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "A phone is a telecommunications device that allows users to conduct a\nconversation.\n",
    description: "A phone is a telecommunications device that allows users to conduct a\nconversation.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/phone"
      }
    ]
  },
  {
    apiName: "PhonePe",
    name: "PhonePe",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "PhonePe is a digital wallet and online payments application that allows users\nto make instant money transfers with UPI.\n",
    description: "PhonePe is a digital wallet and online payments application that allows users\nto make instant money transfers with UPI.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PhonePe"
      }
    ]
  },
  {
    apiName: "Piastrix",
    name: "Piastrix",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Piastrix is a Russian payment method that allows merchants to accept credit\ncard purchases via e-wallet.\n",
    description: "Piastrix is a Russian payment method that allows merchants to accept credit\ncard purchases via e-wallet.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Piastrix"
      }
    ]
  },
  {
    apiName: "PinPay",
    name: "PinPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The PinPay method.",
    description: "The PinPay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/PinPay"
      }
    ]
  },
  {
    apiName: "QIWI",
    name: "QIWI",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "QIWI is an e-wallet that allows users to transfer money, receive payments, and\nhas over 149,000 kiosks and terminals.\n",
    description: "QIWI is an e-wallet that allows users to transfer money, receive payments, and\nhas over 149,000 kiosks and terminals.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/QIWI"
      }
    ]
  },
  {
    apiName: "QPay",
    name: "QPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The QPay method.\n",
    description: "The QPay method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/QPay"
      }
    ]
  },
  {
    apiName: "QQPay",
    name: "QQPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "QQPay is an e-wallet that allows users to pay for online services quickly an\nsecurely.\n",
    description: "QQPay is an e-wallet that allows users to pay for online services quickly an\nsecurely.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/QQPay"
      }
    ]
  },
  {
    apiName: "rapyd-checkout",
    name: "Rapyd Checkout",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Rapyd Checkout is a platform that allows businesses to accept payment in the\nform of instant UPI payments from bank accounts, e-wallets, and credit cards.\n",
    description: "Rapyd Checkout is a platform that allows businesses to accept payment in the\nform of instant UPI payments from bank accounts, e-wallets, and credit cards.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/rapyd-checkout"
      }
    ]
  },
  {
    apiName: "Resurs",
    name: "Resurs",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Resurs method.",
    description: "The Resurs method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Resurs"
      }
    ]
  },
  {
    apiName: "SEPA",
    name: "SEPA",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "SEPA simplifies payments within the European Union and facilitates the direct\ndebiting of every Euro-denominated bank account.\n",
    description: "SEPA simplifies payments within the European Union and facilitates the direct\ndebiting of every Euro-denominated bank account.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/SEPA"
      }
    ]
  },
  {
    apiName: "SMSVoucher",
    name: "SMSVoucher",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "SMS Voucher is a mobile voucher that can be used to transfer funds via a\nmobile phone.\n",
    description: "SMS Voucher is a mobile voucher that can be used to transfer funds via a\nmobile phone.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/SMSVoucher"
      }
    ]
  },
  {
    apiName: "SPEI",
    name: "SPEI",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/spei.svg",
    portraitLogo: null,
    summary: "SPEI allows its customers to send and receive interbank electronic\ntransfers and obtain real-time payment confirmation in seconds.\n",
    description: "SPEI allows its customers to send and receive interbank electronic\ntransfers and obtain real-time payment confirmation in seconds.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/SPEI"
      }
    ]
  },
  {
    apiName: "SafetyPay",
    name: "SafetyPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "SafetyPay operates the largest network of banks and cash collection points in Latin America, the result of 10+ years effort, with presence in 16 countries consolidated with 380 bank partners and 180,000 collection points.\n",
    description: "SafetyPay operates the largest network of banks and cash collection points in Latin America, the result of 10+ years effort, with presence in 16 countries consolidated with 380 bank partners and 180,000 collection points.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/SafetyPay"
      }
    ]
  },
  {
    apiName: "Samsung Pay",
    name: "Samsung Pay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Samsung Pay is a mobile payment and digital wallet service by Samsung Electronics that enables users to make payments using\ncompatible phones and other Samsung-produced devices.\n",
    description: "Samsung Pay is a mobile payment and digital wallet service by Samsung Electronics that enables users to make payments using\ncompatible phones and other Samsung-produced devices.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: false,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Samsung%20Pay"
      }
    ]
  },
  {
    apiName: "Siirto",
    name: "Siirto",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Siirto allows users to transfer money easily to other Siirto users by using\ntheir phone numbers.\n",
    description: "Siirto allows users to transfer money easily to other Siirto users by using\ntheir phone numbers.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Siirto"
      }
    ]
  },
  {
    apiName: "Skrill",
    name: "Skrill",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Skrill.svg",
    portraitLogo: null,
    summary: "Skrill is a digital wallet for money transfers and online payments that offers\na safe way to pay across different platforms.\n",
    description: "Skrill is a digital wallet for money transfers and online payments that offers\na safe way to pay across different platforms.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Skrill"
      }
    ]
  },
  {
    apiName: "Skrill Rapid Transfer",
    name: "Skrill Rapid Transfer",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Skrill Rapid Transfer allows users to deposit money into their Skrill wallet\nor to pay online directly.\n",
    description: "Skrill Rapid Transfer allows users to deposit money into their Skrill wallet\nor to pay online directly.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Skrill%20Rapid%20Transfer"
      }
    ]
  },
  {
    apiName: "Sofort",
    name: "Sofort",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Sofort.svg",
    portraitLogo: null,
    summary: "Sofort is a payment method acquired by Klarna that redirects customers to\ninitiate a transfer with their bank.\n",
    description: "Sofort is a payment method acquired by Klarna that redirects customers to\ninitiate a transfer with their bank.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Sofort"
      }
    ]
  },
  {
    apiName: "SparkPay",
    name: "SparkPay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The SparkPay method.",
    description: "The SparkPay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/SparkPay"
      }
    ]
  },
  {
    apiName: "swift-dbt",
    name: "SWIFT Debit",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The SWIFT Debit method.",
    description: "The SWIFT Debit method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/swift-dbt"
      }
    ]
  },
  {
    apiName: "TWINT",
    name: "TWINT",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/TWINT.svg",
    portraitLogo: null,
    summary: "TWINT allows customers to make convenient and secure payments via a smartpone.",
    description: "TWINT allows customers to make convenient and secure payments via a smartpone.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/TWINT"
      }
    ]
  },
  {
    apiName: "Tele2",
    name: "Tele2",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Tele2 is an intergrated e-wallet that allows users to instantly receive\ndigital payments frmi TalkBank.\n",
    description: "Tele2 is an intergrated e-wallet that allows users to instantly receive\ndigital payments frmi TalkBank.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Tele2"
      }
    ]
  },
  {
    apiName: "Telr",
    name: "Telr",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Telr method.",
    description: "The Telr method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Telr"
      }
    ]
  },
  {
    apiName: "Terminaly-RF",
    name: "Terminaly RF",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Terminaly RF method.",
    description: "The Terminaly RF method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Terminaly-RF"
      }
    ]
  },
  {
    apiName: "Tether",
    name: "Tether",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Tether is a cryptocurrency with tokens issued by Tether Limited.",
    description: "Tether is a cryptocurrency with tokens issued by Tether Limited.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Tether"
      }
    ]
  },
  {
    apiName: "ToditoCash-card",
    name: "ToditoCash Card",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ToditoCash Card is a prepaid card service used in Mexico that allows customers\nto use the card for purchasing goods and services online.\n",
    description: "ToditoCash Card is a prepaid card service used in Mexico that allows customers\nto use the card for purchasing goods and services online.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ToditoCash-card"
      }
    ]
  },
  {
    apiName: "Trustly",
    name: "Trustly",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Trustly.svg",
    portraitLogo: null,
    summary: "Trustly an open banking payment method that allows customers to shop and pay\nfrom their online bank account, without the use of a card or app.\n",
    description: "Trustly an open banking payment method that allows customers to shop and pay\nfrom their online bank account, without the use of a card or app.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Trustly"
      }
    ]
  },
  {
    apiName: "Tupay",
    name: "Tupay",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Tupay.svg",
    portraitLogo: null,
    summary: "Tupay is a one-stop-shop payment platform. It enables you to make everyday purchases in an easy, convenient, and secure manner through your favorite wallets.\nPay seamlessly, in-app, from anywhere your money is. Whether it is mobile money, a card, or bank without the need to transfer to various wallets.\n",
    description: "Tupay is a one-stop-shop payment platform. It enables you to make everyday purchases in an easy, convenient, and secure manner through your favorite wallets.\nPay seamlessly, in-app, from anywhere your money is. Whether it is mobile money, a card, or bank without the need to transfer to various wallets.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Tupay"
      }
    ]
  },
  {
    apiName: "UPI",
    name: "UPI",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Unified Payments Interface (UPI) is a payment system that powers multiple bank\naccounts into a single mobile application.\n",
    description: "Unified Payments Interface (UPI) is a payment system that powers multiple bank\naccounts into a single mobile application.\n",
    countries: {
      mode: "subset",
      values: [
        "IN"
      ]
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/UPI"
      }
    ]
  },
  {
    apiName: "UPayCard",
    name: "UPayCard",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The UPayCard method.",
    description: "The UPayCard method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/UPayCard"
      }
    ]
  },
  {
    apiName: "USD-coin",
    name: "USD coin",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The USD coin (USDC ERC20) method.\n",
    description: "The USD coin (USDC ERC20) method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/USD-coin"
      }
    ]
  },
  {
    apiName: "UniCrypt",
    name: "UniCrypt",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The UniCrypt method.",
    description: "The UniCrypt method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/UniCrypt"
      }
    ]
  },
  {
    apiName: "VCreditos",
    name: "VCreditos",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "VCreditos is an e-wallet for online transfers and withdrawals. The customer\ncan acquire exclusive advantages, points, and benefits.\n",
    description: "VCreditos is an e-wallet for online transfers and withdrawals. The customer\ncan acquire exclusive advantages, points, and benefits.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/VCreditos"
      }
    ]
  },
  {
    apiName: "VegaWallet",
    name: "VegaWallet",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "VegaWallet is an e-wallet that allows users to purchase, receive, send, and convert funds (points) between users and merchants.\n",
    description: "VegaWallet is an e-wallet that allows users to purchase, receive, send, and convert funds (points) between users and merchants.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/VegaWallet"
      }
    ]
  },
  {
    apiName: "VenusPoint",
    name: "VenusPoint",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The VenusPoint method.",
    description: "The VenusPoint method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/VenusPoint"
      }
    ]
  },
  {
    apiName: "voucher",
    name: "Voucher",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The voucher method.\n",
    description: "The voucher method.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/voucher"
      }
    ]
  },
  {
    apiName: "Wallet88",
    name: "Wallet88",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Wallet88 payment method.",
    description: "Wallet88 payment method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Wallet88"
      }
    ]
  },
  {
    apiName: "WeChat Pay",
    name: "WeChat Pay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "WeChat Pay is an e-Wallet within the Chinese social media app WeChat.",
    description: "WeChat Pay is an e-Wallet within the Chinese social media app WeChat.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/WeChat%20Pay"
      }
    ]
  },
  {
    apiName: "Webmoney",
    name: "Webmoney",
    landscapeLogo: "https://app.rebilly.com/static/payment-methods/landscape/Webmoney.svg",
    portraitLogo: null,
    summary: "The Webmoney method.",
    description: "The Webmoney method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Webmoney"
      }
    ]
  },
  {
    apiName: "Webpay",
    name: "Webpay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Webpay method.",
    description: "The Webpay method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Webpay"
      }
    ]
  },
  {
    apiName: "Webpay Card",
    name: "Webpay Card",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Webpay Card allows consumers in Chile to securely use their debit and credit\ncards online.\n",
    description: "Webpay Card allows consumers in Chile to securely use their debit and credit\ncards online.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Webpay%20Card"
      }
    ]
  },
  {
    apiName: "XPay-P2P",
    name: "XPay-P2P",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "XPAY-P2P is a payment service provider with online merchant services & payment\ngateway integration for retailers.\n",
    description: "XPAY-P2P is a payment service provider with online merchant services & payment\ngateway integration for retailers.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/XPay-P2P"
      }
    ]
  },
  {
    apiName: "XPay-QR",
    name: "XPay-QR",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "XPay-QR is a contactless payment method where payments are completed by\nscannign a QR code from a mobile app.\n",
    description: "XPay-QR is a contactless payment method where payments are completed by\nscannign a QR code from a mobile app.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/XPay-QR"
      }
    ]
  },
  {
    apiName: "Yandex-money",
    name: "Yandex Money",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Yandex Money serves both merchants and individual users as the largest\nelectronic payment service in Russia.\n",
    description: "Yandex Money serves both merchants and individual users as the largest\nelectronic payment service in Russia.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Yandex-money"
      }
    ]
  },
  {
    apiName: "Zimpler",
    name: "Zimpler",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The Zimpler method.",
    description: "The Zimpler method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Zimpler"
      }
    ]
  },
  {
    apiName: "Zotapay",
    name: "Zotapay",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "Zotapay is a global payment service provider that facilitates online payment\nprocessing solutions for emerging markets worldwide.\n",
    description: "Zotapay is a global payment service provider that facilitates online payment\nprocessing solutions for emerging markets worldwide.\n",
    countries: {
      mode: "all",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/Zotapay"
      }
    ]
  },
  {
    apiName: "ePay.bg",
    name: "ePay.bg",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ePay.bg is a free mobile application allowing customers to pay and receive\nmoney quickly and safely.\n",
    description: "ePay.bg is a free mobile application allowing customers to pay and receive\nmoney quickly and safely.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ePay.bg"
      }
    ]
  },
  {
    apiName: "ePayCard",
    name: "ePayCard",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ePay is a free mobile application that provides a quick and safe way to pay and receive money.\n",
    description: "ePay is a free mobile application that provides a quick and safe way to pay and receive money.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ePayCard"
      }
    ]
  },
  {
    apiName: "ezyEFT",
    name: "ezyEFT",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "ezyEFT is an easy to use software application that offers customers the option\nof paying by direct debit.\n",
    description: "ezyEFT is an easy to use software application that offers customers the option\nof paying by direct debit.\n",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/ezyEFT"
      }
    ]
  },
  {
    apiName: "loonie",
    name: "loonie",
    landscapeLogo: null,
    portraitLogo: null,
    summary: "The loonie method.",
    description: "The loonie method.",
    countries: {
      mode: "unknown",
      values: []
    },
    storefrontEnabled: true,
    _links: [
      {
        rel: "self",
        href: "https://api.rebilly.com/payment-methods/loonie"
      }
    ]
  }
];
class PaymentMetadataModel extends BaseModel {
  get logo() {
    return this.landscapeLogo || this.portraitLogo;
  }
}
const _ReadyToPayFeatureModel = class _ReadyToPayFeatureModel {
  constructor({
    name = "",
    expirationTime = "",
    // Apple Pay fields
    displayName = "",
    country = "",
    // Google Pay fields
    merchantName = "",
    merchantOrigin = "",
    // Paypal fields
    paypalMerchantId = "",
    billingAgreementToken = "",
    paypalClientId = "",
    // Plaid fields
    linkToken = ""
  } = {}) {
    this.name = name;
    this.expirationTime = expirationTime;
    this.displayName = displayName;
    this.country = country;
    this.merchantName = merchantName;
    this.merchantOrigin = merchantOrigin;
    this.paypalMerchantId = paypalMerchantId;
    this.billingAgreementToken = billingAgreementToken;
    this.paypalClientId = paypalClientId;
    this.linkToken = linkToken;
  }
};
_ReadyToPayFeatureModel.FeatureName = {
  paypalBillingAgreement: "PayPal billing agreement",
  googlePay: "Google Pay",
  applePay: "Apple Pay"
};
let ReadyToPayFeatureModel = _ReadyToPayFeatureModel;
class ReadyToPayModel {
  constructor({
    index: index2 = null,
    method = "",
    feature = null,
    brands = [],
    filters = [],
    metadata: metadata2 = null
  } = {}) {
    this.index = index2;
    this.method = method;
    this.feature = feature ? new ReadyToPayFeatureModel(feature) : null;
    this.brands = brands;
    this.filters = filters;
    this.metadata = metadata2 ? new PaymentMetadataModel(metadata2) : null;
  }
  get optionsPaymentInstrumentsKey() {
    var _a;
    switch ((_a = this.feature) == null ? void 0 : _a.name) {
      case ReadyToPayFeatureModel.FeatureName.paypalBillingAgreement:
        return "paypal";
      case ReadyToPayFeatureModel.FeatureName.googlePay:
        return "googlePay";
      case ReadyToPayFeatureModel.FeatureName.applePay:
        return "applePay";
      default:
        return void 0;
    }
  }
}
function filterReadyToPay(readyToPay) {
  const paymentMethodsMetadata = [...paymentMethods];
  const EXPRESS_METHODS = ["Google Pay", "Apple Pay", "paypal"];
  const BLOCKED_METHODS = [
    // Requires implementation.
    "echeck",
    // Required unique implementation
    // account number, routing number, and account type required
    "Khelocard",
    // payment instrument is required
    // card number is required
    // card cvv is required
    // expiration month is required
    // expiration year is required
    "Klarna",
    // Klarna authorization token is required
    // Klarna session ID is required
    // Methods to ignore
    "Apple Pay",
    // Apple Pay should be used only from payment-card method
    "China UnionPay",
    // China UnionPay should not be used
    "Google Pay",
    // Google Pay should be used only from payment-card method
    "KakaoPay",
    // KakaoPay is unimplemented digital wallet
    "Payco",
    // Payco is unimplemented digital wallet
    "Samsung Pay"
    // Samsung Pay is unimplemented digital wallet
  ];
  const isExpressMethod = ({ method, feature }) => EXPRESS_METHODS.includes(method) || EXPRESS_METHODS.includes(feature == null ? void 0 : feature.name);
  return readyToPay.filter((readyData) => {
    const isOldPayPal = readyData.method === "paypal" && !readyData.feature;
    const isPlaid = readyData.method === "ach" && readyData.feature;
    const isBlocked = BLOCKED_METHODS.includes(readyData.method);
    return !isOldPayPal && !isPlaid && !isBlocked;
  }).map((fields, index2) => {
    const metadata2 = paymentMethodsMetadata.find(
      (methodMetadata) => methodMetadata.apiName === fields.method
    ) || {};
    metadata2.isExpressMethod = isExpressMethod(fields);
    return new ReadyToPayModel({
      index: index2,
      metadata: metadata2,
      ...fields
    });
  });
}
async function fetchReadyToPay() {
  return Endpoint(async () => {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
    if (!state.data.riskMetadata) {
      const { riskMetadata: data2 } = await un();
      state.data.riskMetadata = data2;
    }
    const data = {
      riskMetadata: state.data.riskMetadata
    };
    data.websiteId = ((_a = state.options) == null ? void 0 : _a.websiteId) || null;
    if ((_b = state.options) == null ? void 0 : _b.items) {
      data.items = mapItemsQuantities(state.options.items);
    }
    if ((((_c = state.options) == null ? void 0 : _c.money) || ((_d = state.data) == null ? void 0 : _d.invoice) || ((_e2 = state.data) == null ? void 0 : _e2.transaction)) && ((_f = state.data) == null ? void 0 : _f.amountAndCurrency)) {
      const { amount, currency } = state.data.amountAndCurrency;
      data.amount = amount;
      data.currency = currency;
    }
    if ((_h = (_g = state.data) == null ? void 0 : _g.account) == null ? void 0 : _h.address) {
      data.billingAddress = state.data.account.address;
    }
    if ((_i = state.data) == null ? void 0 : _i.deposit) {
      data.amount = state.data.deposit.amount;
      data.currency = state.data.deposit.currency;
    }
    const { fields: readyToPayFields } = await state.storefront.purchase.readyToPay({ data });
    const readyToPay = Object.values(readyToPayFields);
    return filterReadyToPay(readyToPay);
  });
}
function filterReadyToPayout(readyToPayout) {
  const paymentMethodsMetadata = [...paymentMethods];
  const EXPRESS_METHODS = ["Google Pay", "Apple Pay", "paypal"];
  const BLOCKED_METHODS = [
    // account number, routing number, and account type required
    "echeck",
    // payment instrument is required
    // card number is required
    // card cvv is required
    // expiration month is required
    // expiration year is required
    "Khelocard",
    // Klarna authorization token is required
    // Klarna session ID is required
    "Klarna"
  ];
  const isExpressMethod = ({ method, feature }) => EXPRESS_METHODS.includes(method) || EXPRESS_METHODS.includes(feature == null ? void 0 : feature.name);
  return readyToPayout.filter((readyData) => {
    const isOldPayPal = readyData.method === "paypal" && !readyData.feature;
    const isPlaid = readyData.method === "ach" && readyData.feature;
    const isBlocked = BLOCKED_METHODS.includes(readyData.method);
    return !isOldPayPal && !isPlaid && !isBlocked;
  }).map((fields, index2) => {
    const metadata2 = paymentMethodsMetadata.find(
      (methodMetadata) => methodMetadata.apiName === fields.method
    ) || {};
    metadata2.isExpressMethod = isExpressMethod(fields);
    return new ReadyToPayModel({
      index: index2,
      metadata: metadata2,
      ...fields
    });
  }).filter(({ metadata: metadata2 }) => metadata2.storefrontEnabled);
}
async function fetchReadyToPayout() {
  return Endpoint(async () => {
    var _a, _b, _c;
    validateOptions$1(state.options);
    validateData(state.data);
    validateStorefront(state.storefront);
    if (!((_a = state == null ? void 0 : state.data) == null ? void 0 : _a.riskMetadata)) {
      const { riskMetadata: data2 } = await un();
      state.data.riskMetadata = data2;
    }
    const data = {
      riskMetadata: state.data.riskMetadata,
      websiteId: state.options.websiteId || null
    };
    if ((_c = (_b = state == null ? void 0 : state.data) == null ? void 0 : _b.account) == null ? void 0 : _c.address) {
      data.billingAddress = state.data.account.address;
    }
    if (state.data.payout) {
      data.amount = state.data.payout.amount;
      data.currency = state.data.payout.currency;
    }
    const { fields: readyToPayFields } = await state.storefront.readyToPayout.readyToPayout({ data });
    const readyToPayout = Object.values(readyToPayFields);
    return filterReadyToPayout(readyToPayout);
  });
}
const _InvoiceModel = class _InvoiceModel extends BaseModel {
  get isPaid() {
    return this.status === _InvoiceModel.Status.paid;
  }
  get isVoid() {
    return this.status === _InvoiceModel.Status.voided;
  }
  get isRefunded() {
    return this.status === _InvoiceModel.Status.refunded;
  }
  get isAbandoned() {
    return this.status === _InvoiceModel.Status.abandoned;
  }
};
_InvoiceModel.Status = {
  draft: "draft",
  unpaid: "unpaid",
  paid: "paid",
  partiallyPaid: "partially-paid",
  pastDue: "past-due",
  abandoned: "abandoned",
  voided: "voided",
  partiallyRefunded: "partially-refunded",
  refunded: "refunded",
  disputed: "disputed"
};
let InvoiceModel = _InvoiceModel;
async function fetchInvoiceAndProducts({
  data = null
}) {
  return Endpoint(async () => {
    var _a;
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    state.storefront.setSessionToken(state.options.jwt);
    const { fields } = await state.storefront.invoices.get({
      ...data,
      // @ts-ignore TODO: check why `expand` is not typed in `get` arguments.
      expand: "items.*.product"
    });
    const products = (_a = fields.items) == null ? void 0 : _a.filter((item) => item._embedded).map((items2) => {
      var _a2;
      return new ProductModel((_a2 = items2._embedded) == null ? void 0 : _a2.product);
    });
    return {
      products,
      invoice: new InvoiceModel(fields)
    };
  });
}
const _TransactionModel = class _TransactionModel extends BaseModel {
  constructor({
    invoiceIds = [],
    ...fields
  }) {
    super(fields);
    this.invoiceIds = invoiceIds || [];
  }
  get invoiceId() {
    return this.invoiceIds[0] || null;
  }
  get hasInvoice() {
    return Boolean(this.invoiceId);
  }
  get transactionIsCompleted() {
    return this.status === _TransactionModel.Status.completed;
  }
};
_TransactionModel.Status = {
  completed: "completed"
};
let TransactionModel = _TransactionModel;
async function fetchTransaction({
  data = null
}) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    if (data == null) {
      throw new Error("Invalid payload.");
    }
    state.storefront.setSessionToken(state.options.jwt);
    const { fields } = await state.storefront.transactions.get(data);
    return new TransactionModel(fields);
  });
}
class AddressModel {
  constructor({
    firstName = null,
    lastName = null,
    organization = null,
    address = null,
    address2 = null,
    city = null,
    region = null,
    country = null,
    postalCode = null,
    emails = [],
    phoneNumbers = []
  } = {}) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.organization = organization;
    this.address = address;
    this.address2 = address2;
    this.city = city;
    this.region = region;
    this.country = country;
    this.postalCode = postalCode;
    this.emails = emails;
    this.phoneNumbers = phoneNumbers;
  }
}
class AccountModel extends BaseModel {
  constructor({
    primaryAddress = {},
    ...fields
  } = {}) {
    super(fields);
    this.address = new AddressModel({ ...primaryAddress });
  }
}
class WebsiteModel extends BaseModel {
}
async function fetchAccountAndWebsite() {
  return Endpoint(async () => {
    var _a;
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    state.storefront.setSessionToken(state.options.jwt);
    const { fields } = await state.storefront.account.get({
      expand: "website"
    });
    return {
      website: new WebsiteModel((_a = fields._embedded) == null ? void 0 : _a.website),
      account: new AccountModel(fields)
    };
  });
}
async function setupPaymentInstrument({
  data
}) {
  return Endpoint(async () => {
    var _a, _b, _c;
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    const { fields: instrument } = await state.storefront.paymentInstruments.create({ data });
    state.storefront.setSessionToken(instrument.token || state.options.jwt);
    const setupPayload = {
      id: instrument.id,
      data: {
        websiteId: state.options.websiteId,
        ...data
      }
    };
    if ((_a = state.data) == null ? void 0 : _a.amountAndCurrency) {
      setupPayload.data = {
        ...setupPayload.data,
        ...state.data.amountAndCurrency
      };
    }
    if ((_c = (_b = state.data) == null ? void 0 : _b.transaction) == null ? void 0 : _c.redirectUrl) {
      setupPayload.data.redirectUrl = `${setupPayload.data.redirectUrl}&originalRedirectUrl=${state.data.transaction.redirectUrl}`;
    }
    const { fields: transaction } = await state.storefront.paymentInstruments.setup(setupPayload);
    return { instrument, transaction };
  });
}
async function fetchPaymentInstrument() {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    const { items: instruments } = await state.storefront.paymentInstruments.getAll({
      filter: `status:active,inactive,verification-needed`
    });
    return instruments.map(({ fields }) => fields);
  });
}
async function createPaymentInstrument({
  data
}) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    const { fields: instrument } = await state.storefront.paymentInstruments.create({ data });
    return instrument;
  });
}
class DepositRequestModel extends BaseModel {
  constructor(fields) {
    super(fields);
    this.amount = Array.isArray(fields.amounts) ? fields.amounts[0] : fields.amount;
    if (fields.buttons) {
      this.buttons = fields.buttons;
    } else if (fields.amounts) {
      this.buttons = [...fields.amounts];
    } else {
      this.buttons = [];
    }
    this.editable = typeof fields.editable === "boolean" ? fields.editable : Boolean(fields.customAmount);
    this.customAmount = merge$2(
      {
        minimum: 1,
        maximum: 1e12,
        multipleOf: 1
      },
      fields.customAmount || {}
    );
  }
}
async function fetchDepositRequest({
  data = null
}) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    if (data == null) {
      throw new Error("Invalid payload.");
    }
    state.storefront.setSessionToken(state.options.jwt);
    const { fields } = await state.storefront.depositRequests.get(data);
    return new DepositRequestModel(fields);
  });
}
const _PayoutRequestModel = class _PayoutRequestModel extends BaseModel {
  constructor(fields = {}) {
    super(fields);
  }
  get isPending() {
    return this.status === _PayoutRequestModel.Status.pending;
  }
};
_PayoutRequestModel.Status = {
  pending: "pending",
  instrumentSelected: "instrument-selected",
  partiallyFulfilled: "partially-fulfilled",
  fulfilled: "fulfilled",
  canceled: "canceled"
};
let PayoutRequestModel = _PayoutRequestModel;
async function fetchPayoutRequest(data) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    const { fields } = await state.storefront.payoutRequests.get(data);
    return new PayoutRequestModel(fields);
  });
}
async function updatePayoutRequest(data) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    const { fields } = await state.storefront.payoutRequests.update(data);
    return new PayoutRequestModel(fields);
  });
}
function optional(schema2) {
  return schema2;
}
function isDepositRequest(deposit) {
  return deposit != null && "depositRequestId" in deposit && typeof deposit.depositRequestId === "string";
}
const depositRequestSchema = {
  type: "object",
  properties: {
    depositRequestId: { type: "string" }
  },
  required: ["depositRequestId"]
};
const depositObjectSchema = {
  type: "object",
  properties: {
    currency: {
      type: "string",
      minLength: 3,
      maxLength: 3
    },
    amount: optional({
      type: "number"
    }),
    buttons: optional({
      type: "array",
      items: {
        type: "number"
      }
    }),
    editable: optional({ type: "boolean" }),
    customAmount: optional({
      type: "object",
      properties: {
        minimum: optional({ type: "number" }),
        maximum: optional({ type: "number" }),
        multipleOf: optional({ type: "number" })
      },
      required: []
    })
  },
  anyOf: [
    {
      required: ["amount"]
    },
    {
      required: ["buttons"]
    }
  ],
  required: ["currency"]
};
const depositSchema = {
  type: "object",
  oneOf: [depositRequestSchema, depositObjectSchema]
};
const collectedProperties = [
  // Google UTM fields
  "utm_source",
  "utm_medium",
  "utm_campaign",
  "utm_term",
  "utm_content",
  // FramePay specific fields
  "affiliate",
  "subAffiliate",
  "clickId",
  "salesAgent"
];
const prefix = /utm_/g;
const getLeadSourceData = () => {
  const { href, origin: origin2, pathname, search } = window.location;
  const leadSource = {
    // Large query parameters including JWTs will cause issues, so make sure we dont
    // use anything longer than 255 characters.
    path: href.length <= 255 ? href : `${origin2}${pathname}`
  };
  const query = search.replace("?", "");
  return query.split("&").map((field) => field.split("=")).filter((field) => {
    const [name] = field;
    return collectedProperties.indexOf(name) > -1;
  }).reduce((data, field) => {
    const [name, value = null] = field;
    const key = name.replace(prefix, "");
    if (key) {
      data[key] = value;
    }
    return data;
  }, leadSource);
};
class DataInstance {
  constructor({ ...fields } = {}) {
    var _a;
    Object.entries({
      ...state.data || {},
      ...fields
    }).forEach(([key, value]) => {
      this[key] = value;
    });
    this.money = ((_a = state.options) == null ? void 0 : _a.money) || null;
    this.couponIds = [];
    this.addons = [];
    this.acceptBumpOffer = false;
  }
  get amountAndCurrency() {
    let currency;
    let amount;
    let amountDue;
    if (this.previewPurchase) {
      currency = this.previewPurchase.currency;
      amount = this.previewPurchase.total;
    } else if (this.invoice) {
      currency = this.invoice.currency;
      amount = this.invoice.amount;
      amountDue = this.invoice.amountDue;
    } else if (this.transaction) {
      currency = this.transaction.currency;
      amount = this.transaction.amount;
    } else if (this.money) {
      currency = this.money.currency;
      amount = this.money.amount;
    }
    const amountAndCurrency = {
      amount,
      currency
    };
    if (amountDue) {
      amountAndCurrency.amountDue = amountDue;
    }
    return amountAndCurrency;
  }
  get isPayment() {
    return Boolean(this.invoice || this.transaction || this.money);
  }
  get isDepositTransaction() {
    var _a;
    return Boolean((_a = this.transaction) == null ? void 0 : _a.depositRequestId);
  }
  get isInvoice() {
    return Boolean(this.invoice);
  }
  get isPurchase() {
    return Boolean(this.previewPurchase);
  }
  get hasAmountDue() {
    return Boolean(
      this.amountAndCurrency.amountDue && this.amountAndCurrency.amountDue !== this.amountAndCurrency.amount
    );
  }
  get summaryItems() {
    const {
      discountsAmount = null,
      shippingAmount = null,
      subtotalAmount = null,
      taxAmount = null
    } = this.previewPurchase || this.invoice || {};
    return {
      discountsAmount,
      shippingAmount,
      subtotalAmount,
      taxAmount
    };
  }
  get summaryLineItems() {
    let lineItems = [];
    if (this.invoice) {
      ({ items: lineItems = [] } = this.invoice);
    } else {
      ({ lineItems = [] } = this.previewPurchase || {});
    }
    return lineItems;
  }
  get isShippingRequired() {
    return (this.products || []).some(
      (product) => product.requiresShipping
    );
  }
  get hasPurchaseData() {
    var _a, _b;
    return Boolean(
      this.isPayment || this.inPurchase || ((_a = state.options) == null ? void 0 : _a.deposit) || ((_b = state.options) == null ? void 0 : _b.payout)
    );
  }
  toPostmatesModel() {
    return JSON.parse(
      JSON.stringify({
        ...this,
        hasPurchaseData: this.hasPurchaseData,
        amountAndCurrency: this.amountAndCurrency,
        isPayment: this.isPayment,
        isInvoice: this.isInvoice,
        isPurchase: this.isPurchase,
        isDepositTransaction: this.isDepositTransaction,
        hasAmountDue: this.hasAmountDue,
        summaryItems: this.summaryItems,
        summaryLineItems: this.summaryLineItems,
        isShippingRequired: this.isShippingRequired,
        leadSource: getLeadSourceData()
      })
    );
  }
}
async function fetchData({
  riskMetadata = null,
  // Dependency injectable functions
  fetchInvoiceAndProducts: fetchInvoiceAndProducts$1 = fetchInvoiceAndProducts,
  fetchTransaction: fetchTransaction$1 = fetchTransaction,
  fetchAccountAndWebsite: fetchAccountAndWebsite$1 = fetchAccountAndWebsite,
  fetchInstruments = fetchPaymentInstrument,
  fetchDepositRequest: fetchDepositRequest$1 = fetchDepositRequest,
  fetchPayoutRequest: fetchPayoutRequest$1 = fetchPayoutRequest
} = {}) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s2, _t3, _u;
  try {
    state.data = new DataInstance();
    if (state.storefront && ((_a = state.options) == null ? void 0 : _a.jwt)) {
      state.storefront.setSessionToken(state.options.jwt);
    }
    if (!riskMetadata) {
      const { riskMetadata: data } = await un();
      state.data.riskMetadata = data;
    } else {
      state.data.riskMetadata = riskMetadata;
    }
    if ((_b = state.options) == null ? void 0 : _b.deposit) {
      if (isDepositRequest(state.options.deposit)) {
        state.data.deposit = await fetchDepositRequest$1({
          data: {
            id: state.options.deposit.depositRequestId
          }
        });
      } else {
        state.data.deposit = new DepositRequestModel(
          // @ts-ignore TODO: refactor - customAmounts optional modifier not present in api-definitions.
          state.options.deposit
        );
      }
    }
    if ((_c = state.options) == null ? void 0 : _c.payout) {
      state.data.payout = await fetchPayoutRequest$1({
        id: state.options.payout.payoutRequestId
      });
    }
    if ((_d = state.options) == null ? void 0 : _d.transactionId) {
      state.data.transaction = await fetchTransaction$1({
        data: {
          id: state.options.transactionId
        }
      });
    }
    let productsPromise;
    const invoiceId = ((_e2 = state.options) == null ? void 0 : _e2.invoiceId) || ((_g = (_f = state.data) == null ? void 0 : _f.transaction) == null ? void 0 : _g.invoiceId);
    if (invoiceId) {
      const { invoice, products: products2 } = await fetchInvoiceAndProducts$1({
        data: {
          id: invoiceId
        }
      });
      productsPromise = Promise.resolve(products2);
      state.data.invoice = invoice;
    }
    const isManageInstruments = [
      (_i = (_h = state.options) == null ? void 0 : _h.paymentInstruments) == null ? void 0 : _i.allowDeactivate,
      (_k = (_j = state.options) == null ? void 0 : _j.paymentInstruments) == null ? void 0 : _k.allowUpdate,
      (_m = (_l = state.options) == null ? void 0 : _l.paymentInstruments) == null ? void 0 : _m.allowMakeDefault
    ].some((v2) => v2);
    let readyToPayPromise = Promise.resolve(null);
    let readyToPayoutPromise = Promise.resolve(null);
    let fetchAccountAndWebsitePromise = Promise.resolve();
    let availableInstrumentsPromise = null;
    if ((_n = state.options) == null ? void 0 : _n.jwt) {
      fetchAccountAndWebsitePromise = fetchAccountAndWebsite$1().then(
        ({ account, website }) => {
          if (state.data == null) {
            throw new Error("Invalid data instance");
          }
          state.data.account = account;
          state.data.website = website;
        }
      );
      if ((_o = state.options) == null ? void 0 : _o.payout) {
        readyToPayoutPromise = fetchAccountAndWebsitePromise.then(
          () => fetchReadyToPayout()
        );
      } else if (state.data.money || state.data.invoice || state.data.transaction || state.data.payout || state.data.deposit) {
        readyToPayPromise = fetchAccountAndWebsitePromise.then(
          () => fetchReadyToPay()
        );
      }
      availableInstrumentsPromise = fetchInstruments();
    } else if ((_p = state.options) == null ? void 0 : _p.payout) {
      readyToPayoutPromise = fetchReadyToPayout();
    } else {
      readyToPayPromise = fetchReadyToPay();
    }
    const previewPurchasePromise = ((_q = state.options) == null ? void 0 : _q.items) ? fetchSummary() : null;
    if (!((_r = state.options) == null ? void 0 : _r.jwt)) {
      productsPromise = fetchProductsFromPlans();
    }
    let plansPromise = new Promise((resolve2) => {
      resolve2([]);
    });
    if (((_s2 = state.options) == null ? void 0 : _s2.addons) || ((_t3 = state.options) == null ? void 0 : _t3.bumpOffer)) {
      plansPromise = fetchPlansFromAddonsBumpOffer();
    }
    let [
      readyToPayout,
      readyToPay,
      previewPurchase,
      products,
      plans,
      availableInstruments
    ] = await Promise.all([
      readyToPayoutPromise,
      readyToPayPromise,
      previewPurchasePromise,
      productsPromise,
      plansPromise,
      availableInstrumentsPromise
    ]);
    if (isManageInstruments && availableInstruments && !readyToPay && !((_u = state.options) == null ? void 0 : _u.payout)) {
      const set2 = /* @__PURE__ */ new Set();
      availableInstruments.forEach((instrument) => {
        set2.add(instrument.method);
      });
      readyToPay = filterReadyToPay(
        Array.from(set2).map((method) => ({ method }))
      );
    }
    return new DataInstance({
      readyToPayout,
      readyToPay,
      previewPurchase,
      products,
      plans,
      availableInstruments,
      isManageInstruments
    });
  } catch (error2) {
    console.error(error2);
  }
  return new DataInstance({});
}
function mountExpressMethod({ state: state2, id: id2 }) {
  const { Framepay } = window;
  const container = state2.form.querySelector(
    `.rebilly-instruments-${id2}-method`
  );
  function updateApplePayStyling() {
    const applePayButton = state2.form.querySelector(
      "#rebilly-apple-pay-button"
    );
    const {
      applePayDisplayOptions: { buttonHeight }
    } = state2.options.digitalWallet.applePay;
    applePayButton.style.margin = "0px";
    applePayButton.style.width = "100%";
    applePayButton.style.height = buttonHeight;
    applePayButton.style.cursor = "pointer";
  }
  return function mountButton() {
    if (!container.children.length) {
      const mountFunction = {
        "google-pay": "googlePay",
        "pay-pal-billing-agreement": "paypal",
        "apple-pay": "applePay"
      };
      const element = state2.form.querySelector(
        `.rebilly-instruments-${id2}-method`
      );
      if (mountFunction[id2]) {
        Framepay[mountFunction[id2]].mount(element);
        if (id2 === "apple-pay") {
          updateApplePayStyling();
        }
      } else {
        console.warn(`method '${id2}' is not supported`);
      }
    }
  };
}
function generateFramepayConfig({ methodIds } = {}) {
  var _a, _b;
  const { options, data } = state;
  const config = {
    style: options.themeFramepay,
    locale: (options == null ? void 0 : options.locale) || "auto",
    organizationId: options.organizationId,
    websiteId: options.websiteId,
    methods: options.payout ? data.readyToPayout : data.readyToPay
  };
  if (methodIds.includes("pay-pal-billing-agreement")) {
    config.transactionData = merge$2(
      typeof config.transactionData === "object" ? config.transactionData : {},
      data.amountAndCurrency
    );
    config.paypal = options.paymentInstruments.paypal;
  }
  if (methodIds.includes("google-pay")) {
    config.transactionData = merge$2(
      typeof config.transactionData === "object" ? config.transactionData : {},
      (_a = options.digitalWallet.googlePay) == null ? void 0 : _a.transactionData
    );
    config.googlePay = options.digitalWallet.googlePay.googlePayDisplayOptions;
  }
  if (methodIds.includes("apple-pay")) {
    config.transactionData = merge$2(
      typeof config.transactionData === "object" ? config.transactionData : {},
      (_b = options.digitalWallet.applePay) == null ? void 0 : _b.transactionData
    );
    config.applePay = options.digitalWallet.applePay.applePayDisplayOptions;
  }
  if (options.publishableKey) {
    config.publishableKey = options.publishableKey;
  }
  if (options.jwt) {
    config.jwt = options.jwt;
    config.sandbox = options.apiMode === "sandbox";
  }
  if (data.riskMetadata) {
    config.riskMetadata = data.riskMetadata;
  }
  return config;
}
const getMethodData = (method) => {
  var _a, _b;
  const METHOD_ID = kebabCase$1(((_a = method.feature) == null ? void 0 : _a.name) || method.method);
  const METHOD_TYPE = camelCase$1(
    ((_b = method.feature) == null ? void 0 : _b.name) || method.method
  ).replace("-", "");
  return { METHOD_ID, METHOD_TYPE };
};
const browserIsSafari = () => window.ApplePaySession;
async function mountExpressMethods({ methods, container }) {
  const methodIds = methods.map((expressMethod) => {
    const { METHOD_ID } = getMethodData(expressMethod);
    return METHOD_ID;
  });
  const { Framepay } = window;
  if (!(Framepay == null ? void 0 : Framepay.initialized)) {
    await (Framepay == null ? void 0 : Framepay.initialize(
      generateFramepayConfig({
        methodIds
      })
    ));
  }
  function generateExpressMethodHeight(method) {
    var _a, _b;
    let height;
    const optionId = method.optionsPaymentInstrumentsKey;
    if (!optionId) return "48px";
    const { buttonHeight, displayOptions } = ((_b = (_a = state.options) == null ? void 0 : _a.paymentInstruments) == null ? void 0 : _b[optionId]) || {};
    if (displayOptions) {
      height = displayOptions.buttonHeight;
    } else {
      height = buttonHeight;
    }
    if (typeof height === "number") {
      height = `${buttonHeight}px`;
    }
    return height;
  }
  Framepay == null ? void 0 : Framepay.on("ready", () => {
    const mountingMethods = [];
    methods.map((method) => {
      const { METHOD_ID: id2 } = getMethodData(method);
      if (id2 === "apple-pay" && !browserIsSafari()) return;
      container.innerHTML += `
      <div class="rebilly-instruments-${id2}-method" style="height: ${generateExpressMethodHeight(
        method
      )}"></div>
    `;
      mountingMethods.push(
        mountExpressMethod({
          state,
          id: id2
        })
      );
    });
    mountingMethods.forEach((mount2) => mount2());
  });
  Framepay == null ? void 0 : Framepay.on("error", (error2) => {
    if (error2.code === "paypal-error") {
      const paypalEl = document.querySelector(
        ".rebilly-instruments-pay-pal-billing-agreement-method"
      );
      if (paypalEl) {
        paypalEl.remove();
        if (container.children.length <= 0) {
          const divider = document.querySelector(
            '[data-rebilly-instruments="divider"]'
          );
          if (divider) {
            divider.remove();
          }
        }
      }
    } else {
      console.error(error2);
    }
  });
  const redirectUrl = state.options.apiMode === "sandbox" ? "https://forms-sandbox.secure-payments.app/approval-url?close=true" : "https://forms.secure-payments.app/approval-url?close=true";
  Framepay == null ? void 0 : Framepay.on("token-ready", (token) => {
    var _a, _b, _c;
    const instrumentReadyPayload = {
      websiteId: state.options.websiteId,
      billingAddress: token.billingAddress,
      redirectUrl,
      _raw: token
    };
    if ((_a = state.data) == null ? void 0 : _a.isShippingRequired) {
      if (token.shippingAddress) {
        instrumentReadyPayload.deliveryAddress = token.shippingAddress;
      } else {
        instrumentReadyPayload.deliveryAddress = instrumentReadyPayload.billingAddress;
      }
    }
    if (Array.isArray((_b = instrumentReadyPayload.billingAddress) == null ? void 0 : _b.emails)) {
      const email = instrumentReadyPayload.billingAddress.emails.find(
        (e2) => e2.label === "main"
      );
      if (email == null ? void 0 : email.value) {
        instrumentReadyPayload.billingAddress.email = email.value;
      }
    }
    if (Array.isArray((_c = instrumentReadyPayload.deliveryAddress) == null ? void 0 : _c.emails)) {
      const email = instrumentReadyPayload.deliveryAddress.emails.find(
        (e2) => e2.label === "main"
      );
      if (email == null ? void 0 : email.value) {
        instrumentReadyPayload.deliveryAddress.email = email.value;
      }
    }
    events.instrumentReady.dispatch(instrumentReadyPayload);
  });
}
function formatCurrency(number2, currency = "USD") {
  const numberValue = Number(number2);
  if (Number.isNaN(numberValue) || number2 == null) return "-";
  return new Intl.NumberFormat("en-US", {
    style: "currency",
    currency
  }).format(numberValue);
}
function lineItem({ offer }) {
  const plan = state.data.plans.find((item) => item.id === offer.planId);
  const product = state.data.products.find(
    (item) => item.id === plan.productId
  );
  const rif = (condition, template) => condition ? template : "";
  function unitPrice() {
    const planPricing = plan.pricing.isBracket ? plan.pricing.brackets[0].price : plan.pricing.price;
    const basePrice = formatCurrency(planPricing, plan.currency);
    return plan.pricing.isBracket ? state.translate.getTranslation("form.bumpOffer.startingAt").replace("{basePrice}", basePrice) : basePrice;
  }
  const thumbnail = (item) => rif(
    item.thumbnail,
    `
    <figure class="rebilly-instruments-bump-offer-line-item-figure">
      <img src="${item.thumbnail}" :alt="${item.name}"/>
    </figure>
  `
  );
  const synopsis = (item) => `
    <div class="rebilly-instruments-bump-offer-line-item-synopsis">
      <p class="rebilly-instruments-bump-offer-line-item-synopsis-title">
        ${item.name}
      </p>
      ${rif(
    item.description,
    `
        <p class="rebilly-instruments-bump-offer-line-item-synopsis-description">
          ${item.description}
        </p>
      `
  )}
    </div>
  `;
  const breakdown = (item) => `
    <div class="rebilly-instruments-bump-offer-line-item-price-breakdown">
      ${rif(
    item.quantity,
    `
        <p class="rebilly-instruments-bump-offer-line-item-price-breakdown-quantity">
          ${item.quantity}
        </p>
        <svg class="rebilly-instruments-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 10.5858l2.8284-2.8284c.3906-.3906 1.0237-.3906 1.4142 0 .3906.3905.3906 1.0236 0 1.4142L13.4142 12l2.8284 2.8284c.3906.3906.3906 1.0237 0 1.4142-.3905.3906-1.0236.3906-1.4142 0L12 13.4142l-2.8284 2.8284c-.3906.3906-1.0237.3906-1.4142 0-.3906-.3905-.3906-1.0236 0-1.4142L10.5858 12 7.7574 9.1716c-.3906-.3906-.3906-1.0237 0-1.4142.3905-.3906 1.0236-.3906 1.4142 0L12 10.5858z" fill-rule="nonzero"/>
        </svg>
      `
  )}
      <p class="rebilly-instruments-bump-offer-line-item-price-breakdown-unit-price">
        ${item.unitPrice}
      </p>
    <div>
  `;
  const line = {
    ...offer,
    quantity: plan.pricing.isBracket ? null : offer.quantity,
    name: product.name,
    description: plan.name,
    unitPrice: unitPrice()
  };
  return `
    <div class="rebilly-instruments-bump-offer-line-item">
      ${thumbnail(line)}
      ${synopsis(line)}
      ${breakdown(line)}
    </div>
  `;
}
function mountBumpOffer({ container }) {
  container.insertAdjacentHTML(
    "beforeEnd",
    `
    <label for="rebilly-instruments-bump-offer" class="rebilly-instruments-form-field-checkbox">
      <div class="rebilly-instruments-bump-offer-label" data-rebilly-i18n="form.bumpOffer.title">
        ${state.translate.getTranslation("form.bumpOffer.title")}
      </div>
      <input
        type="checkbox"
        id="rebilly-instruments-bump-offer"
      />
      <span></span>
    </label>
  `
  );
  const checkbox = document.getElementById("rebilly-instruments-bump-offer");
  checkbox.addEventListener("click", async () => {
    state.data.acceptBumpOffer = checkbox.checked;
    await fetchSummary();
    state.updateModel();
  });
  checkbox.checked = state.data.acceptBumpOffer;
  state.options.bumpOffer.forEach((offer) => {
    const node = document.createElement("div");
    node.classList.add("rebilly-instruments-bump-offer");
    node.insertAdjacentHTML("beforeEnd", lineItem({ offer }));
    container.appendChild(node);
  });
}
function generateDigitalWallet({ expressMethods = [] }) {
  var _a;
  const output = {};
  const { paymentInstruments } = state.options;
  const transactionData = {
    countryCode: state.options.countryCode,
    label: state.options.websiteId
  };
  if ((_a = state.data) == null ? void 0 : _a.amountAndCurrency) {
    const { amount, currency } = state.data.amountAndCurrency;
    transactionData.amount = amount;
    transactionData.currency = currency;
  }
  expressMethods.forEach((method) => {
    var _a2, _b, _c, _d;
    const { METHOD_TYPE } = getMethodData(method);
    if (((_a2 = method.feature) == null ? void 0 : _a2.name) === "Google Pay") {
      output[METHOD_TYPE] = {
        transactionData,
        merchantConfig: {
          merchantName: method.feature.merchantName,
          merchantOrigin: method.feature.merchantOrigin
        },
        googlePayDisplayOptions: paymentInstruments.googlePay.displayOptions
      };
    }
    if (((_b = method.feature) == null ? void 0 : _b.name) === "Apple Pay") {
      output[METHOD_TYPE] = {
        transactionData,
        merchantConfig: {
          merchantName: (_d = (_c = paymentInstruments.applePay) == null ? void 0 : _c.merchantConfig) == null ? void 0 : _d.merchantName,
          // Apple Pay code cannot run in an iframe, and the merchant origin must be
          // registered as a merchant domain, so we can just send the current URL.
          merchantOrigin: window.location.hostname
        },
        applePayDisplayOptions: paymentInstruments.applePay.displayOptions
      };
    }
  });
  return output;
}
async function createDeposit({
  data
}) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    validateOptions$1(state.options);
    if (data == null) {
      throw new Error("Invalid payload.");
    }
    state.storefront.setSessionToken(state.options.jwt);
    const { fields } = await state.storefront.deposit.create({ data });
    return new TransactionModel(fields);
  });
}
function getElement(id2, rootElement = state.form) {
  return rootElement.querySelector(`[data-rebilly-instruments="${id2}"]`);
}
const getBumpOfferElement = () => {
  const rootDiv = document.createElement("div");
  rootDiv.classList.add("rebilly-instruments-bump-offers");
  rootDiv.setAttribute("data-rebilly-instruments", "bump-offer");
  return rootDiv;
};
function hideExtraUI() {
  var _a, _b, _c;
  const { expressMethods } = getPaymentMethods();
  if ((_a = state.options) == null ? void 0 : _a.deposit) {
    const linkElement = getElement("deposit-back");
    if (linkElement) {
      linkElement.style.height = "0px";
      linkElement.style.overflow = "hidden";
    }
  }
  if (expressMethods.length) {
    const expressMethodsElement2 = getElement("express-methods");
    if (expressMethodsElement2) {
      expressMethodsElement2.style.height = "0px";
      expressMethodsElement2.style.overflow = "hidden";
    }
  }
  if ((_c = (_b = state.options) == null ? void 0 : _b.bumpOffer) == null ? void 0 : _c.length) {
    const bumpOfferElement = getElement("bump-offer");
    if (bumpOfferElement) {
      bumpOfferElement.style.height = "0px";
      bumpOfferElement.style.overflow = "hidden";
      bumpOfferElement.style.marginBottom = "0px";
    }
  }
}
const expressMethodsElement = ({ expressMethods }) => {
  const rootDiv = document.createElement("div");
  rootDiv.classList.add("rebilly-instruments-method-selector");
  rootDiv.setAttribute("data-rebilly-instruments", "express-methods");
  rootDiv.innerHTML = `
  <div class="rebilly-instruments-express-methods ">
    <span data-rebilly-i18n="form.expressCheckout" class="rebilly-instruments-express-methods-label">Express checkout</span>
    <div class="rebilly-instruments-express-methods-container" data-rebilly-instruments="express-methods-container"></div>
  </div>
  <div data-rebilly-instruments="divider" class="rebilly-instruments-divider">
    <span class="rebilly-instruments-divider-label" data-rebilly-i18n="form.or">Or</span>
  </div>
  `;
  const expressMethodsContainer = getElement(
    "express-methods-container",
    rootDiv
  );
  const useCompactExpressInstruments = state.options.paymentInstruments.compactExpressInstruments && expressMethods.length;
  if (useCompactExpressInstruments) {
    rootDiv.classList.add("has-express-compact");
    expressMethodsContainer.classList.add("is-compact");
  }
  return rootDiv;
};
async function mountMethodSelector() {
  var _a, _b, _c, _d, _e2, _f, _g;
  const contentEl = getElement("content");
  const formEl = getElement("form");
  const { expressMethods, methods } = getPaymentMethods();
  if (expressMethods.length) {
    const existingExpressMethodElement = getElement("express-methods");
    if (existingExpressMethodElement) {
      existingExpressMethodElement.style.height = "auto";
    } else {
      contentEl.insertBefore(
        expressMethodsElement({ expressMethods }),
        formEl
      );
      state.options.digitalWallet = generateDigitalWallet({
        expressMethods
      });
      const container = state.form.querySelector(
        '[data-rebilly-instruments="express-methods-container"]'
      );
      mountExpressMethods({
        methods: expressMethods,
        container
      });
    }
  }
  if ((_b = (_a = state.options) == null ? void 0 : _a.bumpOffer) == null ? void 0 : _b.length) {
    const existingExpressMethodElement = getElement("bump-offer");
    if (existingExpressMethodElement) {
      existingExpressMethodElement.style.height = "auto";
      existingExpressMethodElement.style.marginBottom = "calc(var(--rebilly-spacingM) + var(--rebilly-fontSizeS))";
    } else {
      contentEl.insertBefore(getBumpOfferElement(), formEl);
      const container = getElement("bump-offer");
      mountBumpOffer({
        container
      });
    }
  }
  if (methods.length) {
    const iframe = iframes.form;
    if (!iframe) {
      await mountForm();
    }
    const modelSafeState = state.toModel();
    const model = {
      options: modelSafeState.options,
      data: modelSafeState.data
    };
    (_c = iframe == null ? void 0 : iframe.component) == null ? void 0 : _c.call("route", {
      name: "method-switch"
    });
    (_d = iframe == null ? void 0 : iframe.component) == null ? void 0 : _d.call("update", model);
    if (!((_f = (_e2 = iframe == null ? void 0 : iframe.component) == null ? void 0 : _e2.events) == null ? void 0 : _f["restart-payment-flow"])) {
      (_g = iframe == null ? void 0 : iframe.component) == null ? void 0 : _g.on("restart-payment-flow", async (payload) => {
        if (payload == null ? void 0 : payload.createNewDeposit) {
          const transaction = await createDeposit({
            data: {
              depositRequestId: payload.depositRequestId,
              amount: payload.amount
            }
          });
          if (transaction.approvalUrl) {
            window.location.assign(transaction.approvalUrl);
            return;
          }
        }
        if (state.data.isPurchase) {
          updateSummary();
        }
        mountMethodSelector();
      });
    }
  } else {
    state.loader.stopLoading({ id: "rebilly-instruments-form" });
    state.form.querySelector(
      '[data-rebilly-instruments="form"]'
    ).style.display = "none";
    document.querySelectorAll('[data-rebilly-instruments="divider"]').forEach((el) => {
      el.style.display = "none";
    });
  }
  state.translate.translateItems();
}
async function mountAmountSelector() {
  var _a, _b, _c;
  if (state.data.money) {
    state.data.money.amount = null;
    state.data.money.currency = null;
    state.updateModel();
  }
  const iframe = iframes.form;
  if (!iframe) {
    await mountForm();
  }
  const modelSafeState = state.toModel();
  const model = {
    options: modelSafeState.options,
    data: modelSafeState.data
  };
  (_a = iframe.component) == null ? void 0 : _a.call("route", {
    name: "amount-selector"
  });
  (_b = iframe.component) == null ? void 0 : _b.call("update", model);
  (_c = iframe == null ? void 0 : iframe.component) == null ? void 0 : _c.on("confirm-amount", async (data) => {
    const { amount, currency } = data;
    const { depositRequestId } = state.options.deposit;
    state.data.money = {
      amount,
      currency
    };
    const transaction = await createDeposit({
      data: {
        depositRequestId,
        amount
      }
    });
    if (transaction) {
      state.data.transaction = transaction;
      state.options.transactionId = transaction.id;
    }
    const readyToPayUpdated = await fetchReadyToPay();
    state.data.readyToPay = readyToPayUpdated;
    state.updateModel();
    mountMethodSelector();
  });
}
const baseMethodSelectorHTML = () => `
<div data-rebilly-instruments="content" class="rebilly-instruments-content">
  <div data-rebilly-instruments="content-error" id="rebilly-instruments-error"></div>
  <div data-rebilly-instruments="form"></div>
</div>
`;
async function mountForm() {
  var _a;
  state.form.innerHTML += baseMethodSelectorHTML();
  const container = state.form.querySelector(
    '[data-rebilly-instruments="form"]'
  );
  const { paymentMethodsUrl: url } = ((_a = state == null ? void 0 : state.options) == null ? void 0 : _a._computed) || {};
  const name = "rebilly-instruments-form";
  const modelSafeState = state.toModel();
  const model = {
    options: modelSafeState.options,
    data: modelSafeState.data,
    mainStyleVars: modelSafeState.mainStyleVars
  };
  const args = {
    name,
    url: `${url}?name=${name}`,
    container,
    model
  };
  const iframe = await new ViewIframe2(args);
  iframe.bindEventListeners({ loader: state.loader });
  iframes.form = iframe;
  state.loader.stopLoading({ id: "rebilly-instruments-form" });
  return {
    then: (callback) => callback()
  };
}
function determineFirstView() {
  var _a;
  if ((_a = state.options) == null ? void 0 : _a.deposit) {
    mountAmountSelector();
  } else {
    mountMethodSelector();
  }
}
function removeForm() {
  const container = state.form.querySelector(
    '[data-rebilly-instruments="form"]'
  );
  container.remove();
}
function addDOMElement({
  element = "div",
  attributes = {},
  content: content2 = null,
  target = "body",
  insertMethod = "append"
} = {}) {
  const ELEMENT = document.createElement(element);
  const ELEMENT_ATTRIBUTES = Object.entries(attributes);
  ELEMENT_ATTRIBUTES.forEach(([attribute, value]) => {
    ELEMENT.setAttribute(attribute, value);
  });
  if (content2) {
    ELEMENT.innerHTML = content2;
  }
  if (target instanceof ShadowRoot) {
    target.prepend(ELEMENT);
  } else {
    document[target][insertMethod](ELEMENT);
  }
}
function hasValidCSSSelector(selector) {
  const REGEX_CSS_SELECTOR = /([.#][_a-z]+[_a-z0-9-:\\]*)/gi;
  return typeof selector === "string" && selector.match(REGEX_CSS_SELECTOR);
}
function processPropertyAsDOMElement({
  prop,
  propName = "Mounting",
  isRequired = true
} = {}) {
  let DOMElement;
  if (typeof prop === "undefined") {
    throw new Error('processPropertyDOMElement: Missing argument "prop"');
  }
  if (isDOMElement(prop)) {
    DOMElement = prop;
  } else if (typeof prop === "string" && hasValidCSSSelector(prop)) {
    DOMElement = document.querySelector(prop);
  } else {
    throw new Error(
      `Please provide a valid CSS class, id or DOM element for "${propName}" property`
    );
  }
  if (!DOMElement && isRequired) {
    throw new Error(
      `Could not find DOM element with CSS class or id "${prop}" to mount ${propName}`
    );
  }
  return DOMElement;
}
const setupElement = ({ element = "" }) => {
  const { options } = state;
  if (element !== "form" && element !== "summary") {
    throw new Error('element must be "form", or "summary"');
  }
  const getProp = () => {
    if (options != null && options[element]) {
      return options[element];
    }
    switch (element) {
      case "summary":
        return ".rebilly-instruments-summary";
      case "form":
      default:
        return ".rebilly-instruments";
    }
  };
  return processPropertyAsDOMElement({
    prop: getProp(),
    propName: element,
    isRequired: ["form"].includes(element)
  });
};
const setupStorefront = () => {
  validateOptions$1(state.options);
  const { publishableKey, organizationId, apiMode, _dev } = state.options;
  const storefront = {
    organizationId,
    mode: apiMode || "live"
  };
  if (publishableKey) {
    storefront.publishableKey = publishableKey;
  }
  if (_dev) {
    storefront.liveUrl = _dev.liveUrl || "https://api.rebilly.com";
    storefront.sandboxUrl = _dev.sandboxUrl || "https://api-sandbox.rebilly.com";
  }
  return Storefront(storefront);
};
function e(e2) {
  this.message = e2;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0) o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c;
};
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2) throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var _2019 = { exports: {} };
var core$3 = {};
var validate$1 = {};
var boolSchema = {};
var errors = {};
var codegen = {};
var code$1 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class Name extends _CodeOrName {
    constructor(s) {
      super();
      if (!exports.IDENTIFIER.test(s))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;
  class _Code extends _CodeOrName {
    constructor(code2) {
      super();
      this._items = typeof code2 === "string" ? [code2] : code2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names2, c) => {
        if (c instanceof Name)
          names2[c.str] = (names2[c.str] || 0) + 1;
        return names2;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _2(strs, ...args) {
    const code2 = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code2, args[i]);
      code2.push(strs[++i]);
    }
    return new _Code(code2);
  }
  exports._ = _2;
  const plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code2, arg) {
    if (arg instanceof _Code)
      code2.push(...arg._items);
    else if (arg instanceof Name)
      code2.push(arg);
    else
      code2.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== void 0) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a, b2) {
    if (b2 === '""')
      return a;
    if (a === '""')
      return b2;
    if (typeof a == "string") {
      if (b2 instanceof Name || a[a.length - 1] !== '"')
        return;
      if (typeof b2 != "string")
        return `${a.slice(0, -1)}${b2}"`;
      if (b2[0] === '"')
        return a.slice(0, -1) + b2.slice(1);
      return;
    }
    if (typeof b2 == "string" && b2[0] === '"' && !(a instanceof Name))
      return `"${a}${b2.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x2) {
    return typeof x2 == "number" || typeof x2 == "boolean" || x2 === null ? x2 : safeStringify(Array.isArray(x2) ? x2.join(",") : x2);
  }
  function stringify(x2) {
    return new _Code(safeStringify(x2));
  }
  exports.stringify = stringify;
  function safeStringify(x2) {
    return JSON.stringify(x2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _2`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
})(code$1);
var scope = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
  const code_12 = code$1;
  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_12.Name("const"),
    let: new code_12.Name("let"),
    var: new code_12.Name("var")
  };
  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix2) {
      return new code_12.Name(this._newName(prefix2));
    }
    _newName(prefix2) {
      const ng = this._names[prefix2] || this._nameGroup(prefix2);
      return `${prefix2}${ng.index++}`;
    }
    _nameGroup(prefix2) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix2)) || this._prefixes && !this._prefixes.has(prefix2)) {
        throw new Error(`CodeGen: prefix "${prefix2}" is not allowed in this scope`);
      }
      return this._names[prefix2] = { prefix: prefix2, index: 0 };
    }
  }
  exports.Scope = Scope;
  class ValueScopeName extends code_12.Name {
    constructor(prefix2, nameStr) {
      super(nameStr);
      this.prefix = prefix2;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  const line = (0, code_12._)`\n`;
  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix2) {
      return new ValueScopeName(prefix2, this._newName(prefix2));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix: prefix2 } = name;
      const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
      let vs2 = this._values[prefix2];
      if (vs2) {
        const _name = vs2.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs2 = this._values[prefix2] = /* @__PURE__ */ new Map();
      }
      vs2.set(valueKey, name);
      const s = this._scope[prefix2] || (this._scope[prefix2] = []);
      const itemIndex = s.length;
      s[itemIndex] = value.ref;
      name.setValue(value, { property: prefix2, itemIndex });
      return name;
    }
    getValue(prefix2, keyOrRef) {
      const vs2 = this._values[prefix2];
      if (!vs2)
        return;
      return vs2.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_12._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === void 0)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code2 = code_12.nil;
      for (const prefix2 in values) {
        const vs2 = values[prefix2];
        if (!vs2)
          continue;
        const nameSet = usedValues[prefix2] = usedValues[prefix2] || /* @__PURE__ */ new Map();
        vs2.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c = valueCode(name);
          if (c) {
            const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code2 = (0, code_12._)`${code2}${def2} ${name} = ${c};${this.opts._n}`;
          } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
            code2 = (0, code_12._)`${code2}${c}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code2;
    }
  }
  exports.ValueScope = ValueScope;
})(scope);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
  const code_12 = code$1;
  const scope_1 = scope;
  var code_2 = code$1;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = scope;
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_12._Code(">"),
    GTE: new code_12._Code(">="),
    LT: new code_12._Code("<"),
    LTE: new code_12._Code("<="),
    EQ: new code_12._Code("==="),
    NEQ: new code_12._Code("!=="),
    NOT: new code_12._Code("!"),
    OR: new code_12._Code("||"),
    AND: new code_12._Code("&&"),
    ADD: new code_12._Code("+")
  };
  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }
  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n;
    }
    optimizeNames(names2, constants) {
      if (!names2[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names2, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
    }
  }
  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n }) {
      return `${this.lhs} = ${this.rhs};` + _n;
    }
    optimizeNames(names2, constants) {
      if (this.lhs instanceof code_12.Name && !names2[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names2, constants);
      return this;
    }
    get names() {
      const names2 = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
      return addExprNames(names2, this.rhs);
    }
  }
  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
    }
  }
  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      return `${this.label}:` + _n;
    }
  }
  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n;
    }
  }
  class Throw extends Node {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render({ _n }) {
      return `throw ${this.error};` + _n;
    }
    get names() {
      return this.error.names;
    }
  }
  class AnyCode extends Node {
    constructor(code2) {
      super();
      this.code = code2;
    }
    render({ _n }) {
      return `${this.code};` + _n;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(names2, constants) {
      this.code = optimizeExpr(this.code, names2, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_12._CodeOrName ? this.code.names : {};
    }
  }
  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code2, n2) => code2 + n2.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n2 = nodes[i].optimizeNodes();
        if (Array.isArray(n2))
          nodes.splice(i, 1, ...n2);
        else if (n2)
          nodes[i] = n2;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    optimizeNames(names2, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n2 = nodes[i];
        if (n2.optimizeNames(names2, constants))
          continue;
        subtractNames(names2, n2.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((names2, n2) => addNames(names2, n2.names), {});
    }
  }
  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }
  class Root extends ParentNode {
  }
  class Else extends BlockNode {
  }
  Else.kind = "else";
  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code2 = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code2 += "else " + this.else.render(opts);
      return code2;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e2 = this.else;
      if (e2) {
        const ns2 = e2.optimizeNodes();
        e2 = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
      }
      if (e2) {
        if (cond === false)
          return e2 instanceof If ? e2 : e2.nodes;
        if (this.nodes.length)
          return this;
        return new If(not2(cond), e2 instanceof If ? [e2] : e2.nodes);
      }
      if (cond === false || !this.nodes.length)
        return void 0;
      return this;
    }
    optimizeNames(names2, constants) {
      var _a;
      this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
      if (!(super.optimizeNames(names2, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names2, constants);
      return this;
    }
    get names() {
      const names2 = super.names;
      addExprNames(names2, this.condition);
      if (this.else)
        addNames(names2, this.else.names);
      return names2;
    }
  }
  If.kind = "if";
  class For extends BlockNode {
  }
  For.kind = "for";
  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names2, constants) {
      if (!super.optimizeNames(names2, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names2, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }
  class ForRange extends For {
    constructor(varKind, name, from, to) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names2 = addExprNames(super.names, this.from);
      return addExprNames(names2, this.to);
    }
  }
  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names2, constants) {
      if (!super.optimizeNames(names2, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names2, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }
  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";
  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";
  class Try extends BlockNode {
    render(opts) {
      let code2 = "try" + super.render(opts);
      if (this.catch)
        code2 += this.catch.render(opts);
      if (this.finally)
        code2 += this.finally.render(opts);
      return code2;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
      return this;
    }
    optimizeNames(names2, constants) {
      var _a, _b;
      super.optimizeNames(names2, constants);
      (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names2, constants);
      (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names2, constants);
      return this;
    }
    get names() {
      const names2 = super.names;
      if (this.catch)
        addNames(names2, this.catch.names);
      if (this.finally)
        addNames(names2, this.finally.names);
      return names2;
    }
  }
  class Catch extends BlockNode {
    constructor(error2) {
      super();
      this.error = error2;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";
  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";
  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(prefix2) {
      return this._scope.name(prefix2);
    }
    // reserves unique name in the external scope
    scopeName(prefix2) {
      return this._extScope.name(prefix2);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs2 = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
      vs2.add(name);
      return name;
    }
    getScopeValue(prefix2, keyOrRef) {
      return this._extScope.getValue(prefix2, keyOrRef);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant2) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== void 0 && constant2)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    // assignment code
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    // `+=` code
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    // appends passed SafeExpr to code or executes Block
    code(c) {
      if (typeof c == "function")
        c();
      else if (c !== code_12.nil)
        this._leafNode(new AnyCode(c));
      return this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
      const code2 = ["{"];
      for (const [key, value] of keyValues) {
        if (code2.length > 1)
          code2.push(",");
        code2.push(key);
        if (key !== value || this.opts.es5) {
          code2.push(":");
          (0, code_12.addCodeArg)(code2, value);
        }
      }
      code2.push("}");
      return new code_12._Code(code2);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new Else());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i) => {
          this.var(name, (0, code_12._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(For);
    }
    // `label` statement
    label(label) {
      return this._leafNode(new Label(label));
    }
    // `break` statement
    break(label) {
      return this._leafNode(new Break(label));
    }
    // `return` statement
    return(value) {
      const node = new Return();
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try();
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error2 = this.name("e");
        this._currNode = node.catch = new Catch(error2);
        catchCode(error2);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally();
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    // `throw` statement
    throw(error2) {
      return this._leafNode(new Throw(error2));
    }
    // start self-balancing block
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    // end the current self-balancing block
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_12.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n2 = 1) {
      while (n2-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N2) {
      const n2 = this._currNode;
      if (n2 instanceof N1 || N2 && n2 instanceof N2) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n2 = this._currNode;
      if (!(n2 instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n2.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns2 = this._nodes;
      return ns2[ns2.length - 1];
    }
    set _currNode(node) {
      const ns2 = this._nodes;
      ns2[ns2.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names2, from) {
    for (const n2 in from)
      names2[n2] = (names2[n2] || 0) + (from[n2] || 0);
    return names2;
  }
  function addExprNames(names2, from) {
    return from instanceof code_12._CodeOrName ? addNames(names2, from.names) : names2;
  }
  function optimizeExpr(expr, names2, constants) {
    if (expr instanceof code_12.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_12._Code(expr._items.reduce((items2, c) => {
      if (c instanceof code_12.Name)
        c = replaceName(c);
      if (c instanceof code_12._Code)
        items2.push(...c._items);
      else
        items2.push(c);
      return items2;
    }, []));
    function replaceName(n2) {
      const c = constants[n2.str];
      if (c === void 0 || names2[n2.str] !== 1)
        return n2;
      delete names2[n2.str];
      return c;
    }
    function canOptimize(e2) {
      return e2 instanceof code_12._Code && e2._items.some((c) => c instanceof code_12.Name && names2[c.str] === 1 && constants[c.str] !== void 0);
    }
  }
  function subtractNames(names2, from) {
    for (const n2 in from)
      names2[n2] = (names2[n2] || 0) - (from[n2] || 0);
  }
  function not2(x2) {
    return typeof x2 == "boolean" || typeof x2 == "number" || x2 === null ? !x2 : (0, code_12._)`!${par(x2)}`;
  }
  exports.not = not2;
  const andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  const orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x2, y) => x2 === code_12.nil ? y : y === code_12.nil ? x2 : (0, code_12._)`${par(x2)} ${op} ${par(y)}`;
  }
  function par(x2) {
    return x2 instanceof code_12.Name ? x2 : (0, code_12._)`(${x2})`;
  }
})(codegen);
var util = {};
Object.defineProperty(util, "__esModule", { value: true });
util.checkStrictMode = util.getErrorPath = util.Type = util.useFunc = util.setEvaluated = util.evaluatedPropsToName = util.mergeEvaluated = util.eachItem = util.unescapeJsonPointer = util.escapeJsonPointer = util.escapeFragment = util.unescapeFragment = util.schemaRefOrVal = util.schemaHasRulesButRef = util.schemaHasRules = util.checkUnknownRules = util.alwaysValidSchema = util.toHash = void 0;
const codegen_1$z = codegen;
const code_1$a = code$1;
function toHash(arr) {
  const hash = {};
  for (const item of arr)
    hash[item] = true;
  return hash;
}
util.toHash = toHash;
function alwaysValidSchema(it2, schema2) {
  if (typeof schema2 == "boolean")
    return schema2;
  if (Object.keys(schema2).length === 0)
    return true;
  checkUnknownRules(it2, schema2);
  return !schemaHasRules(schema2, it2.self.RULES.all);
}
util.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it2, schema2 = it2.schema) {
  const { opts, self: self2 } = it2;
  if (!opts.strictSchema)
    return;
  if (typeof schema2 === "boolean")
    return;
  const rules2 = self2.RULES.keywords;
  for (const key in schema2) {
    if (!rules2[key])
      checkStrictMode(it2, `unknown keyword: "${key}"`);
  }
}
util.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema2, rules2) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (rules2[key])
      return true;
  return false;
}
util.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema2, RULES) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (key !== "$ref" && RULES.all[key])
      return true;
  return false;
}
util.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath }, schema2, keyword2, $data) {
  if (!$data) {
    if (typeof schema2 == "number" || typeof schema2 == "boolean")
      return schema2;
    if (typeof schema2 == "string")
      return (0, codegen_1$z._)`${schema2}`;
  }
  return (0, codegen_1$z._)`${topSchemaRef}${schemaPath}${(0, codegen_1$z.getProperty)(keyword2)}`;
}
util.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}
util.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}
util.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
  if (typeof str == "number")
    return `${str}`;
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
util.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
  return str.replace(/~1/g, "/").replace(/~0/g, "~");
}
util.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs2, f) {
  if (Array.isArray(xs2)) {
    for (const x2 of xs2)
      f(x2);
  } else {
    f(xs2);
  }
}
util.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
  return (gen, from, to, toName) => {
    const res = to === void 0 ? from : to instanceof codegen_1$z.Name ? (from instanceof codegen_1$z.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1$z.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
    return toName === codegen_1$z.Name && !(res instanceof codegen_1$z.Name) ? resultToName(gen, res) : res;
  };
}
util.mergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true && ${from} !== undefined`, () => {
      gen.if((0, codegen_1$z._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1$z._)`${to} || {}`).code((0, codegen_1$z._)`Object.assign(${to}, ${from})`));
    }),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true`, () => {
      if (from === true) {
        gen.assign(to, true);
      } else {
        gen.assign(to, (0, codegen_1$z._)`${to} || {}`);
        setEvaluated(gen, to, from);
      }
    }),
    mergeValues: (from, to) => from === true ? true : { ...from, ...to },
    resultToName: evaluatedPropsToName
  }),
  items: makeMergeEvaluated({
    mergeNames: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1$z._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
    mergeToName: (gen, from, to) => gen.if((0, codegen_1$z._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1$z._)`${to} > ${from} ? ${to} : ${from}`)),
    mergeValues: (from, to) => from === true ? true : Math.max(from, to),
    resultToName: (gen, items2) => gen.var("items", items2)
  })
};
function evaluatedPropsToName(gen, ps2) {
  if (ps2 === true)
    return gen.var("props", true);
  const props = gen.var("props", (0, codegen_1$z._)`{}`);
  if (ps2 !== void 0)
    setEvaluated(gen, props, ps2);
  return props;
}
util.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps2) {
  Object.keys(ps2).forEach((p2) => gen.assign((0, codegen_1$z._)`${props}${(0, codegen_1$z.getProperty)(p2)}`, true));
}
util.setEvaluated = setEvaluated;
const snippets = {};
function useFunc(gen, f) {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets[f.code] || (snippets[f.code] = new code_1$a._Code(f.code))
  });
}
util.useFunc = useFunc;
var Type;
(function(Type2) {
  Type2[Type2["Num"] = 0] = "Num";
  Type2[Type2["Str"] = 1] = "Str";
})(Type || (util.Type = Type = {}));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
  if (dataProp instanceof codegen_1$z.Name) {
    const isNumber2 = dataPropType === Type.Num;
    return jsPropertySyntax ? isNumber2 ? (0, codegen_1$z._)`"[" + ${dataProp} + "]"` : (0, codegen_1$z._)`"['" + ${dataProp} + "']"` : isNumber2 ? (0, codegen_1$z._)`"/" + ${dataProp}` : (0, codegen_1$z._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
  }
  return jsPropertySyntax ? (0, codegen_1$z.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
}
util.getErrorPath = getErrorPath;
function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
  if (!mode)
    return;
  msg = `strict mode: ${msg}`;
  if (mode === true)
    throw new Error(msg);
  it2.self.logger.warn(msg);
}
util.checkStrictMode = checkStrictMode;
var names$1 = {};
Object.defineProperty(names$1, "__esModule", { value: true });
const codegen_1$y = codegen;
const names = {
  // validation function arguments
  data: new codegen_1$y.Name("data"),
  // data passed to validation function
  // args passed from referencing schema
  valCxt: new codegen_1$y.Name("valCxt"),
  // validation/data context - should not be used directly, it is destructured to the names below
  instancePath: new codegen_1$y.Name("instancePath"),
  parentData: new codegen_1$y.Name("parentData"),
  parentDataProperty: new codegen_1$y.Name("parentDataProperty"),
  rootData: new codegen_1$y.Name("rootData"),
  // root data - same as the data passed to the first/top validation function
  dynamicAnchors: new codegen_1$y.Name("dynamicAnchors"),
  // used to support recursiveRef and dynamicRef
  // function scoped variables
  vErrors: new codegen_1$y.Name("vErrors"),
  // null or array of validation errors
  errors: new codegen_1$y.Name("errors"),
  // counter of validation errors
  this: new codegen_1$y.Name("this"),
  // "globals"
  self: new codegen_1$y.Name("self"),
  scope: new codegen_1$y.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new codegen_1$y.Name("json"),
  jsonPos: new codegen_1$y.Name("jsonPos"),
  jsonLen: new codegen_1$y.Name("jsonLen"),
  jsonPart: new codegen_1$y.Name("jsonPart")
};
names$1.default = names;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const names_12 = names$1;
  exports.keywordError = {
    message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
  };
  function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_12._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error2, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_12.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_12.default.errors, errsCount);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen.assign(names_12.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword: keyword2, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === void 0)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_12.default.errors, (i) => {
      gen.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i}]`);
      gen.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it2.errSchemaPath}/${keyword2}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_12._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_12._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
    gen.code((0, codegen_12._)`${names_12.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_12._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_12._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  const E2 = {
    keyword: new codegen_12.Name("keyword"),
    schemaPath: new codegen_12.Name("schemaPath"),
    // also used in JTD errors
    params: new codegen_12.Name("params"),
    propertyName: new codegen_12.Name("propertyName"),
    message: new codegen_12.Name("message"),
    schema: new codegen_12.Name("schema"),
    parentSchema: new codegen_12.Name("parentSchema")
  };
  function errorObjectCode(cxt, error2, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_12._)`{}`;
    return errorObject(cxt, error2, errorPaths);
  }
  function errorObject(cxt, error2, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error2, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
    return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
    if (schemaPath) {
      schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
    }
    return [E2.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword: keyword2, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E2.keyword, keyword2], [E2.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
    if (opts.messages) {
      keyValues.push([E2.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E2.schema, schemaValue], [E2.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E2.propertyName, propertyName]);
  }
})(errors);
Object.defineProperty(boolSchema, "__esModule", { value: true });
boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
const errors_1$3 = errors;
const codegen_1$x = codegen;
const names_1$9 = names$1;
const boolError = {
  message: "boolean schema is false"
};
function topBoolOrEmptySchema(it2) {
  const { gen, schema: schema2, validateName } = it2;
  if (schema2 === false) {
    falseSchemaError(it2, false);
  } else if (typeof schema2 == "object" && schema2.$async === true) {
    gen.return(names_1$9.default.data);
  } else {
    gen.assign((0, codegen_1$x._)`${validateName}.errors`, null);
    gen.return(true);
  }
}
boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
function boolOrEmptySchema(it2, valid) {
  const { gen, schema: schema2 } = it2;
  if (schema2 === false) {
    gen.var(valid, false);
    falseSchemaError(it2);
  } else {
    gen.var(valid, true);
  }
}
boolSchema.boolOrEmptySchema = boolOrEmptySchema;
function falseSchemaError(it2, overrideAllErrors) {
  const { gen, data } = it2;
  const cxt = {
    gen,
    keyword: "false schema",
    data,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: it2
  };
  (0, errors_1$3.reportError)(cxt, boolError, void 0, overrideAllErrors);
}
var dataType = {};
var rules = {};
Object.defineProperty(rules, "__esModule", { value: true });
rules.getRules = rules.isJSONType = void 0;
const _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
const jsonTypes = new Set(_jsonTypes);
function isJSONType(x2) {
  return typeof x2 == "string" && jsonTypes.has(x2);
}
rules.isJSONType = isJSONType;
function getRules() {
  const groups = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...groups, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
rules.getRules = getRules;
var applicability = {};
Object.defineProperty(applicability, "__esModule", { value: true });
applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
function schemaHasRulesForType({ schema: schema2, self: self2 }, type2) {
  const group = self2.RULES.types[type2];
  return group && group !== true && shouldUseGroup(schema2, group);
}
applicability.schemaHasRulesForType = schemaHasRulesForType;
function shouldUseGroup(schema2, group) {
  return group.rules.some((rule) => shouldUseRule(schema2, rule));
}
applicability.shouldUseGroup = shouldUseGroup;
function shouldUseRule(schema2, rule) {
  var _a;
  return schema2[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema2[kwd] !== void 0));
}
applicability.shouldUseRule = shouldUseRule;
Object.defineProperty(dataType, "__esModule", { value: true });
dataType.reportTypeError = dataType.checkDataTypes = dataType.checkDataType = dataType.coerceAndCheckDataType = dataType.getJSONTypes = dataType.getSchemaTypes = dataType.DataType = void 0;
const rules_1 = rules;
const applicability_1$1 = applicability;
const errors_1$2 = errors;
const codegen_1$w = codegen;
const util_1$u = util;
var DataType;
(function(DataType2) {
  DataType2[DataType2["Correct"] = 0] = "Correct";
  DataType2[DataType2["Wrong"] = 1] = "Wrong";
})(DataType || (dataType.DataType = DataType = {}));
function getSchemaTypes(schema2) {
  const types2 = getJSONTypes(schema2.type);
  const hasNull = types2.includes("null");
  if (hasNull) {
    if (schema2.nullable === false)
      throw new Error("type: null contradicts nullable: false");
  } else {
    if (!types2.length && schema2.nullable !== void 0) {
      throw new Error('"nullable" cannot be used without "type"');
    }
    if (schema2.nullable === true)
      types2.push("null");
  }
  return types2;
}
dataType.getSchemaTypes = getSchemaTypes;
function getJSONTypes(ts2) {
  const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
  if (types2.every(rules_1.isJSONType))
    return types2;
  throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
}
dataType.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it2, types2) {
  const { gen, data, opts } = it2;
  const coerceTo = coerceToTypes(types2, opts.coerceTypes);
  const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1$1.schemaHasRulesForType)(it2, types2[0]));
  if (checkTypes) {
    const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
    gen.if(wrongType, () => {
      if (coerceTo.length)
        coerceData(it2, types2, coerceTo);
      else
        reportTypeError(it2);
    });
  }
  return checkTypes;
}
dataType.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types2, coerceTypes) {
  return coerceTypes ? types2.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
}
function coerceData(it2, types2, coerceTo) {
  const { gen, data, opts } = it2;
  const dataType2 = gen.let("dataType", (0, codegen_1$w._)`typeof ${data}`);
  const coerced = gen.let("coerced", (0, codegen_1$w._)`undefined`);
  if (opts.coerceTypes === "array") {
    gen.if((0, codegen_1$w._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1$w._)`${data}[0]`).assign(dataType2, (0, codegen_1$w._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data)));
  }
  gen.if((0, codegen_1$w._)`${coerced} !== undefined`);
  for (const t2 of coerceTo) {
    if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
      coerceSpecificType(t2);
    }
  }
  gen.else();
  reportTypeError(it2);
  gen.endIf();
  gen.if((0, codegen_1$w._)`${coerced} !== undefined`, () => {
    gen.assign(data, coerced);
    assignParentData(it2, coerced);
  });
  function coerceSpecificType(t2) {
    switch (t2) {
      case "string":
        gen.elseIf((0, codegen_1$w._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_1$w._)`"" + ${data}`).elseIf((0, codegen_1$w._)`${data} === null`).assign(coerced, (0, codegen_1$w._)`""`);
        return;
      case "number":
        gen.elseIf((0, codegen_1$w._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1$w._)`+${data}`);
        return;
      case "integer":
        gen.elseIf((0, codegen_1$w._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1$w._)`+${data}`);
        return;
      case "boolean":
        gen.elseIf((0, codegen_1$w._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1$w._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
        return;
      case "null":
        gen.elseIf((0, codegen_1$w._)`${data} === "" || ${data} === 0 || ${data} === false`);
        gen.assign(coerced, null);
        return;
      case "array":
        gen.elseIf((0, codegen_1$w._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1$w._)`[${data}]`);
    }
  }
}
function assignParentData({ gen, parentData, parentDataProperty }, expr) {
  gen.if((0, codegen_1$w._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1$w._)`${parentData}[${parentDataProperty}]`, expr));
}
function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
  const EQ = correct === DataType.Correct ? codegen_1$w.operators.EQ : codegen_1$w.operators.NEQ;
  let cond;
  switch (dataType2) {
    case "null":
      return (0, codegen_1$w._)`${data} ${EQ} null`;
    case "array":
      cond = (0, codegen_1$w._)`Array.isArray(${data})`;
      break;
    case "object":
      cond = (0, codegen_1$w._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
      break;
    case "integer":
      cond = numCond((0, codegen_1$w._)`!(${data} % 1) && !isNaN(${data})`);
      break;
    case "number":
      cond = numCond();
      break;
    default:
      return (0, codegen_1$w._)`typeof ${data} ${EQ} ${dataType2}`;
  }
  return correct === DataType.Correct ? cond : (0, codegen_1$w.not)(cond);
  function numCond(_cond = codegen_1$w.nil) {
    return (0, codegen_1$w.and)((0, codegen_1$w._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1$w._)`isFinite(${data})` : codegen_1$w.nil);
  }
}
dataType.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct);
  }
  let cond;
  const types2 = (0, util_1$u.toHash)(dataTypes);
  if (types2.array && types2.object) {
    const notObj = (0, codegen_1$w._)`typeof ${data} != "object"`;
    cond = types2.null ? notObj : (0, codegen_1$w._)`!${data} || ${notObj}`;
    delete types2.null;
    delete types2.array;
    delete types2.object;
  } else {
    cond = codegen_1$w.nil;
  }
  if (types2.number)
    delete types2.integer;
  for (const t2 in types2)
    cond = (0, codegen_1$w.and)(cond, checkDataType(t2, data, strictNums, correct));
  return cond;
}
dataType.checkDataTypes = checkDataTypes;
const typeError = {
  message: ({ schema: schema2 }) => `must be ${schema2}`,
  params: ({ schema: schema2, schemaValue }) => typeof schema2 == "string" ? (0, codegen_1$w._)`{type: ${schema2}}` : (0, codegen_1$w._)`{type: ${schemaValue}}`
};
function reportTypeError(it2) {
  const cxt = getTypeErrorContext(it2);
  (0, errors_1$2.reportError)(cxt, typeError);
}
dataType.reportTypeError = reportTypeError;
function getTypeErrorContext(it2) {
  const { gen, data, schema: schema2 } = it2;
  const schemaCode = (0, util_1$u.schemaRefOrVal)(it2, schema2, "type");
  return {
    gen,
    keyword: "type",
    data,
    schema: schema2.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema2,
    params: {},
    it: it2
  };
}
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.assignDefaults = void 0;
const codegen_1$v = codegen;
const util_1$t = util;
function assignDefaults(it2, ty) {
  const { properties: properties2, items: items2 } = it2.schema;
  if (ty === "object" && properties2) {
    for (const key in properties2) {
      assignDefault(it2, key, properties2[key].default);
    }
  } else if (ty === "array" && Array.isArray(items2)) {
    items2.forEach((sch, i) => assignDefault(it2, i, sch.default));
  }
}
defaults.assignDefaults = assignDefaults;
function assignDefault(it2, prop, defaultValue) {
  const { gen, compositeRule, data, opts } = it2;
  if (defaultValue === void 0)
    return;
  const childData = (0, codegen_1$v._)`${data}${(0, codegen_1$v.getProperty)(prop)}`;
  if (compositeRule) {
    (0, util_1$t.checkStrictMode)(it2, `default is ignored for: ${childData}`);
    return;
  }
  let condition = (0, codegen_1$v._)`${childData} === undefined`;
  if (opts.useDefaults === "empty") {
    condition = (0, codegen_1$v._)`${condition} || ${childData} === null || ${childData} === ""`;
  }
  gen.if(condition, (0, codegen_1$v._)`${childData} = ${(0, codegen_1$v.stringify)(defaultValue)}`);
}
var keyword = {};
var code = {};
Object.defineProperty(code, "__esModule", { value: true });
code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
const codegen_1$u = codegen;
const util_1$s = util;
const names_1$8 = names$1;
const util_2$1 = util;
function checkReportMissingProp(cxt, prop) {
  const { gen, data, it: it2 } = cxt;
  gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
    cxt.setParams({ missingProperty: (0, codegen_1$u._)`${prop}` }, true);
    cxt.error();
  });
}
code.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts } }, properties2, missing) {
  return (0, codegen_1$u.or)(...properties2.map((prop) => (0, codegen_1$u.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1$u._)`${missing} = ${prop}`)));
}
code.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
  cxt.setParams({ missingProperty: missing }, true);
  cxt.error();
}
code.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, codegen_1$u._)`Object.prototype.hasOwnProperty`
  });
}
code.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
  return (0, codegen_1$u._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
}
code.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} !== undefined`;
  return ownProperties ? (0, codegen_1$u._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
}
code.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
  const cond = (0, codegen_1$u._)`${data}${(0, codegen_1$u.getProperty)(property)} === undefined`;
  return ownProperties ? (0, codegen_1$u.or)(cond, (0, codegen_1$u.not)(isOwnProperty(gen, data, property))) : cond;
}
code.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
  return schemaMap ? Object.keys(schemaMap).filter((p2) => p2 !== "__proto__") : [];
}
code.allSchemaProperties = allSchemaProperties;
function schemaProperties(it2, schemaMap) {
  return allSchemaProperties(schemaMap).filter((p2) => !(0, util_1$s.alwaysValidSchema)(it2, schemaMap[p2]));
}
code.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
  const dataAndSchema = passSchema ? (0, codegen_1$u._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
  const valCxt = [
    [names_1$8.default.instancePath, (0, codegen_1$u.strConcat)(names_1$8.default.instancePath, errorPath)],
    [names_1$8.default.parentData, it2.parentData],
    [names_1$8.default.parentDataProperty, it2.parentDataProperty],
    [names_1$8.default.rootData, names_1$8.default.rootData]
  ];
  if (it2.opts.dynamicRef)
    valCxt.push([names_1$8.default.dynamicAnchors, names_1$8.default.dynamicAnchors]);
  const args = (0, codegen_1$u._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
  return context !== codegen_1$u.nil ? (0, codegen_1$u._)`${func}.call(${context}, ${args})` : (0, codegen_1$u._)`${func}(${args})`;
}
code.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1$u._)`new RegExp`;
function usePattern({ gen, it: { opts } }, pattern2) {
  const u = opts.unicodeRegExp ? "u" : "";
  const { regExp } = opts.code;
  const rx = regExp(pattern2, u);
  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: (0, codegen_1$u._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2$1.useFunc)(gen, regExp)}(${pattern2}, ${u})`
  });
}
code.usePattern = usePattern;
function validateArray(cxt) {
  const { gen, data, keyword: keyword2, it: it2 } = cxt;
  const valid = gen.name("valid");
  if (it2.allErrors) {
    const validArr = gen.let("valid", true);
    validateItems(() => gen.assign(validArr, false));
    return validArr;
  }
  gen.var(valid, true);
  validateItems(() => gen.break());
  return valid;
  function validateItems(notValid) {
    const len = gen.const("len", (0, codegen_1$u._)`${data}.length`);
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema({
        keyword: keyword2,
        dataProp: i,
        dataPropType: util_1$s.Type.Num
      }, valid);
      gen.if((0, codegen_1$u.not)(valid), notValid);
    });
  }
}
code.validateArray = validateArray;
function validateUnion(cxt) {
  const { gen, schema: schema2, keyword: keyword2, it: it2 } = cxt;
  if (!Array.isArray(schema2))
    throw new Error("ajv implementation error");
  const alwaysValid = schema2.some((sch) => (0, util_1$s.alwaysValidSchema)(it2, sch));
  if (alwaysValid && !it2.opts.unevaluated)
    return;
  const valid = gen.let("valid", false);
  const schValid = gen.name("_valid");
  gen.block(() => schema2.forEach((_sch, i) => {
    const schCxt = cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      compositeRule: true
    }, schValid);
    gen.assign(valid, (0, codegen_1$u._)`${valid} || ${schValid}`);
    const merged = cxt.mergeValidEvaluated(schCxt, schValid);
    if (!merged)
      gen.if((0, codegen_1$u.not)(valid));
  }));
  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
}
code.validateUnion = validateUnion;
Object.defineProperty(keyword, "__esModule", { value: true });
keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
const codegen_1$t = codegen;
const names_1$7 = names$1;
const code_1$9 = code;
const errors_1$1 = errors;
function macroKeywordCode(cxt, def2) {
  const { gen, keyword: keyword2, schema: schema2, parentSchema, it: it2 } = cxt;
  const macroSchema = def2.macro.call(it2.self, schema2, parentSchema, it2);
  const schemaRef = useKeyword(gen, keyword2, macroSchema);
  if (it2.opts.validateSchema !== false)
    it2.self.validateSchema(macroSchema, true);
  const valid = gen.name("valid");
  cxt.subschema({
    schema: macroSchema,
    schemaPath: codegen_1$t.nil,
    errSchemaPath: `${it2.errSchemaPath}/${keyword2}`,
    topSchemaRef: schemaRef,
    compositeRule: true
  }, valid);
  cxt.pass(valid, () => cxt.error(true));
}
keyword.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def2) {
  var _a;
  const { gen, keyword: keyword2, schema: schema2, parentSchema, $data, it: it2 } = cxt;
  checkAsyncKeyword(it2, def2);
  const validate2 = !$data && def2.compile ? def2.compile.call(it2.self, schema2, parentSchema, it2) : def2.validate;
  const validateRef = useKeyword(gen, keyword2, validate2);
  const valid = gen.let("valid");
  cxt.block$data(valid, validateKeyword);
  cxt.ok((_a = def2.valid) !== null && _a !== void 0 ? _a : valid);
  function validateKeyword() {
    if (def2.errors === false) {
      assignValid();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => cxt.error());
    } else {
      const ruleErrs = def2.async ? validateAsync() : validateSync();
      if (def2.modifying)
        modifyData(cxt);
      reportErrs(() => addErrs(cxt, ruleErrs));
    }
  }
  function validateAsync() {
    const ruleErrs = gen.let("ruleErrs", null);
    gen.try(() => assignValid((0, codegen_1$t._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1$t._)`${e2} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1$t._)`${e2}.errors`), () => gen.throw(e2)));
    return ruleErrs;
  }
  function validateSync() {
    const validateErrs = (0, codegen_1$t._)`${validateRef}.errors`;
    gen.assign(validateErrs, null);
    assignValid(codegen_1$t.nil);
    return validateErrs;
  }
  function assignValid(_await = def2.async ? (0, codegen_1$t._)`await ` : codegen_1$t.nil) {
    const passCxt = it2.opts.passContext ? names_1$7.default.this : names_1$7.default.self;
    const passSchema = !("compile" in def2 && !$data || def2.schema === false);
    gen.assign(valid, (0, codegen_1$t._)`${_await}${(0, code_1$9.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
  }
  function reportErrs(errors2) {
    var _a2;
    gen.if((0, codegen_1$t.not)((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors2);
  }
}
keyword.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
  const { gen, data, it: it2 } = cxt;
  gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1$t._)`${it2.parentData}[${it2.parentDataProperty}]`));
}
function addErrs(cxt, errs) {
  const { gen } = cxt;
  gen.if((0, codegen_1$t._)`Array.isArray(${errs})`, () => {
    gen.assign(names_1$7.default.vErrors, (0, codegen_1$t._)`${names_1$7.default.vErrors} === null ? ${errs} : ${names_1$7.default.vErrors}.concat(${errs})`).assign(names_1$7.default.errors, (0, codegen_1$t._)`${names_1$7.default.vErrors}.length`);
    (0, errors_1$1.extendErrors)(cxt);
  }, () => cxt.error());
}
function checkAsyncKeyword({ schemaEnv }, def2) {
  if (def2.async && !schemaEnv.$async)
    throw new Error("async keyword in sync schema");
}
function useKeyword(gen, keyword2, result) {
  if (result === void 0)
    throw new Error(`keyword "${keyword2}" failed to compile`);
  return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1$t.stringify)(result) });
}
function validSchemaType(schema2, schemaType, allowUndefined = false) {
  return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema2) : st2 === "object" ? schema2 && typeof schema2 == "object" && !Array.isArray(schema2) : typeof schema2 == st2 || allowUndefined && typeof schema2 == "undefined");
}
keyword.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema: schema2, opts, self: self2, errSchemaPath }, def2, keyword2) {
  if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
    throw new Error("ajv implementation error");
  }
  const deps = def2.dependencies;
  if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema2, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
  }
  if (def2.validateSchema) {
    const valid = def2.validateSchema(schema2[keyword2]);
    if (!valid) {
      const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
      if (opts.validateSchema === "log")
        self2.logger.error(msg);
      else
        throw new Error(msg);
    }
  }
}
keyword.validateKeywordUsage = validateKeywordUsage;
var subschema = {};
Object.defineProperty(subschema, "__esModule", { value: true });
subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
const codegen_1$s = codegen;
const util_1$r = util;
function getSubschema(it2, { keyword: keyword2, schemaProp, schema: schema2, schemaPath, errSchemaPath, topSchemaRef }) {
  if (keyword2 !== void 0 && schema2 !== void 0) {
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  }
  if (keyword2 !== void 0) {
    const sch = it2.schema[keyword2];
    return schemaProp === void 0 ? {
      schema: sch,
      schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}`
    } : {
      schema: sch[schemaProp],
      schemaPath: (0, codegen_1$s._)`${it2.schemaPath}${(0, codegen_1$s.getProperty)(keyword2)}${(0, codegen_1$s.getProperty)(schemaProp)}`,
      errSchemaPath: `${it2.errSchemaPath}/${keyword2}/${(0, util_1$r.escapeFragment)(schemaProp)}`
    };
  }
  if (schema2 !== void 0) {
    if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    }
    return {
      schema: schema2,
      schemaPath,
      topSchemaRef,
      errSchemaPath
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
subschema.getSubschema = getSubschema;
function extendSubschemaData(subschema2, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
  if (data !== void 0 && dataProp !== void 0) {
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  }
  const { gen } = it2;
  if (dataProp !== void 0) {
    const { errorPath, dataPathArr, opts } = it2;
    const nextData = gen.let("data", (0, codegen_1$s._)`${it2.data}${(0, codegen_1$s.getProperty)(dataProp)}`, true);
    dataContextProps(nextData);
    subschema2.errorPath = (0, codegen_1$s.str)`${errorPath}${(0, util_1$r.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
    subschema2.parentDataProperty = (0, codegen_1$s._)`${dataProp}`;
    subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
  }
  if (data !== void 0) {
    const nextData = data instanceof codegen_1$s.Name ? data : gen.let("data", data, true);
    dataContextProps(nextData);
    if (propertyName !== void 0)
      subschema2.propertyName = propertyName;
  }
  if (dataTypes)
    subschema2.dataTypes = dataTypes;
  function dataContextProps(_nextData) {
    subschema2.data = _nextData;
    subschema2.dataLevel = it2.dataLevel + 1;
    subschema2.dataTypes = [];
    it2.definedProperties = /* @__PURE__ */ new Set();
    subschema2.parentData = it2.data;
    subschema2.dataNames = [...it2.dataNames, _nextData];
  }
}
subschema.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
  if (compositeRule !== void 0)
    subschema2.compositeRule = compositeRule;
  if (createErrors !== void 0)
    subschema2.createErrors = createErrors;
  if (allErrors !== void 0)
    subschema2.allErrors = allErrors;
  subschema2.jtdDiscriminator = jtdDiscriminator;
  subschema2.jtdMetadata = jtdMetadata;
}
subschema.extendSubschemaMode = extendSubschemaMode;
var resolve$2 = {};
var fastDeepEqual = function equal(a, b2) {
  if (a === b2) return true;
  if (a && b2 && typeof a == "object" && typeof b2 == "object") {
    if (a.constructor !== b2.constructor) return false;
    var length, i, keys2;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b2.length) return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b2[i])) return false;
      return true;
    }
    if (a.constructor === RegExp) return a.source === b2.source && a.flags === b2.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b2.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b2.toString();
    keys2 = Object.keys(a);
    length = keys2.length;
    if (length !== Object.keys(b2).length) return false;
    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i])) return false;
    for (i = length; i-- !== 0; ) {
      var key = keys2[i];
      if (!equal(a[key], b2[key])) return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
};
var jsonSchemaTraverse = { exports: {} };
var traverse$1 = jsonSchemaTraverse.exports = function(schema2, opts, cb) {
  if (typeof opts == "function") {
    cb = opts;
    opts = {};
  }
  cb = opts.cb || cb;
  var pre = typeof cb == "function" ? cb : cb.pre || function() {
  };
  var post = cb.post || function() {
  };
  _traverse(opts, pre, post, schema2, "", schema2);
};
traverse$1.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
traverse$1.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
traverse$1.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
traverse$1.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function _traverse(opts, pre, post, schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema2 && typeof schema2 == "object" && !Array.isArray(schema2)) {
    pre(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema2) {
      var sch = schema2[key];
      if (Array.isArray(sch)) {
        if (key in traverse$1.arrayKeywords) {
          for (var i = 0; i < sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema2, i);
        }
      } else if (key in traverse$1.propsKeywords) {
        if (sch && typeof sch == "object") {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema2, prop);
        }
      } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
        _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema2);
      }
    }
    post(schema2, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}
function escapeJsonPtr(str) {
  return str.replace(/~/g, "~0").replace(/\//g, "~1");
}
var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
Object.defineProperty(resolve$2, "__esModule", { value: true });
resolve$2.getSchemaRefs = resolve$2.resolveUrl = resolve$2.normalizeId = resolve$2._getFullPath = resolve$2.getFullPath = resolve$2.inlineRef = void 0;
const util_1$q = util;
const equal$3 = fastDeepEqual;
const traverse = jsonSchemaTraverseExports;
const SIMPLE_INLINED = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function inlineRef(schema2, limit = true) {
  if (typeof schema2 == "boolean")
    return true;
  if (limit === true)
    return !hasRef(schema2);
  if (!limit)
    return false;
  return countKeys(schema2) <= limit;
}
resolve$2.inlineRef = inlineRef;
const REF_KEYWORDS = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function hasRef(schema2) {
  for (const key in schema2) {
    if (REF_KEYWORDS.has(key))
      return true;
    const sch = schema2[key];
    if (Array.isArray(sch) && sch.some(hasRef))
      return true;
    if (typeof sch == "object" && hasRef(sch))
      return true;
  }
  return false;
}
function countKeys(schema2) {
  let count = 0;
  for (const key in schema2) {
    if (key === "$ref")
      return Infinity;
    count++;
    if (SIMPLE_INLINED.has(key))
      continue;
    if (typeof schema2[key] == "object") {
      (0, util_1$q.eachItem)(schema2[key], (sch) => count += countKeys(sch));
    }
    if (count === Infinity)
      return Infinity;
  }
  return count;
}
function getFullPath(resolver, id2 = "", normalize2) {
  if (normalize2 !== false)
    id2 = normalizeId(id2);
  const p2 = resolver.parse(id2);
  return _getFullPath(resolver, p2);
}
resolve$2.getFullPath = getFullPath;
function _getFullPath(resolver, p2) {
  const serialized = resolver.serialize(p2);
  return serialized.split("#")[0] + "#";
}
resolve$2._getFullPath = _getFullPath;
const TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id2) {
  return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
}
resolve$2.normalizeId = normalizeId;
function resolveUrl(resolver, baseId, id2) {
  id2 = normalizeId(id2);
  return resolver.resolve(baseId, id2);
}
resolve$2.resolveUrl = resolveUrl;
const ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
function getSchemaRefs(schema2, baseId) {
  if (typeof schema2 == "boolean")
    return {};
  const { schemaId, uriResolver } = this.opts;
  const schId = normalizeId(schema2[schemaId] || baseId);
  const baseIds = { "": schId };
  const pathPrefix = getFullPath(uriResolver, schId, false);
  const localRefs = {};
  const schemaRefs = /* @__PURE__ */ new Set();
  traverse(schema2, { allKeys: true }, (sch, jsonPtr, _2, parentJsonPtr) => {
    if (parentJsonPtr === void 0)
      return;
    const fullPath = pathPrefix + jsonPtr;
    let innerBaseId = baseIds[parentJsonPtr];
    if (typeof sch[schemaId] == "string")
      innerBaseId = addRef.call(this, sch[schemaId]);
    addAnchor.call(this, sch.$anchor);
    addAnchor.call(this, sch.$dynamicAnchor);
    baseIds[jsonPtr] = innerBaseId;
    function addRef(ref2) {
      const _resolve = this.opts.uriResolver.resolve;
      ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
      if (schemaRefs.has(ref2))
        throw ambiguos(ref2);
      schemaRefs.add(ref2);
      let schOrRef = this.refs[ref2];
      if (typeof schOrRef == "string")
        schOrRef = this.refs[schOrRef];
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref2);
      } else if (ref2 !== normalizeId(fullPath)) {
        if (ref2[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref2], ref2);
          localRefs[ref2] = sch;
        } else {
          this.refs[ref2] = fullPath;
        }
      }
      return ref2;
    }
    function addAnchor(anchor) {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor))
          throw new Error(`invalid anchor "${anchor}"`);
        addRef.call(this, `#${anchor}`);
      }
    }
  });
  return localRefs;
  function checkAmbiguosRef(sch1, sch2, ref2) {
    if (sch2 !== void 0 && !equal$3(sch1, sch2))
      throw ambiguos(ref2);
  }
  function ambiguos(ref2) {
    return new Error(`reference "${ref2}" resolves to more than one schema`);
  }
}
resolve$2.getSchemaRefs = getSchemaRefs;
Object.defineProperty(validate$1, "__esModule", { value: true });
validate$1.getData = validate$1.KeywordCxt = validate$1.validateFunctionCode = void 0;
const boolSchema_1 = boolSchema;
const dataType_1$1 = dataType;
const applicability_1 = applicability;
const dataType_2 = dataType;
const defaults_1 = defaults;
const keyword_1 = keyword;
const subschema_1 = subschema;
const codegen_1$r = codegen;
const names_1$6 = names$1;
const resolve_1$2 = resolve$2;
const util_1$p = util;
const errors_1 = errors;
function validateFunctionCode(it2) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      topSchemaObjCode(it2);
      return;
    }
  }
  validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
}
validate$1.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema: schema2, schemaEnv, opts }, body) {
  if (opts.code.es5) {
    gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${names_1$6.default.valCxt}`, schemaEnv.$async, () => {
      gen.code((0, codegen_1$r._)`"use strict"; ${funcSourceUrl(schema2, opts)}`);
      destructureValCxtES5(gen, opts);
      gen.code(body);
    });
  } else {
    gen.func(validateName, (0, codegen_1$r._)`${names_1$6.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema2, opts)).code(body));
  }
}
function destructureValCxt(opts) {
  return (0, codegen_1$r._)`{${names_1$6.default.instancePath}="", ${names_1$6.default.parentData}, ${names_1$6.default.parentDataProperty}, ${names_1$6.default.rootData}=${names_1$6.default.data}${opts.dynamicRef ? (0, codegen_1$r._)`, ${names_1$6.default.dynamicAnchors}={}` : codegen_1$r.nil}}={}`;
}
function destructureValCxtES5(gen, opts) {
  gen.if(names_1$6.default.valCxt, () => {
    gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.instancePath}`);
    gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentData}`);
    gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.parentDataProperty}`);
    gen.var(names_1$6.default.rootData, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.rootData}`);
    if (opts.dynamicRef)
      gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`${names_1$6.default.valCxt}.${names_1$6.default.dynamicAnchors}`);
  }, () => {
    gen.var(names_1$6.default.instancePath, (0, codegen_1$r._)`""`);
    gen.var(names_1$6.default.parentData, (0, codegen_1$r._)`undefined`);
    gen.var(names_1$6.default.parentDataProperty, (0, codegen_1$r._)`undefined`);
    gen.var(names_1$6.default.rootData, names_1$6.default.data);
    if (opts.dynamicRef)
      gen.var(names_1$6.default.dynamicAnchors, (0, codegen_1$r._)`{}`);
  });
}
function topSchemaObjCode(it2) {
  const { schema: schema2, opts, gen } = it2;
  validateFunction(it2, () => {
    if (opts.$comment && schema2.$comment)
      commentKeyword(it2);
    checkNoDefault(it2);
    gen.let(names_1$6.default.vErrors, null);
    gen.let(names_1$6.default.errors, 0);
    if (opts.unevaluated)
      resetEvaluated(it2);
    typeAndKeywords(it2);
    returnResults(it2);
  });
  return;
}
function resetEvaluated(it2) {
  const { gen, validateName } = it2;
  it2.evaluated = gen.const("evaluated", (0, codegen_1$r._)`${validateName}.evaluated`);
  gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.props`, (0, codegen_1$r._)`undefined`));
  gen.if((0, codegen_1$r._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1$r._)`${it2.evaluated}.items`, (0, codegen_1$r._)`undefined`));
}
function funcSourceUrl(schema2, opts) {
  const schId = typeof schema2 == "object" && schema2[opts.schemaId];
  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1$r._)`/*# sourceURL=${schId} */` : codegen_1$r.nil;
}
function subschemaCode(it2, valid) {
  if (isSchemaObj(it2)) {
    checkKeywords(it2);
    if (schemaCxtHasRules(it2)) {
      subSchemaObjCode(it2, valid);
      return;
    }
  }
  (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
}
function schemaCxtHasRules({ schema: schema2, self: self2 }) {
  if (typeof schema2 == "boolean")
    return !schema2;
  for (const key in schema2)
    if (self2.RULES.all[key])
      return true;
  return false;
}
function isSchemaObj(it2) {
  return typeof it2.schema != "boolean";
}
function subSchemaObjCode(it2, valid) {
  const { schema: schema2, gen, opts } = it2;
  if (opts.$comment && schema2.$comment)
    commentKeyword(it2);
  updateContext(it2);
  checkAsyncSchema(it2);
  const errsCount = gen.const("_errs", names_1$6.default.errors);
  typeAndKeywords(it2, errsCount);
  gen.var(valid, (0, codegen_1$r._)`${errsCount} === ${names_1$6.default.errors}`);
}
function checkKeywords(it2) {
  (0, util_1$p.checkUnknownRules)(it2);
  checkRefsAndKeywords(it2);
}
function typeAndKeywords(it2, errsCount) {
  if (it2.opts.jtd)
    return schemaKeywords(it2, [], false, errsCount);
  const types2 = (0, dataType_1$1.getSchemaTypes)(it2.schema);
  const checkedTypes = (0, dataType_1$1.coerceAndCheckDataType)(it2, types2);
  schemaKeywords(it2, types2, !checkedTypes, errsCount);
}
function checkRefsAndKeywords(it2) {
  const { schema: schema2, errSchemaPath, opts, self: self2 } = it2;
  if (schema2.$ref && opts.ignoreKeywordsWithRef && (0, util_1$p.schemaHasRulesButRef)(schema2, self2.RULES)) {
    self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
  }
}
function checkNoDefault(it2) {
  const { schema: schema2, opts } = it2;
  if (schema2.default !== void 0 && opts.useDefaults && opts.strictSchema) {
    (0, util_1$p.checkStrictMode)(it2, "default is ignored in the schema root");
  }
}
function updateContext(it2) {
  const schId = it2.schema[it2.opts.schemaId];
  if (schId)
    it2.baseId = (0, resolve_1$2.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
}
function checkAsyncSchema(it2) {
  if (it2.schema.$async && !it2.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function commentKeyword({ gen, schemaEnv, schema: schema2, errSchemaPath, opts }) {
  const msg = schema2.$comment;
  if (opts.$comment === true) {
    gen.code((0, codegen_1$r._)`${names_1$6.default.self}.logger.log(${msg})`);
  } else if (typeof opts.$comment == "function") {
    const schemaPath = (0, codegen_1$r.str)`${errSchemaPath}/$comment`;
    const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
    gen.code((0, codegen_1$r._)`${names_1$6.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
  }
}
function returnResults(it2) {
  const { gen, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it2;
  if (schemaEnv.$async) {
    gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === 0`, () => gen.return(names_1$6.default.data), () => gen.throw((0, codegen_1$r._)`new ${ValidationError2}(${names_1$6.default.vErrors})`));
  } else {
    gen.assign((0, codegen_1$r._)`${validateName}.errors`, names_1$6.default.vErrors);
    if (opts.unevaluated)
      assignEvaluated(it2);
    gen.return((0, codegen_1$r._)`${names_1$6.default.errors} === 0`);
  }
}
function assignEvaluated({ gen, evaluated, props, items: items2 }) {
  if (props instanceof codegen_1$r.Name)
    gen.assign((0, codegen_1$r._)`${evaluated}.props`, props);
  if (items2 instanceof codegen_1$r.Name)
    gen.assign((0, codegen_1$r._)`${evaluated}.items`, items2);
}
function schemaKeywords(it2, types2, typeErrors, errsCount) {
  const { gen, schema: schema2, data, allErrors, opts, self: self2 } = it2;
  const { RULES } = self2;
  if (schema2.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1$p.schemaHasRulesButRef)(schema2, RULES))) {
    gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
    return;
  }
  if (!opts.jtd)
    checkStrictTypes(it2, types2);
  gen.block(() => {
    for (const group of RULES.rules)
      groupKeywords(group);
    groupKeywords(RULES.post);
  });
  function groupKeywords(group) {
    if (!(0, applicability_1.shouldUseGroup)(schema2, group))
      return;
    if (group.type) {
      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
      iterateKeywords(it2, group);
      if (types2.length === 1 && types2[0] === group.type && typeErrors) {
        gen.else();
        (0, dataType_2.reportTypeError)(it2);
      }
      gen.endIf();
    } else {
      iterateKeywords(it2, group);
    }
    if (!allErrors)
      gen.if((0, codegen_1$r._)`${names_1$6.default.errors} === ${errsCount || 0}`);
  }
}
function iterateKeywords(it2, group) {
  const { gen, schema: schema2, opts: { useDefaults } } = it2;
  if (useDefaults)
    (0, defaults_1.assignDefaults)(it2, group.type);
  gen.block(() => {
    for (const rule of group.rules) {
      if ((0, applicability_1.shouldUseRule)(schema2, rule)) {
        keywordCode(it2, rule.keyword, rule.definition, group.type);
      }
    }
  });
}
function checkStrictTypes(it2, types2) {
  if (it2.schemaEnv.meta || !it2.opts.strictTypes)
    return;
  checkContextTypes(it2, types2);
  if (!it2.opts.allowUnionTypes)
    checkMultipleTypes(it2, types2);
  checkKeywordTypes(it2, it2.dataTypes);
}
function checkContextTypes(it2, types2) {
  if (!types2.length)
    return;
  if (!it2.dataTypes.length) {
    it2.dataTypes = types2;
    return;
  }
  types2.forEach((t2) => {
    if (!includesType(it2.dataTypes, t2)) {
      strictTypesError(it2, `type "${t2}" not allowed by context "${it2.dataTypes.join(",")}"`);
    }
  });
  narrowSchemaTypes(it2, types2);
}
function checkMultipleTypes(it2, ts2) {
  if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
    strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
  }
}
function checkKeywordTypes(it2, ts2) {
  const rules2 = it2.self.RULES.all;
  for (const keyword2 in rules2) {
    const rule = rules2[keyword2];
    if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
      const { type: type2 } = rule.definition;
      if (type2.length && !type2.some((t2) => hasApplicableType(ts2, t2))) {
        strictTypesError(it2, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
      }
    }
  }
}
function hasApplicableType(schTs, kwdT) {
  return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
}
function includesType(ts2, t2) {
  return ts2.includes(t2) || t2 === "integer" && ts2.includes("number");
}
function narrowSchemaTypes(it2, withTypes) {
  const ts2 = [];
  for (const t2 of it2.dataTypes) {
    if (includesType(withTypes, t2))
      ts2.push(t2);
    else if (withTypes.includes("integer") && t2 === "number")
      ts2.push("integer");
  }
  it2.dataTypes = ts2;
}
function strictTypesError(it2, msg) {
  const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
  msg += ` at "${schemaPath}" (strictTypes)`;
  (0, util_1$p.checkStrictMode)(it2, msg, it2.opts.strictTypes);
}
class KeywordCxt {
  constructor(it2, def2, keyword2) {
    (0, keyword_1.validateKeywordUsage)(it2, def2, keyword2);
    this.gen = it2.gen;
    this.allErrors = it2.allErrors;
    this.keyword = keyword2;
    this.data = it2.data;
    this.schema = it2.schema[keyword2];
    this.$data = def2.$data && it2.opts.$data && this.schema && this.schema.$data;
    this.schemaValue = (0, util_1$p.schemaRefOrVal)(it2, this.schema, keyword2, this.$data);
    this.schemaType = def2.schemaType;
    this.parentSchema = it2.schema;
    this.params = {};
    this.it = it2;
    this.def = def2;
    if (this.$data) {
      this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
    } else {
      this.schemaCode = this.schemaValue;
      if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
        throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
      }
    }
    if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
      this.errsCount = it2.gen.const("_errs", names_1$6.default.errors);
    }
  }
  result(condition, successAction, failAction) {
    this.failResult((0, codegen_1$r.not)(condition), successAction, failAction);
  }
  failResult(condition, successAction, failAction) {
    this.gen.if(condition);
    if (failAction)
      failAction();
    else
      this.error();
    if (successAction) {
      this.gen.else();
      successAction();
      if (this.allErrors)
        this.gen.endIf();
    } else {
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
  }
  pass(condition, failAction) {
    this.failResult((0, codegen_1$r.not)(condition), void 0, failAction);
  }
  fail(condition) {
    if (condition === void 0) {
      this.error();
      if (!this.allErrors)
        this.gen.if(false);
      return;
    }
    this.gen.if(condition);
    this.error();
    if (this.allErrors)
      this.gen.endIf();
    else
      this.gen.else();
  }
  fail$data(condition) {
    if (!this.$data)
      return this.fail(condition);
    const { schemaCode } = this;
    this.fail((0, codegen_1$r._)`${schemaCode} !== undefined && (${(0, codegen_1$r.or)(this.invalid$data(), condition)})`);
  }
  error(append2, errorParams, errorPaths) {
    if (errorParams) {
      this.setParams(errorParams);
      this._error(append2, errorPaths);
      this.setParams({});
      return;
    }
    this._error(append2, errorPaths);
  }
  _error(append2, errorPaths) {
    (append2 ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
  }
  $dataError() {
    (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(cond) {
    if (!this.allErrors)
      this.gen.if(cond);
  }
  setParams(obj, assign) {
    if (assign)
      Object.assign(this.params, obj);
    else
      this.params = obj;
  }
  block$data(valid, codeBlock, $dataValid = codegen_1$r.nil) {
    this.gen.block(() => {
      this.check$data(valid, $dataValid);
      codeBlock();
    });
  }
  check$data(valid = codegen_1$r.nil, $dataValid = codegen_1$r.nil) {
    if (!this.$data)
      return;
    const { gen, schemaCode, schemaType, def: def2 } = this;
    gen.if((0, codegen_1$r.or)((0, codegen_1$r._)`${schemaCode} === undefined`, $dataValid));
    if (valid !== codegen_1$r.nil)
      gen.assign(valid, true);
    if (schemaType.length || def2.validateSchema) {
      gen.elseIf(this.invalid$data());
      this.$dataError();
      if (valid !== codegen_1$r.nil)
        gen.assign(valid, false);
    }
    gen.else();
  }
  invalid$data() {
    const { gen, schemaCode, schemaType, def: def2, it: it2 } = this;
    return (0, codegen_1$r.or)(wrong$DataType(), invalid$DataSchema());
    function wrong$DataType() {
      if (schemaType.length) {
        if (!(schemaCode instanceof codegen_1$r.Name))
          throw new Error("ajv implementation error");
        const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
        return (0, codegen_1$r._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
      }
      return codegen_1$r.nil;
    }
    function invalid$DataSchema() {
      if (def2.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", { ref: def2.validateSchema });
        return (0, codegen_1$r._)`!${validateSchemaRef}(${schemaCode})`;
      }
      return codegen_1$r.nil;
    }
  }
  subschema(appl, valid) {
    const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
    (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
    (0, subschema_1.extendSubschemaMode)(subschema2, appl);
    const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
    subschemaCode(nextContext, valid);
    return nextContext;
  }
  mergeEvaluated(schemaCxt, toName) {
    const { it: it2, gen } = this;
    if (!it2.opts.unevaluated)
      return;
    if (it2.props !== true && schemaCxt.props !== void 0) {
      it2.props = util_1$p.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
    }
    if (it2.items !== true && schemaCxt.items !== void 0) {
      it2.items = util_1$p.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
    }
  }
  mergeValidEvaluated(schemaCxt, valid) {
    const { it: it2, gen } = this;
    if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1$r.Name));
      return true;
    }
  }
}
validate$1.KeywordCxt = KeywordCxt;
function keywordCode(it2, keyword2, def2, ruleType) {
  const cxt = new KeywordCxt(it2, def2, keyword2);
  if ("code" in def2) {
    def2.code(cxt, ruleType);
  } else if (cxt.$data && def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  } else if ("macro" in def2) {
    (0, keyword_1.macroKeywordCode)(cxt, def2);
  } else if (def2.compile || def2.validate) {
    (0, keyword_1.funcKeywordCode)(cxt, def2);
  }
}
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr }) {
  let jsonPointer;
  let data;
  if ($data === "")
    return names_1$6.default.rootData;
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data))
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    jsonPointer = $data;
    data = names_1$6.default.rootData;
  } else {
    const matches = RELATIVE_JSON_POINTER.exec($data);
    if (!matches)
      throw new Error(`Invalid JSON-pointer: ${$data}`);
    const up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer === "#") {
      if (up >= dataLevel)
        throw new Error(errorMsg("property/index", up));
      return dataPathArr[dataLevel - up];
    }
    if (up > dataLevel)
      throw new Error(errorMsg("data", up));
    data = dataNames[dataLevel - up];
    if (!jsonPointer)
      return data;
  }
  let expr = data;
  const segments = jsonPointer.split("/");
  for (const segment of segments) {
    if (segment) {
      data = (0, codegen_1$r._)`${data}${(0, codegen_1$r.getProperty)((0, util_1$p.unescapeJsonPointer)(segment))}`;
      expr = (0, codegen_1$r._)`${expr} && ${data}`;
    }
  }
  return expr;
  function errorMsg(pointerType, up) {
    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
  }
}
validate$1.getData = getData;
var validation_error = {};
Object.defineProperty(validation_error, "__esModule", { value: true });
class ValidationError extends Error {
  constructor(errors2) {
    super("validation failed");
    this.errors = errors2;
    this.ajv = this.validation = true;
  }
}
validation_error.default = ValidationError;
var ref_error = {};
Object.defineProperty(ref_error, "__esModule", { value: true });
const resolve_1$1 = resolve$2;
class MissingRefError extends Error {
  constructor(resolver, baseId, ref2, msg) {
    super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
    this.missingRef = (0, resolve_1$1.resolveUrl)(resolver, baseId, ref2);
    this.missingSchema = (0, resolve_1$1.normalizeId)((0, resolve_1$1.getFullPath)(resolver, this.missingRef));
  }
}
ref_error.default = MissingRefError;
var compile = {};
Object.defineProperty(compile, "__esModule", { value: true });
compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
const codegen_1$q = codegen;
const validation_error_1 = validation_error;
const names_1$5 = names$1;
const resolve_1 = resolve$2;
const util_1$o = util;
const validate_1$1 = validate$1;
class SchemaEnv {
  constructor(env) {
    var _a;
    this.refs = {};
    this.dynamicAnchors = {};
    let schema2;
    if (typeof env.schema == "object")
      schema2 = env.schema;
    this.schema = env.schema;
    this.schemaId = env.schemaId;
    this.root = env.root || this;
    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema2 === null || schema2 === void 0 ? void 0 : schema2[env.schemaId || "$id"]);
    this.schemaPath = env.schemaPath;
    this.localRefs = env.localRefs;
    this.meta = env.meta;
    this.$async = schema2 === null || schema2 === void 0 ? void 0 : schema2.$async;
    this.refs = {};
  }
}
compile.SchemaEnv = SchemaEnv;
function compileSchema(sch) {
  const _sch = getCompilingSchema.call(this, sch);
  if (_sch)
    return _sch;
  const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
  const { es5, lines } = this.opts.code;
  const { ownProperties } = this.opts;
  const gen = new codegen_1$q.CodeGen(this.scope, { es5, lines, ownProperties });
  let _ValidationError;
  if (sch.$async) {
    _ValidationError = gen.scopeValue("Error", {
      ref: validation_error_1.default,
      code: (0, codegen_1$q._)`require("ajv/dist/runtime/validation_error").default`
    });
  }
  const validateName = gen.scopeName("validate");
  sch.validateName = validateName;
  const schemaCxt = {
    gen,
    allErrors: this.opts.allErrors,
    data: names_1$5.default.data,
    parentData: names_1$5.default.parentData,
    parentDataProperty: names_1$5.default.parentDataProperty,
    dataNames: [names_1$5.default.data],
    dataPathArr: [codegen_1$q.nil],
    // TODO can its length be used as dataLevel if nil is removed?
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$q.stringify)(sch.schema) } : { ref: sch.schema }),
    validateName,
    ValidationError: _ValidationError,
    schema: sch.schema,
    schemaEnv: sch,
    rootId,
    baseId: sch.baseId || rootId,
    schemaPath: codegen_1$q.nil,
    errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, codegen_1$q._)`""`,
    opts: this.opts,
    self: this
  };
  let sourceCode;
  try {
    this._compilations.add(sch);
    (0, validate_1$1.validateFunctionCode)(schemaCxt);
    gen.optimize(this.opts.code.optimize);
    const validateCode = gen.toString();
    sourceCode = `${gen.scopeRefs(names_1$5.default.scope)}return ${validateCode}`;
    if (this.opts.code.process)
      sourceCode = this.opts.code.process(sourceCode, sch);
    const makeValidate = new Function(`${names_1$5.default.self}`, `${names_1$5.default.scope}`, sourceCode);
    const validate2 = makeValidate(this, this.scope.get());
    this.scope.value(validateName, { ref: validate2 });
    validate2.errors = null;
    validate2.schema = sch.schema;
    validate2.schemaEnv = sch;
    if (sch.$async)
      validate2.$async = true;
    if (this.opts.code.source === true) {
      validate2.source = { validateName, validateCode, scopeValues: gen._values };
    }
    if (this.opts.unevaluated) {
      const { props, items: items2 } = schemaCxt;
      validate2.evaluated = {
        props: props instanceof codegen_1$q.Name ? void 0 : props,
        items: items2 instanceof codegen_1$q.Name ? void 0 : items2,
        dynamicProps: props instanceof codegen_1$q.Name,
        dynamicItems: items2 instanceof codegen_1$q.Name
      };
      if (validate2.source)
        validate2.source.evaluated = (0, codegen_1$q.stringify)(validate2.evaluated);
    }
    sch.validate = validate2;
    return sch;
  } catch (e2) {
    delete sch.validate;
    delete sch.validateName;
    if (sourceCode)
      this.logger.error("Error compiling schema, function code:", sourceCode);
    throw e2;
  } finally {
    this._compilations.delete(sch);
  }
}
compile.compileSchema = compileSchema;
function resolveRef(root2, baseId, ref2) {
  var _a;
  ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
  const schOrFunc = root2.refs[ref2];
  if (schOrFunc)
    return schOrFunc;
  let _sch = resolve$1.call(this, root2, ref2);
  if (_sch === void 0) {
    const schema2 = (_a = root2.localRefs) === null || _a === void 0 ? void 0 : _a[ref2];
    const { schemaId } = this.opts;
    if (schema2)
      _sch = new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  if (_sch === void 0)
    return;
  return root2.refs[ref2] = inlineOrCompile.call(this, _sch);
}
compile.resolveRef = resolveRef;
function inlineOrCompile(sch) {
  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
    return sch.schema;
  return sch.validate ? sch : compileSchema.call(this, sch);
}
function getCompilingSchema(schEnv) {
  for (const sch of this._compilations) {
    if (sameSchemaEnv(sch, schEnv))
      return sch;
  }
}
compile.getCompilingSchema = getCompilingSchema;
function sameSchemaEnv(s1, s2) {
  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
}
function resolve$1(root2, ref2) {
  let sch;
  while (typeof (sch = this.refs[ref2]) == "string")
    ref2 = sch;
  return sch || this.schemas[ref2] || resolveSchema.call(this, root2, ref2);
}
function resolveSchema(root2, ref2) {
  const p2 = this.opts.uriResolver.parse(ref2);
  const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p2);
  let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root2.baseId, void 0);
  if (Object.keys(root2.schema).length > 0 && refPath === baseId) {
    return getJsonPointer.call(this, p2, root2);
  }
  const id2 = (0, resolve_1.normalizeId)(refPath);
  const schOrRef = this.refs[id2] || this.schemas[id2];
  if (typeof schOrRef == "string") {
    const sch = resolveSchema.call(this, root2, schOrRef);
    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
      return;
    return getJsonPointer.call(this, p2, sch);
  }
  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
    return;
  if (!schOrRef.validate)
    compileSchema.call(this, schOrRef);
  if (id2 === (0, resolve_1.normalizeId)(ref2)) {
    const { schema: schema2 } = schOrRef;
    const { schemaId } = this.opts;
    const schId = schema2[schemaId];
    if (schId)
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    return new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  }
  return getJsonPointer.call(this, p2, schOrRef);
}
compile.resolveSchema = resolveSchema;
const PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function getJsonPointer(parsedRef, { baseId, schema: schema2, root: root2 }) {
  var _a;
  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
    return;
  for (const part of parsedRef.fragment.slice(1).split("/")) {
    if (typeof schema2 === "boolean")
      return;
    const partSchema = schema2[(0, util_1$o.unescapeFragment)(part)];
    if (partSchema === void 0)
      return;
    schema2 = partSchema;
    const schId = typeof schema2 === "object" && schema2[this.opts.schemaId];
    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
      baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
    }
  }
  let env;
  if (typeof schema2 != "boolean" && schema2.$ref && !(0, util_1$o.schemaHasRulesButRef)(schema2, this.RULES)) {
    const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema2.$ref);
    env = resolveSchema.call(this, root2, $ref);
  }
  const { schemaId } = this.opts;
  env = env || new SchemaEnv({ schema: schema2, schemaId, root: root2, baseId });
  if (env.schema !== env.root.schema)
    return env;
  return void 0;
}
const $id$7 = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
const description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
const type$7 = "object";
const required$1 = [
  "$data"
];
const properties$9 = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
const additionalProperties$1 = false;
const require$$9 = {
  $id: $id$7,
  description,
  type: type$7,
  required: required$1,
  properties: properties$9,
  additionalProperties: additionalProperties$1
};
var uri$1 = {};
var fastUri$1 = { exports: {} };
const HEX$1 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
var scopedChars = {
  HEX: HEX$1
};
const { HEX } = scopedChars;
function normalizeIPv4$1(host) {
  if (findToken(host, ".") < 3) {
    return { host, isIPV4: false };
  }
  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || [];
  const [address] = matches;
  if (address) {
    return { host: stripLeadingZeros(address, "."), isIPV4: true };
  } else {
    return { host, isIPV4: false };
  }
}
function stringArrayToHexStripped(input, keepZero = false) {
  let acc = "";
  let strip = true;
  for (const c of input) {
    if (HEX[c] === void 0) return void 0;
    if (c !== "0" && strip === true) strip = false;
    if (!strip) acc += c;
  }
  if (keepZero && acc.length === 0) acc = "0";
  return acc;
}
function getIPV6(input) {
  let tokenCount = 0;
  const output = { error: false, address: "", zone: "" };
  const address = [];
  const buffer = [];
  let isZone = false;
  let endipv6Encountered = false;
  let endIpv6 = false;
  function consume() {
    if (buffer.length) {
      if (isZone === false) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== void 0) {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
      }
      buffer.length = 0;
    }
    return true;
  }
  for (let i = 0; i < input.length; i++) {
    const cursor = input[i];
    if (cursor === "[" || cursor === "]") {
      continue;
    }
    if (cursor === ":") {
      if (endipv6Encountered === true) {
        endIpv6 = true;
      }
      if (!consume()) {
        break;
      }
      tokenCount++;
      address.push(":");
      if (tokenCount > 7) {
        output.error = true;
        break;
      }
      if (i - 1 >= 0 && input[i - 1] === ":") {
        endipv6Encountered = true;
      }
      continue;
    } else if (cursor === "%") {
      if (!consume()) {
        break;
      }
      isZone = true;
    } else {
      buffer.push(cursor);
      continue;
    }
  }
  if (buffer.length) {
    if (isZone) {
      output.zone = buffer.join("");
    } else if (endIpv6) {
      address.push(buffer.join(""));
    } else {
      address.push(stringArrayToHexStripped(buffer));
    }
  }
  output.address = address.join("");
  return output;
}
function normalizeIPv6$1(host, opts = {}) {
  if (findToken(host, ":") < 2) {
    return { host, isIPV6: false };
  }
  const ipv6 = getIPV6(host);
  if (!ipv6.error) {
    let newHost = ipv6.address;
    let escapedHost = ipv6.address;
    if (ipv6.zone) {
      newHost += "%" + ipv6.zone;
      escapedHost += "%25" + ipv6.zone;
    }
    return { host: newHost, escapedHost, isIPV6: true };
  } else {
    return { host, isIPV6: false };
  }
}
function stripLeadingZeros(str, token) {
  let out = "";
  let skip = true;
  const l = str.length;
  for (let i = 0; i < l; i++) {
    const c = str[i];
    if (c === "0" && skip) {
      if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
        out += c;
        skip = false;
      }
    } else {
      if (c === token) {
        skip = true;
      } else {
        skip = false;
      }
      out += c;
    }
  }
  return out;
}
function findToken(str, token) {
  let ind = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === token) ind++;
  }
  return ind;
}
const RDS1 = /^\.\.?\//u;
const RDS2 = /^\/\.(?:\/|$)/u;
const RDS3 = /^\/\.\.(?:\/|$)/u;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
function removeDotSegments$1(input) {
  const output = [];
  while (input.length) {
    if (input.match(RDS1)) {
      input = input.replace(RDS1, "");
    } else if (input.match(RDS2)) {
      input = input.replace(RDS2, "/");
    } else if (input.match(RDS3)) {
      input = input.replace(RDS3, "/");
      output.pop();
    } else if (input === "." || input === "..") {
      input = "";
    } else {
      const im = input.match(RDS5);
      if (im) {
        const s = im[0];
        input = input.slice(s.length);
        output.push(s);
      } else {
        throw new Error("Unexpected dot segment condition");
      }
    }
  }
  return output.join("");
}
function normalizeComponentEncoding$1(components, esc) {
  const func = esc !== true ? escape : unescape;
  if (components.scheme !== void 0) {
    components.scheme = func(components.scheme);
  }
  if (components.userinfo !== void 0) {
    components.userinfo = func(components.userinfo);
  }
  if (components.host !== void 0) {
    components.host = func(components.host);
  }
  if (components.path !== void 0) {
    components.path = func(components.path);
  }
  if (components.query !== void 0) {
    components.query = func(components.query);
  }
  if (components.fragment !== void 0) {
    components.fragment = func(components.fragment);
  }
  return components;
}
function recomposeAuthority$1(components, options) {
  const uriTokens = [];
  if (components.userinfo !== void 0) {
    uriTokens.push(components.userinfo);
    uriTokens.push("@");
  }
  if (components.host !== void 0) {
    let host = unescape(components.host);
    const ipV4res = normalizeIPv4$1(host);
    if (ipV4res.isIPV4) {
      host = ipV4res.host;
    } else {
      const ipV6res = normalizeIPv6$1(ipV4res.host, { isIPV4: false });
      if (ipV6res.isIPV6 === true) {
        host = `[${ipV6res.escapedHost}]`;
      } else {
        host = components.host;
      }
    }
    uriTokens.push(host);
  }
  if (typeof components.port === "number" || typeof components.port === "string") {
    uriTokens.push(":");
    uriTokens.push(String(components.port));
  }
  return uriTokens.length ? uriTokens.join("") : void 0;
}
var utils = {
  recomposeAuthority: recomposeAuthority$1,
  normalizeComponentEncoding: normalizeComponentEncoding$1,
  removeDotSegments: removeDotSegments$1,
  normalizeIPv4: normalizeIPv4$1,
  normalizeIPv6: normalizeIPv6$1,
  stringArrayToHexStripped
};
const UUID_REG = /^[\da-f]{8}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{4}\b-[\da-f]{12}$/iu;
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
function isSecure(wsComponents) {
  return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
function httpParse(components) {
  if (!components.host) {
    components.error = components.error || "HTTP URIs must have a host.";
  }
  return components;
}
function httpSerialize(components) {
  const secure = String(components.scheme).toLowerCase() === "https";
  if (components.port === (secure ? 443 : 80) || components.port === "") {
    components.port = void 0;
  }
  if (!components.path) {
    components.path = "/";
  }
  return components;
}
function wsParse(wsComponents) {
  wsComponents.secure = isSecure(wsComponents);
  wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
  wsComponents.path = void 0;
  wsComponents.query = void 0;
  return wsComponents;
}
function wsSerialize(wsComponents) {
  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
    wsComponents.port = void 0;
  }
  if (typeof wsComponents.secure === "boolean") {
    wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
    wsComponents.secure = void 0;
  }
  if (wsComponents.resourceName) {
    const [path, query] = wsComponents.resourceName.split("?");
    wsComponents.path = path && path !== "/" ? path : void 0;
    wsComponents.query = query;
    wsComponents.resourceName = void 0;
  }
  wsComponents.fragment = void 0;
  return wsComponents;
}
function urnParse(urnComponents, options) {
  if (!urnComponents.path) {
    urnComponents.error = "URN can not be parsed";
    return urnComponents;
  }
  const matches = urnComponents.path.match(URN_REG);
  if (matches) {
    const scheme = options.scheme || urnComponents.scheme || "urn";
    urnComponents.nid = matches[1].toLowerCase();
    urnComponents.nss = matches[2];
    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
    const schemeHandler = SCHEMES$1[urnScheme];
    urnComponents.path = void 0;
    if (schemeHandler) {
      urnComponents = schemeHandler.parse(urnComponents, options);
    }
  } else {
    urnComponents.error = urnComponents.error || "URN can not be parsed.";
  }
  return urnComponents;
}
function urnSerialize(urnComponents, options) {
  const scheme = options.scheme || urnComponents.scheme || "urn";
  const nid = urnComponents.nid.toLowerCase();
  const urnScheme = `${scheme}:${options.nid || nid}`;
  const schemeHandler = SCHEMES$1[urnScheme];
  if (schemeHandler) {
    urnComponents = schemeHandler.serialize(urnComponents, options);
  }
  const uriComponents = urnComponents;
  const nss = urnComponents.nss;
  uriComponents.path = `${nid || options.nid}:${nss}`;
  options.skipEscape = true;
  return uriComponents;
}
function urnuuidParse(urnComponents, options) {
  const uuidComponents = urnComponents;
  uuidComponents.uuid = uuidComponents.nss;
  uuidComponents.nss = void 0;
  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
    uuidComponents.error = uuidComponents.error || "UUID is not valid.";
  }
  return uuidComponents;
}
function urnuuidSerialize(uuidComponents) {
  const urnComponents = uuidComponents;
  urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
  return urnComponents;
}
const http = {
  scheme: "http",
  domainHost: true,
  parse: httpParse,
  serialize: httpSerialize
};
const https = {
  scheme: "https",
  domainHost: http.domainHost,
  parse: httpParse,
  serialize: httpSerialize
};
const ws = {
  scheme: "ws",
  domainHost: true,
  parse: wsParse,
  serialize: wsSerialize
};
const wss = {
  scheme: "wss",
  domainHost: ws.domainHost,
  parse: ws.parse,
  serialize: ws.serialize
};
const urn = {
  scheme: "urn",
  parse: urnParse,
  serialize: urnSerialize,
  skipNormalize: true
};
const urnuuid = {
  scheme: "urn:uuid",
  parse: urnuuidParse,
  serialize: urnuuidSerialize,
  skipNormalize: true
};
const SCHEMES$1 = {
  http,
  https,
  ws,
  wss,
  urn,
  "urn:uuid": urnuuid
};
var schemes = SCHEMES$1;
const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = utils;
const SCHEMES = schemes;
function normalize(uri2, options) {
  if (typeof uri2 === "string") {
    uri2 = serialize(parse(uri2, options), options);
  } else if (typeof uri2 === "object") {
    uri2 = parse(serialize(uri2, options), options);
  }
  return uri2;
}
function resolve(baseURI, relativeURI, options) {
  const schemelessOptions = Object.assign({ scheme: "null" }, options);
  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
  return serialize(resolved, { ...schemelessOptions, skipEscape: true });
}
function resolveComponents(base, relative, options, skipNormalization) {
  const target = {};
  if (!skipNormalization) {
    base = parse(serialize(base, options), options);
    relative = parse(serialize(relative, options), options);
  }
  options = options || {};
  if (!options.tolerant && relative.scheme) {
    target.scheme = relative.scheme;
    target.userinfo = relative.userinfo;
    target.host = relative.host;
    target.port = relative.port;
    target.path = removeDotSegments(relative.path || "");
    target.query = relative.query;
  } else {
    if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (!relative.path) {
        target.path = base.path;
        if (relative.query !== void 0) {
          target.query = relative.query;
        } else {
          target.query = base.query;
        }
      } else {
        if (relative.path.charAt(0) === "/") {
          target.path = removeDotSegments(relative.path);
        } else {
          if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
            target.path = "/" + relative.path;
          } else if (!base.path) {
            target.path = relative.path;
          } else {
            target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
          }
          target.path = removeDotSegments(target.path);
        }
        target.query = relative.query;
      }
      target.userinfo = base.userinfo;
      target.host = base.host;
      target.port = base.port;
    }
    target.scheme = base.scheme;
  }
  target.fragment = relative.fragment;
  return target;
}
function equal$2(uriA, uriB, options) {
  if (typeof uriA === "string") {
    uriA = unescape(uriA);
    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
  } else if (typeof uriA === "object") {
    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
  }
  if (typeof uriB === "string") {
    uriB = unescape(uriB);
    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
  } else if (typeof uriB === "object") {
    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
  }
  return uriA.toLowerCase() === uriB.toLowerCase();
}
function serialize(cmpts, opts) {
  const components = {
    host: cmpts.host,
    scheme: cmpts.scheme,
    userinfo: cmpts.userinfo,
    port: cmpts.port,
    path: cmpts.path,
    query: cmpts.query,
    nid: cmpts.nid,
    nss: cmpts.nss,
    uuid: cmpts.uuid,
    fragment: cmpts.fragment,
    reference: cmpts.reference,
    resourceName: cmpts.resourceName,
    secure: cmpts.secure,
    error: ""
  };
  const options = Object.assign({}, opts);
  const uriTokens = [];
  const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
  if (components.path !== void 0) {
    if (!options.skipEscape) {
      components.path = escape(components.path);
      if (components.scheme !== void 0) {
        components.path = components.path.split("%3A").join(":");
      }
    } else {
      components.path = unescape(components.path);
    }
  }
  if (options.reference !== "suffix" && components.scheme) {
    uriTokens.push(components.scheme);
    uriTokens.push(":");
  }
  const authority = recomposeAuthority(components, options);
  if (authority !== void 0) {
    if (options.reference !== "suffix") {
      uriTokens.push("//");
    }
    uriTokens.push(authority);
    if (components.path && components.path.charAt(0) !== "/") {
      uriTokens.push("/");
    }
  }
  if (components.path !== void 0) {
    let s = components.path;
    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
      s = removeDotSegments(s);
    }
    if (authority === void 0) {
      s = s.replace(/^\/\//u, "/%2F");
    }
    uriTokens.push(s);
  }
  if (components.query !== void 0) {
    uriTokens.push("?");
    uriTokens.push(components.query);
  }
  if (components.fragment !== void 0) {
    uriTokens.push("#");
    uriTokens.push(components.fragment);
  }
  return uriTokens.join("");
}
const hexLookUp = Array.from({ length: 127 }, (v2, k2) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k2)));
function nonSimpleDomain(value) {
  let code2 = 0;
  for (let i = 0, len = value.length; i < len; ++i) {
    code2 = value.charCodeAt(i);
    if (code2 > 126 || hexLookUp[code2]) {
      return true;
    }
  }
  return false;
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
function parse(uri2, opts) {
  const options = Object.assign({}, opts);
  const parsed = {
    scheme: void 0,
    userinfo: void 0,
    host: "",
    port: void 0,
    path: "",
    query: void 0,
    fragment: void 0
  };
  const gotEncoding = uri2.indexOf("%") !== -1;
  let isIP = false;
  if (options.reference === "suffix") uri2 = (options.scheme ? options.scheme + ":" : "") + "//" + uri2;
  const matches = uri2.match(URI_PARSE);
  if (matches) {
    parsed.scheme = matches[1];
    parsed.userinfo = matches[3];
    parsed.host = matches[4];
    parsed.port = parseInt(matches[5], 10);
    parsed.path = matches[6] || "";
    parsed.query = matches[7];
    parsed.fragment = matches[8];
    if (isNaN(parsed.port)) {
      parsed.port = matches[5];
    }
    if (parsed.host) {
      const ipv4result = normalizeIPv4(parsed.host);
      if (ipv4result.isIPV4 === false) {
        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false });
        parsed.host = ipv6result.host.toLowerCase();
        isIP = ipv6result.isIPV6;
      } else {
        parsed.host = ipv4result.host;
        isIP = true;
      }
    }
    if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && !parsed.path && parsed.query === void 0) {
      parsed.reference = "same-document";
    } else if (parsed.scheme === void 0) {
      parsed.reference = "relative";
    } else if (parsed.fragment === void 0) {
      parsed.reference = "absolute";
    } else {
      parsed.reference = "uri";
    }
    if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
      parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
    }
    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
      if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
        try {
          parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
        } catch (e2) {
          parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
        }
      }
    }
    if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
      if (gotEncoding && parsed.scheme !== void 0) {
        parsed.scheme = unescape(parsed.scheme);
      }
      if (gotEncoding && parsed.userinfo !== void 0) {
        parsed.userinfo = unescape(parsed.userinfo);
      }
      if (gotEncoding && parsed.host !== void 0) {
        parsed.host = unescape(parsed.host);
      }
      if (parsed.path !== void 0 && parsed.path.length) {
        parsed.path = escape(unescape(parsed.path));
      }
      if (parsed.fragment !== void 0 && parsed.fragment.length) {
        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
      }
    }
    if (schemeHandler && schemeHandler.parse) {
      schemeHandler.parse(parsed, options);
    }
  } else {
    parsed.error = parsed.error || "URI can not be parsed.";
  }
  return parsed;
}
const fastUri = {
  SCHEMES,
  normalize,
  resolve,
  resolveComponents,
  equal: equal$2,
  serialize,
  parse
};
fastUri$1.exports = fastUri;
fastUri$1.exports.default = fastUri;
fastUri$1.exports.fastUri = fastUri;
var fastUriExports = fastUri$1.exports;
Object.defineProperty(uri$1, "__esModule", { value: true });
const uri = fastUriExports;
uri.code = 'require("ajv/dist/runtime/uri").default';
uri$1.default = uri;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
  var validate_12 = validate$1;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  const validation_error_12 = validation_error;
  const ref_error_12 = ref_error;
  const rules_12 = rules;
  const compile_12 = compile;
  const codegen_2 = codegen;
  const resolve_12 = resolve$2;
  const dataType_12 = dataType;
  const util_12 = util;
  const $dataRefSchema = require$$9;
  const uri_1 = uri$1;
  const defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  const removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  const deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  const MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s2, _t3, _u, _v, _w, _x, _y, _z, _0;
    const s = o2.strict;
    const _optz = (_a = o2.code) === null || _a === void 0 ? void 0 : _a.optimize;
    const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e2 = o2.strictSchema) !== null && _e2 !== void 0 ? _e2 : s) !== null && _f !== void 0 ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
      loopEnum: (_r = o2.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
      meta: (_s2 = o2.meta) !== null && _s2 !== void 0 ? _s2 : true,
      messages: (_t3 = o2.messages) !== null && _t3 !== void 0 ? _t3 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== void 0 ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== void 0 ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== void 0 ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== void 0 ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== void 0 ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== void 0 ? _0 : true,
      uriResolver
    };
  }
  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = /* @__PURE__ */ new Set();
      this._loading = {};
      this._cache = /* @__PURE__ */ new Map();
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_12.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid;
    }
    compile(schema2, _meta) {
      const sch = this._addSchema(schema2, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema2, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema2, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e2) {
          if (!(e2 instanceof ref_error_12.default))
            throw e2;
          checkLoaded.call(this, e2);
          await loadMissingSchema.call(this, e2.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref2, missingRef }) {
        if (this.refs[ref2]) {
          throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref2) {
        const _schema = await _loadSchema.call(this, ref2);
        if (!this.refs[ref2])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref2])
          this.addSchema(_schema, ref2, meta);
      }
      async function _loadSchema(ref2) {
        const p2 = this._loading[ref2];
        if (p2)
          return p2;
        try {
          return await (this._loading[ref2] = loadSchema(ref2));
        } finally {
          delete this._loading[ref2];
        }
      }
    }
    // Adds schema to the instance
    addSchema(schema2, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema2)) {
        for (const sch of schema2)
          this.addSchema(sch, void 0, _meta, _validateSchema);
        return this;
      }
      let id2;
      if (typeof schema2 === "object") {
        const { schemaId } = this.opts;
        id2 = schema2[schemaId];
        if (id2 !== void 0 && typeof id2 != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_12.normalizeId)(key || id2);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema2, _meta, key, _validateSchema, true);
      return this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(schema2, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema2, key, true, _validateSchema);
      return this;
    }
    //  Validate schema against its meta-schema
    validateSchema(schema2, throwOrLogError) {
      if (typeof schema2 == "boolean")
        return true;
      let $schema2;
      $schema2 = schema2.$schema;
      if ($schema2 !== void 0 && typeof $schema2 != "string") {
        throw new Error("$schema must be a string");
      }
      $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema2) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema2, schema2);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === void 0) {
        const { schemaId } = this.opts;
        const root2 = new compile_12.SchemaEnv({ schema: {}, schemaId });
        sch = compile_12.resolveSchema.call(this, root2, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id2 = schemaKeyRef[this.opts.schemaId];
          if (id2) {
            id2 = (0, resolve_12.normalizeId)(id2);
            delete this.schemas[id2];
            delete this.refs[id2];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(definitions) {
      for (const def2 of definitions)
        this.addKeyword(def2);
      return this;
    }
    addKeyword(kwdOrDef, def2) {
      let keyword2;
      if (typeof kwdOrDef == "string") {
        keyword2 = kwdOrDef;
        if (typeof def2 == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def2.keyword = keyword2;
        }
      } else if (typeof kwdOrDef == "object" && def2 === void 0) {
        def2 = kwdOrDef;
        keyword2 = def2.keyword;
        if (Array.isArray(keyword2) && !keyword2.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword2, def2);
      if (!def2) {
        (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def2);
      const definition = {
        ...def2,
        type: (0, dataType_12.getJSONTypes)(def2.type),
        schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
      };
      (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k2) => addRule.call(this, k2, definition) : (k2) => definition.type.forEach((t2) => addRule.call(this, k2, definition, t2)));
      return this;
    }
    getKeyword(keyword2) {
      const rule = this.RULES.all[keyword2];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    // Remove keyword
    removeKeyword(keyword2) {
      const { RULES } = this;
      delete RULES.keywords[keyword2];
      delete RULES.all[keyword2];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword2);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    // Add format
    addFormat(name, format2) {
      if (typeof format2 == "string")
        format2 = new RegExp(format2);
      this.formats[name] = format2;
      return this;
    }
    errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors2 || errors2.length === 0)
        return "No errors";
      return errors2.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema2, keywordsJsonPointers) {
      const rules2 = this.RULES.all;
      metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema2;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules2) {
          const rule = rules2[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema2 = keywords[key];
          if ($data && schema2)
            keywords[key] = schemaOrData(schema2);
        }
      }
      return metaSchema2;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema2, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id2;
      const { schemaId } = this.opts;
      if (typeof schema2 == "object") {
        id2 = schema2[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema2 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema2);
      if (sch !== void 0)
        return sch;
      baseId = (0, resolve_12.normalizeId)(id2 || baseId);
      const localRefs = resolve_12.getSchemaRefs.call(this, schema2, baseId);
      sch = new compile_12.SchemaEnv({ schema: schema2, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema2, true);
      return sch;
    }
    _checkUnique(id2) {
      if (this.schemas[id2] || this.refs[id2]) {
        throw new Error(`schema with key or id "${id2}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_12.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_12.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_12.default;
  Ajv.MissingRefError = ref_error_12.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_12.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format2 = this.opts.formats[name];
      if (format2)
        this.addFormat(name, format2);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword2 in defs) {
      const def2 = defs[keyword2];
      if (!def2.keyword)
        def2.keyword = keyword2;
      this.addKeyword(def2);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  const noLogs = { log() {
  }, warn() {
  }, error() {
  } };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === void 0)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword2, def2) {
    const { RULES } = this;
    (0, util_12.eachItem)(keyword2, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def2)
      return;
    if (def2.$data && !("code" in def2 || "validate" in def2)) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword2, definition, dataType2) {
    var _a;
    const post = definition === null || definition === void 0 ? void 0 : definition.post;
    if (dataType2 && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType2);
    if (!ruleGroup) {
      ruleGroup = { type: dataType2, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword2] = true;
    if (!definition)
      return;
    const rule = {
      keyword: keyword2,
      definition: {
        ...definition,
        type: (0, dataType_12.getJSONTypes)(definition.type),
        schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword2] = rule;
    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def2) {
    let { metaSchema: metaSchema2 } = def2;
    if (metaSchema2 === void 0)
      return;
    if (def2.$data && this.opts.$data)
      metaSchema2 = schemaOrData(metaSchema2);
    def2.validateSchema = this.compile(metaSchema2, true);
  }
  const $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema2) {
    return { anyOf: [schema2, $dataRef] };
  }
})(core$3);
var draft7 = {};
var core$2 = {};
var id = {};
Object.defineProperty(id, "__esModule", { value: true });
const def$B = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
id.default = def$B;
var ref = {};
Object.defineProperty(ref, "__esModule", { value: true });
ref.callRef = ref.getValidate = void 0;
const ref_error_1$1 = ref_error;
const code_1$8 = code;
const codegen_1$p = codegen;
const names_1$4 = names$1;
const compile_1$2 = compile;
const util_1$n = util;
const def$A = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt) {
    const { gen, schema: $ref, it: it2 } = cxt;
    const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
    const { root: root2 } = env;
    if (($ref === "#" || $ref === "#/") && baseId === root2.baseId)
      return callRootRef();
    const schOrEnv = compile_1$2.resolveRef.call(self2, root2, baseId, $ref);
    if (schOrEnv === void 0)
      throw new ref_error_1$1.default(it2.opts.uriResolver, baseId, $ref);
    if (schOrEnv instanceof compile_1$2.SchemaEnv)
      return callValidate(schOrEnv);
    return inlineRefSchema(schOrEnv);
    function callRootRef() {
      if (env === root2)
        return callRef(cxt, validateName, env, env.$async);
      const rootName = gen.scopeValue("root", { ref: root2 });
      return callRef(cxt, (0, codegen_1$p._)`${rootName}.validate`, root2, root2.$async);
    }
    function callValidate(sch) {
      const v2 = getValidate(cxt, sch);
      callRef(cxt, v2, sch, sch.$async);
    }
    function inlineRefSchema(sch) {
      const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$p.stringify)(sch) } : { ref: sch });
      const valid = gen.name("valid");
      const schCxt = cxt.subschema({
        schema: sch,
        dataTypes: [],
        schemaPath: codegen_1$p.nil,
        topSchemaRef: schName,
        errSchemaPath: $ref
      }, valid);
      cxt.mergeEvaluated(schCxt);
      cxt.ok(valid);
    }
  }
};
function getValidate(cxt, sch) {
  const { gen } = cxt;
  return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$p._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
}
ref.getValidate = getValidate;
function callRef(cxt, v2, sch, $async) {
  const { gen, it: it2 } = cxt;
  const { allErrors, schemaEnv: env, opts } = it2;
  const passCxt = opts.passContext ? names_1$4.default.this : codegen_1$p.nil;
  if ($async)
    callAsyncRef();
  else
    callSyncRef();
  function callAsyncRef() {
    if (!env.$async)
      throw new Error("async schema referenced by sync schema");
    const valid = gen.let("valid");
    gen.try(() => {
      gen.code((0, codegen_1$p._)`await ${(0, code_1$8.callValidateCode)(cxt, v2, passCxt)}`);
      addEvaluatedFrom(v2);
      if (!allErrors)
        gen.assign(valid, true);
    }, (e2) => {
      gen.if((0, codegen_1$p._)`!(${e2} instanceof ${it2.ValidationError})`, () => gen.throw(e2));
      addErrorsFrom(e2);
      if (!allErrors)
        gen.assign(valid, false);
    });
    cxt.ok(valid);
  }
  function callSyncRef() {
    cxt.result((0, code_1$8.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
  }
  function addErrorsFrom(source) {
    const errs = (0, codegen_1$p._)`${source}.errors`;
    gen.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`);
    gen.assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
  }
  function addEvaluatedFrom(source) {
    var _a;
    if (!it2.opts.unevaluated)
      return;
    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
    if (it2.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== void 0) {
          it2.props = util_1$n.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
        }
      } else {
        const props = gen.var("props", (0, codegen_1$p._)`${source}.evaluated.props`);
        it2.props = util_1$n.mergeEvaluated.props(gen, props, it2.props, codegen_1$p.Name);
      }
    }
    if (it2.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== void 0) {
          it2.items = util_1$n.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
        }
      } else {
        const items2 = gen.var("items", (0, codegen_1$p._)`${source}.evaluated.items`);
        it2.items = util_1$n.mergeEvaluated.items(gen, items2, it2.items, codegen_1$p.Name);
      }
    }
  }
}
ref.callRef = callRef;
ref.default = def$A;
Object.defineProperty(core$2, "__esModule", { value: true });
const id_1 = id;
const ref_1$2 = ref;
const core$1 = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  id_1.default,
  ref_1$2.default
];
core$2.default = core$1;
var validation$2 = {};
var limitNumber = {};
Object.defineProperty(limitNumber, "__esModule", { value: true });
const codegen_1$o = codegen;
const ops = codegen_1$o.operators;
const KWDs = {
  maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
  minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
  exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
  exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
};
const error$k = {
  message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
  params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
};
const def$z = {
  keyword: Object.keys(KWDs),
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$k,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    cxt.fail$data((0, codegen_1$o._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
  }
};
limitNumber.default = def$z;
var multipleOf = {};
Object.defineProperty(multipleOf, "__esModule", { value: true });
const codegen_1$n = codegen;
const error$j = {
  message: ({ schemaCode }) => (0, codegen_1$n.str)`must be multiple of ${schemaCode}`,
  params: ({ schemaCode }) => (0, codegen_1$n._)`{multipleOf: ${schemaCode}}`
};
const def$y = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: error$j,
  code(cxt) {
    const { gen, data, schemaCode, it: it2 } = cxt;
    const prec = it2.opts.multipleOfPrecision;
    const res = gen.let("res");
    const invalid = prec ? (0, codegen_1$n._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$n._)`${res} !== parseInt(${res})`;
    cxt.fail$data((0, codegen_1$n._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
  }
};
multipleOf.default = def$y;
var limitLength = {};
var ucs2length$1 = {};
Object.defineProperty(ucs2length$1, "__esModule", { value: true });
function ucs2length(str) {
  const len = str.length;
  let length = 0;
  let pos = 0;
  let value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 55296 && value <= 56319 && pos < len) {
      value = str.charCodeAt(pos);
      if ((value & 64512) === 56320)
        pos++;
    }
  }
  return length;
}
ucs2length$1.default = ucs2length;
ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(limitLength, "__esModule", { value: true });
const codegen_1$m = codegen;
const util_1$m = util;
const ucs2length_1 = ucs2length$1;
const error$i = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxLength" ? "more" : "fewer";
    return (0, codegen_1$m.str)`must NOT have ${comp} than ${schemaCode} characters`;
  },
  params: ({ schemaCode }) => (0, codegen_1$m._)`{limit: ${schemaCode}}`
};
const def$x = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: error$i,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode, it: it2 } = cxt;
    const op = keyword2 === "maxLength" ? codegen_1$m.operators.GT : codegen_1$m.operators.LT;
    const len = it2.opts.unicode === false ? (0, codegen_1$m._)`${data}.length` : (0, codegen_1$m._)`${(0, util_1$m.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
    cxt.fail$data((0, codegen_1$m._)`${len} ${op} ${schemaCode}`);
  }
};
limitLength.default = def$x;
var pattern$9 = {};
Object.defineProperty(pattern$9, "__esModule", { value: true });
const code_1$7 = code;
const codegen_1$l = codegen;
const error$h = {
  message: ({ schemaCode }) => (0, codegen_1$l.str)`must match pattern "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$l._)`{pattern: ${schemaCode}}`
};
const def$w = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: error$h,
  code(cxt) {
    const { data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
    const u = it2.opts.unicodeRegExp ? "u" : "";
    const regExp = $data ? (0, codegen_1$l._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1$7.usePattern)(cxt, schema2);
    cxt.fail$data((0, codegen_1$l._)`!${regExp}.test(${data})`);
  }
};
pattern$9.default = def$w;
var limitProperties = {};
Object.defineProperty(limitProperties, "__esModule", { value: true });
const codegen_1$k = codegen;
const error$g = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxProperties" ? "more" : "fewer";
    return (0, codegen_1$k.str)`must NOT have ${comp} than ${schemaCode} properties`;
  },
  params: ({ schemaCode }) => (0, codegen_1$k._)`{limit: ${schemaCode}}`
};
const def$v = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: error$g,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxProperties" ? codegen_1$k.operators.GT : codegen_1$k.operators.LT;
    cxt.fail$data((0, codegen_1$k._)`Object.keys(${data}).length ${op} ${schemaCode}`);
  }
};
limitProperties.default = def$v;
var required = {};
Object.defineProperty(required, "__esModule", { value: true });
const code_1$6 = code;
const codegen_1$j = codegen;
const util_1$l = util;
const error$f = {
  message: ({ params: { missingProperty } }) => (0, codegen_1$j.str)`must have required property '${missingProperty}'`,
  params: ({ params: { missingProperty } }) => (0, codegen_1$j._)`{missingProperty: ${missingProperty}}`
};
const def$u = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: error$f,
  code(cxt) {
    const { gen, schema: schema2, schemaCode, data, $data, it: it2 } = cxt;
    const { opts } = it2;
    if (!$data && schema2.length === 0)
      return;
    const useLoop = schema2.length >= opts.loopRequired;
    if (it2.allErrors)
      allErrorsMode();
    else
      exitOnErrorMode();
    if (opts.strictRequired) {
      const props = cxt.parentSchema.properties;
      const { definedProperties } = cxt.it;
      for (const requiredKey of schema2) {
        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
          const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
          const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
          (0, util_1$l.checkStrictMode)(it2, msg, it2.opts.strictRequired);
        }
      }
    }
    function allErrorsMode() {
      if (useLoop || $data) {
        cxt.block$data(codegen_1$j.nil, loopAllRequired);
      } else {
        for (const prop of schema2) {
          (0, code_1$6.checkReportMissingProp)(cxt, prop);
        }
      }
    }
    function exitOnErrorMode() {
      const missing = gen.let("missing");
      if (useLoop || $data) {
        const valid = gen.let("valid", true);
        cxt.block$data(valid, () => loopUntilMissing(missing, valid));
        cxt.ok(valid);
      } else {
        gen.if((0, code_1$6.checkMissingProp)(cxt, schema2, missing));
        (0, code_1$6.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
    function loopAllRequired() {
      gen.forOf("prop", schemaCode, (prop) => {
        cxt.setParams({ missingProperty: prop });
        gen.if((0, code_1$6.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
      });
    }
    function loopUntilMissing(missing, valid) {
      cxt.setParams({ missingProperty: missing });
      gen.forOf(missing, schemaCode, () => {
        gen.assign(valid, (0, code_1$6.propertyInData)(gen, data, missing, opts.ownProperties));
        gen.if((0, codegen_1$j.not)(valid), () => {
          cxt.error();
          gen.break();
        });
      }, codegen_1$j.nil);
    }
  }
};
required.default = def$u;
var limitItems = {};
Object.defineProperty(limitItems, "__esModule", { value: true });
const codegen_1$i = codegen;
const error$e = {
  message({ keyword: keyword2, schemaCode }) {
    const comp = keyword2 === "maxItems" ? "more" : "fewer";
    return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} items`;
  },
  params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
};
const def$t = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: error$e,
  code(cxt) {
    const { keyword: keyword2, data, schemaCode } = cxt;
    const op = keyword2 === "maxItems" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
    cxt.fail$data((0, codegen_1$i._)`${data}.length ${op} ${schemaCode}`);
  }
};
limitItems.default = def$t;
var uniqueItems = {};
var equal$1 = {};
Object.defineProperty(equal$1, "__esModule", { value: true });
const equal2 = fastDeepEqual;
equal2.code = 'require("ajv/dist/runtime/equal").default';
equal$1.default = equal2;
Object.defineProperty(uniqueItems, "__esModule", { value: true });
const dataType_1 = dataType;
const codegen_1$h = codegen;
const util_1$k = util;
const equal_1$2 = equal$1;
const error$d = {
  message: ({ params: { i, j: j2 } }) => (0, codegen_1$h.str)`must NOT have duplicate items (items ## ${j2} and ${i} are identical)`,
  params: ({ params: { i, j: j2 } }) => (0, codegen_1$h._)`{i: ${i}, j: ${j2}}`
};
const def$s = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: error$d,
  code(cxt) {
    const { gen, data, $data, schema: schema2, parentSchema, schemaCode, it: it2 } = cxt;
    if (!$data && !schema2)
      return;
    const valid = gen.let("valid");
    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
    cxt.block$data(valid, validateUniqueItems, (0, codegen_1$h._)`${schemaCode} === false`);
    cxt.ok(valid);
    function validateUniqueItems() {
      const i = gen.let("i", (0, codegen_1$h._)`${data}.length`);
      const j2 = gen.let("j");
      cxt.setParams({ i, j: j2 });
      gen.assign(valid, true);
      gen.if((0, codegen_1$h._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j2));
    }
    function canOptimize() {
      return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
    }
    function loopN(i, j2) {
      const item = gen.name("item");
      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
      const indices = gen.const("indices", (0, codegen_1$h._)`{}`);
      gen.for((0, codegen_1$h._)`;${i}--;`, () => {
        gen.let(item, (0, codegen_1$h._)`${data}[${i}]`);
        gen.if(wrongType, (0, codegen_1$h._)`continue`);
        if (itemTypes.length > 1)
          gen.if((0, codegen_1$h._)`typeof ${item} == "string"`, (0, codegen_1$h._)`${item} += "_"`);
        gen.if((0, codegen_1$h._)`typeof ${indices}[${item}] == "number"`, () => {
          gen.assign(j2, (0, codegen_1$h._)`${indices}[${item}]`);
          cxt.error();
          gen.assign(valid, false).break();
        }).code((0, codegen_1$h._)`${indices}[${item}] = ${i}`);
      });
    }
    function loopN2(i, j2) {
      const eql = (0, util_1$k.useFunc)(gen, equal_1$2.default);
      const outer = gen.name("outer");
      gen.label(outer).for((0, codegen_1$h._)`;${i}--;`, () => gen.for((0, codegen_1$h._)`${j2} = ${i}; ${j2}--;`, () => gen.if((0, codegen_1$h._)`${eql}(${data}[${i}], ${data}[${j2}])`, () => {
        cxt.error();
        gen.assign(valid, false).break(outer);
      })));
    }
  }
};
uniqueItems.default = def$s;
var _const = {};
Object.defineProperty(_const, "__esModule", { value: true });
const codegen_1$g = codegen;
const util_1$j = util;
const equal_1$1 = equal$1;
const error$c = {
  message: "must be equal to constant",
  params: ({ schemaCode }) => (0, codegen_1$g._)`{allowedValue: ${schemaCode}}`
};
const def$r = {
  keyword: "const",
  $data: true,
  error: error$c,
  code(cxt) {
    const { gen, data, $data, schemaCode, schema: schema2 } = cxt;
    if ($data || schema2 && typeof schema2 == "object") {
      cxt.fail$data((0, codegen_1$g._)`!${(0, util_1$j.useFunc)(gen, equal_1$1.default)}(${data}, ${schemaCode})`);
    } else {
      cxt.fail((0, codegen_1$g._)`${schema2} !== ${data}`);
    }
  }
};
_const.default = def$r;
var _enum = {};
Object.defineProperty(_enum, "__esModule", { value: true });
const codegen_1$f = codegen;
const util_1$i = util;
const equal_1 = equal$1;
const error$b = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode }) => (0, codegen_1$f._)`{allowedValues: ${schemaCode}}`
};
const def$q = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: error$b,
  code(cxt) {
    const { gen, data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
    if (!$data && schema2.length === 0)
      throw new Error("enum must have non-empty array");
    const useLoop = schema2.length >= it2.opts.loopEnum;
    let eql;
    const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$i.useFunc)(gen, equal_1.default);
    let valid;
    if (useLoop || $data) {
      valid = gen.let("valid");
      cxt.block$data(valid, loopEnum);
    } else {
      if (!Array.isArray(schema2))
        throw new Error("ajv implementation error");
      const vSchema = gen.const("vSchema", schemaCode);
      valid = (0, codegen_1$f.or)(...schema2.map((_x, i) => equalCode(vSchema, i)));
    }
    cxt.pass(valid);
    function loopEnum() {
      gen.assign(valid, false);
      gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1$f._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
    }
    function equalCode(vSchema, i) {
      const sch = schema2[i];
      return typeof sch === "object" && sch !== null ? (0, codegen_1$f._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1$f._)`${data} === ${sch}`;
    }
  }
};
_enum.default = def$q;
Object.defineProperty(validation$2, "__esModule", { value: true });
const limitNumber_1 = limitNumber;
const multipleOf_1 = multipleOf;
const limitLength_1 = limitLength;
const pattern_1 = pattern$9;
const limitProperties_1 = limitProperties;
const required_1 = required;
const limitItems_1 = limitItems;
const uniqueItems_1 = uniqueItems;
const const_1 = _const;
const enum_1 = _enum;
const validation$1 = [
  // number
  limitNumber_1.default,
  multipleOf_1.default,
  // string
  limitLength_1.default,
  pattern_1.default,
  // object
  limitProperties_1.default,
  required_1.default,
  // array
  limitItems_1.default,
  uniqueItems_1.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  const_1.default,
  enum_1.default
];
validation$2.default = validation$1;
var applicator$1 = {};
var additionalItems = {};
Object.defineProperty(additionalItems, "__esModule", { value: true });
additionalItems.validateAdditionalItems = void 0;
const codegen_1$e = codegen;
const util_1$h = util;
const error$a = {
  message: ({ params: { len } }) => (0, codegen_1$e.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$e._)`{limit: ${len}}`
};
const def$p = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: error$a,
  code(cxt) {
    const { parentSchema, it: it2 } = cxt;
    const { items: items2 } = parentSchema;
    if (!Array.isArray(items2)) {
      (0, util_1$h.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    validateAdditionalItems(cxt, items2);
  }
};
function validateAdditionalItems(cxt, items2) {
  const { gen, schema: schema2, data, keyword: keyword2, it: it2 } = cxt;
  it2.items = true;
  const len = gen.const("len", (0, codegen_1$e._)`${data}.length`);
  if (schema2 === false) {
    cxt.setParams({ len: items2.length });
    cxt.pass((0, codegen_1$e._)`${len} <= ${items2.length}`);
  } else if (typeof schema2 == "object" && !(0, util_1$h.alwaysValidSchema)(it2, schema2)) {
    const valid = gen.var("valid", (0, codegen_1$e._)`${len} <= ${items2.length}`);
    gen.if((0, codegen_1$e.not)(valid), () => validateItems(valid));
    cxt.ok(valid);
  }
  function validateItems(valid) {
    gen.forRange("i", items2.length, len, (i) => {
      cxt.subschema({ keyword: keyword2, dataProp: i, dataPropType: util_1$h.Type.Num }, valid);
      if (!it2.allErrors)
        gen.if((0, codegen_1$e.not)(valid), () => gen.break());
    });
  }
}
additionalItems.validateAdditionalItems = validateAdditionalItems;
additionalItems.default = def$p;
var prefixItems = {};
var items = {};
Object.defineProperty(items, "__esModule", { value: true });
items.validateTuple = void 0;
const codegen_1$d = codegen;
const util_1$g = util;
const code_1$5 = code;
const def$o = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(cxt) {
    const { schema: schema2, it: it2 } = cxt;
    if (Array.isArray(schema2))
      return validateTuple(cxt, "additionalItems", schema2);
    it2.items = true;
    if ((0, util_1$g.alwaysValidSchema)(it2, schema2))
      return;
    cxt.ok((0, code_1$5.validateArray)(cxt));
  }
};
function validateTuple(cxt, extraItems, schArr = cxt.schema) {
  const { gen, parentSchema, data, keyword: keyword2, it: it2 } = cxt;
  checkStrictTuple(parentSchema);
  if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
    it2.items = util_1$g.mergeEvaluated.items(gen, schArr.length, it2.items);
  }
  const valid = gen.name("valid");
  const len = gen.const("len", (0, codegen_1$d._)`${data}.length`);
  schArr.forEach((sch, i) => {
    if ((0, util_1$g.alwaysValidSchema)(it2, sch))
      return;
    gen.if((0, codegen_1$d._)`${len} > ${i}`, () => cxt.subschema({
      keyword: keyword2,
      schemaProp: i,
      dataProp: i
    }, valid));
    cxt.ok(valid);
  });
  function checkStrictTuple(sch) {
    const { opts, errSchemaPath } = it2;
    const l = schArr.length;
    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
    if (opts.strictTuples && !fullTuple) {
      const msg = `"${keyword2}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
      (0, util_1$g.checkStrictMode)(it2, msg, opts.strictTuples);
    }
  }
}
items.validateTuple = validateTuple;
items.default = def$o;
Object.defineProperty(prefixItems, "__esModule", { value: true });
const items_1$1 = items;
const def$n = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
};
prefixItems.default = def$n;
var items2020 = {};
Object.defineProperty(items2020, "__esModule", { value: true });
const codegen_1$c = codegen;
const util_1$f = util;
const code_1$4 = code;
const additionalItems_1$1 = additionalItems;
const error$9 = {
  message: ({ params: { len } }) => (0, codegen_1$c.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$c._)`{limit: ${len}}`
};
const def$m = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: error$9,
  code(cxt) {
    const { schema: schema2, parentSchema, it: it2 } = cxt;
    const { prefixItems: prefixItems2 } = parentSchema;
    it2.items = true;
    if ((0, util_1$f.alwaysValidSchema)(it2, schema2))
      return;
    if (prefixItems2)
      (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
    else
      cxt.ok((0, code_1$4.validateArray)(cxt));
  }
};
items2020.default = def$m;
var contains = {};
Object.defineProperty(contains, "__esModule", { value: true });
const codegen_1$b = codegen;
const util_1$e = util;
const error$8 = {
  message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$b.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
  params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b._)`{minContains: ${min}}` : (0, codegen_1$b._)`{minContains: ${min}, maxContains: ${max}}`
};
const def$l = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: error$8,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it: it2 } = cxt;
    let min;
    let max;
    const { minContains, maxContains } = parentSchema;
    if (it2.opts.next) {
      min = minContains === void 0 ? 1 : minContains;
      max = maxContains;
    } else {
      min = 1;
    }
    const len = gen.const("len", (0, codegen_1$b._)`${data}.length`);
    cxt.setParams({ min, max });
    if (max === void 0 && min === 0) {
      (0, util_1$e.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
      return;
    }
    if (max !== void 0 && min > max) {
      (0, util_1$e.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
      cxt.fail();
      return;
    }
    if ((0, util_1$e.alwaysValidSchema)(it2, schema2)) {
      let cond = (0, codegen_1$b._)`${len} >= ${min}`;
      if (max !== void 0)
        cond = (0, codegen_1$b._)`${cond} && ${len} <= ${max}`;
      cxt.pass(cond);
      return;
    }
    it2.items = true;
    const valid = gen.name("valid");
    if (max === void 0 && min === 1) {
      validateItems(valid, () => gen.if(valid, () => gen.break()));
    } else if (min === 0) {
      gen.let(valid, true);
      if (max !== void 0)
        gen.if((0, codegen_1$b._)`${data}.length > 0`, validateItemsWithCount);
    } else {
      gen.let(valid, false);
      validateItemsWithCount();
    }
    cxt.result(valid, () => cxt.reset());
    function validateItemsWithCount() {
      const schValid = gen.name("_valid");
      const count = gen.let("count", 0);
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
    }
    function validateItems(_valid, block) {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword: "contains",
          dataProp: i,
          dataPropType: util_1$e.Type.Num,
          compositeRule: true
        }, _valid);
        block();
      });
    }
    function checkLimits(count) {
      gen.code((0, codegen_1$b._)`${count}++`);
      if (max === void 0) {
        gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
      } else {
        gen.if((0, codegen_1$b._)`${count} > ${max}`, () => gen.assign(valid, false).break());
        if (min === 1)
          gen.assign(valid, true);
        else
          gen.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen.assign(valid, true));
      }
    }
  }
};
contains.default = def$l;
var dependencies = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
  const codegen_12 = codegen;
  const util_12 = util;
  const code_12 = code;
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    // TODO change to reference
  };
  const def2 = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema: schema2 }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema2) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema2[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema2[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_12.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_12.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword: keyword2, it: it2 } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_12.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if(
        (0, code_12.propertyInData)(gen, data, prop, it2.opts.ownProperties),
        () => {
          const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
          cxt.mergeValidEvaluated(schCxt, valid);
        },
        () => gen.var(valid, true)
        // TODO var
      );
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def2;
})(dependencies);
var propertyNames = {};
Object.defineProperty(propertyNames, "__esModule", { value: true });
const codegen_1$a = codegen;
const util_1$d = util;
const error$7 = {
  message: "property name must be valid",
  params: ({ params }) => (0, codegen_1$a._)`{propertyName: ${params.propertyName}}`
};
const def$k = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: error$7,
  code(cxt) {
    const { gen, schema: schema2, data, it: it2 } = cxt;
    if ((0, util_1$d.alwaysValidSchema)(it2, schema2))
      return;
    const valid = gen.name("valid");
    gen.forIn("key", data, (key) => {
      cxt.setParams({ propertyName: key });
      cxt.subschema({
        keyword: "propertyNames",
        data: key,
        dataTypes: ["string"],
        propertyName: key,
        compositeRule: true
      }, valid);
      gen.if((0, codegen_1$a.not)(valid), () => {
        cxt.error(true);
        if (!it2.allErrors)
          gen.break();
      });
    });
    cxt.ok(valid);
  }
};
propertyNames.default = def$k;
var additionalProperties = {};
Object.defineProperty(additionalProperties, "__esModule", { value: true });
const code_1$3 = code;
const codegen_1$9 = codegen;
const names_1$3 = names$1;
const util_1$c = util;
const error$6 = {
  message: "must NOT have additional properties",
  params: ({ params }) => (0, codegen_1$9._)`{additionalProperty: ${params.additionalProperty}}`
};
const def$j = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: error$6,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, errsCount, it: it2 } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, opts } = it2;
    it2.props = true;
    if (opts.removeAdditional !== "all" && (0, util_1$c.alwaysValidSchema)(it2, schema2))
      return;
    const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
    const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
    checkAdditionalProperties();
    cxt.ok((0, codegen_1$9._)`${errsCount} === ${names_1$3.default.errors}`);
    function checkAdditionalProperties() {
      gen.forIn("key", data, (key) => {
        if (!props.length && !patProps.length)
          additionalPropertyCode(key);
        else
          gen.if(isAdditional(key), () => additionalPropertyCode(key));
      });
    }
    function isAdditional(key) {
      let definedProp;
      if (props.length > 8) {
        const propsSchema = (0, util_1$c.schemaRefOrVal)(it2, parentSchema.properties, "properties");
        definedProp = (0, code_1$3.isOwnProperty)(gen, propsSchema, key);
      } else if (props.length) {
        definedProp = (0, codegen_1$9.or)(...props.map((p2) => (0, codegen_1$9._)`${key} === ${p2}`));
      } else {
        definedProp = codegen_1$9.nil;
      }
      if (patProps.length) {
        definedProp = (0, codegen_1$9.or)(definedProp, ...patProps.map((p2) => (0, codegen_1$9._)`${(0, code_1$3.usePattern)(cxt, p2)}.test(${key})`));
      }
      return (0, codegen_1$9.not)(definedProp);
    }
    function deleteAdditional(key) {
      gen.code((0, codegen_1$9._)`delete ${data}[${key}]`);
    }
    function additionalPropertyCode(key) {
      if (opts.removeAdditional === "all" || opts.removeAdditional && schema2 === false) {
        deleteAdditional(key);
        return;
      }
      if (schema2 === false) {
        cxt.setParams({ additionalProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (typeof schema2 == "object" && !(0, util_1$c.alwaysValidSchema)(it2, schema2)) {
        const valid = gen.name("valid");
        if (opts.removeAdditional === "failing") {
          applyAdditionalSchema(key, valid, false);
          gen.if((0, codegen_1$9.not)(valid), () => {
            cxt.reset();
            deleteAdditional(key);
          });
        } else {
          applyAdditionalSchema(key, valid);
          if (!allErrors)
            gen.if((0, codegen_1$9.not)(valid), () => gen.break());
        }
      }
    }
    function applyAdditionalSchema(key, valid, errors2) {
      const subschema2 = {
        keyword: "additionalProperties",
        dataProp: key,
        dataPropType: util_1$c.Type.Str
      };
      if (errors2 === false) {
        Object.assign(subschema2, {
          compositeRule: true,
          createErrors: false,
          allErrors: false
        });
      }
      cxt.subschema(subschema2, valid);
    }
  }
};
additionalProperties.default = def$j;
var properties$8 = {};
Object.defineProperty(properties$8, "__esModule", { value: true });
const validate_1 = validate$1;
const code_1$2 = code;
const util_1$b = util;
const additionalProperties_1$1 = additionalProperties;
const def$i = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, parentSchema, data, it: it2 } = cxt;
    if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
      additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1$1.default, "additionalProperties"));
    }
    const allProps = (0, code_1$2.allSchemaProperties)(schema2);
    for (const prop of allProps) {
      it2.definedProperties.add(prop);
    }
    if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
      it2.props = util_1$b.mergeEvaluated.props(gen, (0, util_1$b.toHash)(allProps), it2.props);
    }
    const properties2 = allProps.filter((p2) => !(0, util_1$b.alwaysValidSchema)(it2, schema2[p2]));
    if (properties2.length === 0)
      return;
    const valid = gen.name("valid");
    for (const prop of properties2) {
      if (hasDefault(prop)) {
        applyPropertySchema(prop);
      } else {
        gen.if((0, code_1$2.propertyInData)(gen, data, prop, it2.opts.ownProperties));
        applyPropertySchema(prop);
        if (!it2.allErrors)
          gen.else().var(valid, true);
        gen.endIf();
      }
      cxt.it.definedProperties.add(prop);
      cxt.ok(valid);
    }
    function hasDefault(prop) {
      return it2.opts.useDefaults && !it2.compositeRule && schema2[prop].default !== void 0;
    }
    function applyPropertySchema(prop) {
      cxt.subschema({
        keyword: "properties",
        schemaProp: prop,
        dataProp: prop
      }, valid);
    }
  }
};
properties$8.default = def$i;
var patternProperties = {};
Object.defineProperty(patternProperties, "__esModule", { value: true });
const code_1$1 = code;
const codegen_1$8 = codegen;
const util_1$a = util;
const util_2 = util;
const def$h = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt) {
    const { gen, schema: schema2, data, parentSchema, it: it2 } = cxt;
    const { opts } = it2;
    const patterns = (0, code_1$1.allSchemaProperties)(schema2);
    const alwaysValidPatterns = patterns.filter((p2) => (0, util_1$a.alwaysValidSchema)(it2, schema2[p2]));
    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
      return;
    }
    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
    const valid = gen.name("valid");
    if (it2.props !== true && !(it2.props instanceof codegen_1$8.Name)) {
      it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
    }
    const { props } = it2;
    validatePatternProperties();
    function validatePatternProperties() {
      for (const pat of patterns) {
        if (checkProperties)
          checkMatchingProperties(pat);
        if (it2.allErrors) {
          validateProperties(pat);
        } else {
          gen.var(valid, true);
          validateProperties(pat);
          gen.if(valid);
        }
      }
    }
    function checkMatchingProperties(pat) {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          (0, util_1$a.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
      }
    }
    function validateProperties(pat) {
      gen.forIn("key", data, (key) => {
        gen.if((0, codegen_1$8._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat);
          if (!alwaysValid) {
            cxt.subschema({
              keyword: "patternProperties",
              schemaProp: pat,
              dataProp: key,
              dataPropType: util_2.Type.Str
            }, valid);
          }
          if (it2.opts.unevaluated && props !== true) {
            gen.assign((0, codegen_1$8._)`${props}[${key}]`, true);
          } else if (!alwaysValid && !it2.allErrors) {
            gen.if((0, codegen_1$8.not)(valid), () => gen.break());
          }
        });
      });
    }
  }
};
patternProperties.default = def$h;
var not = {};
Object.defineProperty(not, "__esModule", { value: true });
const util_1$9 = util;
const def$g = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(cxt) {
    const { gen, schema: schema2, it: it2 } = cxt;
    if ((0, util_1$9.alwaysValidSchema)(it2, schema2)) {
      cxt.fail();
      return;
    }
    const valid = gen.name("valid");
    cxt.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, valid);
    cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
  },
  error: { message: "must NOT be valid" }
};
not.default = def$g;
var anyOf = {};
Object.defineProperty(anyOf, "__esModule", { value: true });
const code_1 = code;
const def$f = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: code_1.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
anyOf.default = def$f;
var oneOf = {};
Object.defineProperty(oneOf, "__esModule", { value: true });
const codegen_1$7 = codegen;
const util_1$8 = util;
const error$5 = {
  message: "must match exactly one schema in oneOf",
  params: ({ params }) => (0, codegen_1$7._)`{passingSchemas: ${params.passing}}`
};
const def$e = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: error$5,
  code(cxt) {
    const { gen, schema: schema2, parentSchema, it: it2 } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    if (it2.opts.discriminator && parentSchema.discriminator)
      return;
    const schArr = schema2;
    const valid = gen.let("valid", false);
    const passing = gen.let("passing", null);
    const schValid = gen.name("_valid");
    cxt.setParams({ passing });
    gen.block(validateOneOf);
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    function validateOneOf() {
      schArr.forEach((sch, i) => {
        let schCxt;
        if ((0, util_1$8.alwaysValidSchema)(it2, sch)) {
          gen.var(schValid, true);
        } else {
          schCxt = cxt.subschema({
            keyword: "oneOf",
            schemaProp: i,
            compositeRule: true
          }, schValid);
        }
        if (i > 0) {
          gen.if((0, codegen_1$7._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$7._)`[${passing}, ${i}]`).else();
        }
        gen.if(schValid, () => {
          gen.assign(valid, true);
          gen.assign(passing, i);
          if (schCxt)
            cxt.mergeEvaluated(schCxt, codegen_1$7.Name);
        });
      });
    }
  }
};
oneOf.default = def$e;
var allOf$1 = {};
Object.defineProperty(allOf$1, "__esModule", { value: true });
const util_1$7 = util;
const def$d = {
  keyword: "allOf",
  schemaType: "array",
  code(cxt) {
    const { gen, schema: schema2, it: it2 } = cxt;
    if (!Array.isArray(schema2))
      throw new Error("ajv implementation error");
    const valid = gen.name("valid");
    schema2.forEach((sch, i) => {
      if ((0, util_1$7.alwaysValidSchema)(it2, sch))
        return;
      const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
      cxt.ok(valid);
      cxt.mergeEvaluated(schCxt);
    });
  }
};
allOf$1.default = def$d;
var _if = {};
Object.defineProperty(_if, "__esModule", { value: true });
const codegen_1$6 = codegen;
const util_1$6 = util;
const error$4 = {
  message: ({ params }) => (0, codegen_1$6.str)`must match "${params.ifClause}" schema`,
  params: ({ params }) => (0, codegen_1$6._)`{failingKeyword: ${params.ifClause}}`
};
const def$c = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: error$4,
  code(cxt) {
    const { gen, parentSchema, it: it2 } = cxt;
    if (parentSchema.then === void 0 && parentSchema.else === void 0) {
      (0, util_1$6.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
    }
    const hasThen = hasSchema(it2, "then");
    const hasElse = hasSchema(it2, "else");
    if (!hasThen && !hasElse)
      return;
    const valid = gen.let("valid", true);
    const schValid = gen.name("_valid");
    validateIf();
    cxt.reset();
    if (hasThen && hasElse) {
      const ifClause = gen.let("ifClause");
      cxt.setParams({ ifClause });
      gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
    } else if (hasThen) {
      gen.if(schValid, validateClause("then"));
    } else {
      gen.if((0, codegen_1$6.not)(schValid), validateClause("else"));
    }
    cxt.pass(valid, () => cxt.error(true));
    function validateIf() {
      const schCxt = cxt.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, schValid);
      cxt.mergeEvaluated(schCxt);
    }
    function validateClause(keyword2, ifClause) {
      return () => {
        const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
        gen.assign(valid, schValid);
        cxt.mergeValidEvaluated(schCxt, valid);
        if (ifClause)
          gen.assign(ifClause, (0, codegen_1$6._)`${keyword2}`);
        else
          cxt.setParams({ ifClause: keyword2 });
      };
    }
  }
};
function hasSchema(it2, keyword2) {
  const schema2 = it2.schema[keyword2];
  return schema2 !== void 0 && !(0, util_1$6.alwaysValidSchema)(it2, schema2);
}
_if.default = def$c;
var thenElse = {};
Object.defineProperty(thenElse, "__esModule", { value: true });
const util_1$5 = util;
const def$b = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: keyword2, parentSchema, it: it2 }) {
    if (parentSchema.if === void 0)
      (0, util_1$5.checkStrictMode)(it2, `"${keyword2}" without "if" is ignored`);
  }
};
thenElse.default = def$b;
Object.defineProperty(applicator$1, "__esModule", { value: true });
const additionalItems_1 = additionalItems;
const prefixItems_1 = prefixItems;
const items_1 = items;
const items2020_1 = items2020;
const contains_1 = contains;
const dependencies_1$2 = dependencies;
const propertyNames_1 = propertyNames;
const additionalProperties_1 = additionalProperties;
const properties_1 = properties$8;
const patternProperties_1 = patternProperties;
const not_1 = not;
const anyOf_1 = anyOf;
const oneOf_1 = oneOf;
const allOf_1 = allOf$1;
const if_1 = _if;
const thenElse_1 = thenElse;
function getApplicator(draft2020 = false) {
  const applicator2 = [
    // any
    not_1.default,
    anyOf_1.default,
    oneOf_1.default,
    allOf_1.default,
    if_1.default,
    thenElse_1.default,
    // object
    propertyNames_1.default,
    additionalProperties_1.default,
    dependencies_1$2.default,
    properties_1.default,
    patternProperties_1.default
  ];
  if (draft2020)
    applicator2.push(prefixItems_1.default, items2020_1.default);
  else
    applicator2.push(additionalItems_1.default, items_1.default);
  applicator2.push(contains_1.default);
  return applicator2;
}
applicator$1.default = getApplicator;
var format$3 = {};
var format$2 = {};
Object.defineProperty(format$2, "__esModule", { value: true });
const codegen_1$5 = codegen;
const error$3 = {
  message: ({ schemaCode }) => (0, codegen_1$5.str)`must match format "${schemaCode}"`,
  params: ({ schemaCode }) => (0, codegen_1$5._)`{format: ${schemaCode}}`
};
const def$a = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: error$3,
  code(cxt, ruleType) {
    const { gen, data, $data, schema: schema2, schemaCode, it: it2 } = cxt;
    const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
    if (!opts.validateFormats)
      return;
    if ($data)
      validate$DataFormat();
    else
      validateFormat();
    function validate$DataFormat() {
      const fmts = gen.scopeValue("formats", {
        ref: self2.formats,
        code: opts.code.formats
      });
      const fDef = gen.const("fDef", (0, codegen_1$5._)`${fmts}[${schemaCode}]`);
      const fType = gen.let("fType");
      const format2 = gen.let("format");
      gen.if((0, codegen_1$5._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1$5._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$5._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1$5._)`"string"`).assign(format2, fDef));
      cxt.fail$data((0, codegen_1$5.or)(unknownFmt(), invalidFmt()));
      function unknownFmt() {
        if (opts.strictSchema === false)
          return codegen_1$5.nil;
        return (0, codegen_1$5._)`${schemaCode} && !${format2}`;
      }
      function invalidFmt() {
        const callFormat = schemaEnv.$async ? (0, codegen_1$5._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$5._)`${format2}(${data})`;
        const validData = (0, codegen_1$5._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
        return (0, codegen_1$5._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
      }
    }
    function validateFormat() {
      const formatDef = self2.formats[schema2];
      if (!formatDef) {
        unknownFormat();
        return;
      }
      if (formatDef === true)
        return;
      const [fmtType, format2, fmtRef] = getFormat(formatDef);
      if (fmtType === ruleType)
        cxt.pass(validCondition());
      function unknownFormat() {
        if (opts.strictSchema === false) {
          self2.logger.warn(unknownMsg());
          return;
        }
        throw new Error(unknownMsg());
        function unknownMsg() {
          return `unknown format "${schema2}" ignored in schema at path "${errSchemaPath}"`;
        }
      }
      function getFormat(fmtDef) {
        const code2 = fmtDef instanceof RegExp ? (0, codegen_1$5.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$5._)`${opts.code.formats}${(0, codegen_1$5.getProperty)(schema2)}` : void 0;
        const fmt = gen.scopeValue("formats", { key: schema2, ref: fmtDef, code: code2 });
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$5._)`${fmt}.validate`];
        }
        return ["string", fmtDef, fmt];
      }
      function validCondition() {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async)
            throw new Error("async format in sync schema");
          return (0, codegen_1$5._)`await ${fmtRef}(${data})`;
        }
        return typeof format2 == "function" ? (0, codegen_1$5._)`${fmtRef}(${data})` : (0, codegen_1$5._)`${fmtRef}.test(${data})`;
      }
    }
  }
};
format$2.default = def$a;
Object.defineProperty(format$3, "__esModule", { value: true });
const format_1$1 = format$2;
const format$1 = [format_1$1.default];
format$3.default = format$1;
var metadata$1 = {};
Object.defineProperty(metadata$1, "__esModule", { value: true });
metadata$1.contentVocabulary = metadata$1.metadataVocabulary = void 0;
metadata$1.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
metadata$1.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(draft7, "__esModule", { value: true });
const core_1 = core$2;
const validation_1 = validation$2;
const applicator_1 = applicator$1;
const format_1 = format$3;
const metadata_1 = metadata$1;
const draft7Vocabularies = [
  core_1.default,
  validation_1.default,
  (0, applicator_1.default)(),
  format_1.default,
  metadata_1.metadataVocabulary,
  metadata_1.contentVocabulary
];
draft7.default = draft7Vocabularies;
var dynamic$1 = {};
var dynamicAnchor$1 = {};
Object.defineProperty(dynamicAnchor$1, "__esModule", { value: true });
dynamicAnchor$1.dynamicAnchor = void 0;
const codegen_1$4 = codegen;
const names_1$2 = names$1;
const compile_1$1 = compile;
const ref_1$1 = ref;
const def$9 = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (cxt) => dynamicAnchor(cxt, cxt.schema)
};
function dynamicAnchor(cxt, anchor) {
  const { gen, it: it2 } = cxt;
  it2.schemaEnv.root.dynamicAnchors[anchor] = true;
  const v2 = (0, codegen_1$4._)`${names_1$2.default.dynamicAnchors}${(0, codegen_1$4.getProperty)(anchor)}`;
  const validate2 = it2.errSchemaPath === "#" ? it2.validateName : _getValidate(cxt);
  gen.if((0, codegen_1$4._)`!${v2}`, () => gen.assign(v2, validate2));
}
dynamicAnchor$1.dynamicAnchor = dynamicAnchor;
function _getValidate(cxt) {
  const { schemaEnv, schema: schema2, self: self2 } = cxt.it;
  const { root: root2, baseId, localRefs, meta } = schemaEnv.root;
  const { schemaId } = self2.opts;
  const sch = new compile_1$1.SchemaEnv({ schema: schema2, schemaId, root: root2, baseId, localRefs, meta });
  compile_1$1.compileSchema.call(self2, sch);
  return (0, ref_1$1.getValidate)(cxt, sch);
}
dynamicAnchor$1.default = def$9;
var dynamicRef$1 = {};
Object.defineProperty(dynamicRef$1, "__esModule", { value: true });
dynamicRef$1.dynamicRef = void 0;
const codegen_1$3 = codegen;
const names_1$1 = names$1;
const ref_1 = ref;
const def$8 = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (cxt) => dynamicRef(cxt, cxt.schema)
};
function dynamicRef(cxt, ref2) {
  const { gen, keyword: keyword2, it: it2 } = cxt;
  if (ref2[0] !== "#")
    throw new Error(`"${keyword2}" only supports hash fragment reference`);
  const anchor = ref2.slice(1);
  if (it2.allErrors) {
    _dynamicRef();
  } else {
    const valid = gen.let("valid", false);
    _dynamicRef(valid);
    cxt.ok(valid);
  }
  function _dynamicRef(valid) {
    if (it2.schemaEnv.root.dynamicAnchors[anchor]) {
      const v2 = gen.let("_v", (0, codegen_1$3._)`${names_1$1.default.dynamicAnchors}${(0, codegen_1$3.getProperty)(anchor)}`);
      gen.if(v2, _callRef(v2, valid), _callRef(it2.validateName, valid));
    } else {
      _callRef(it2.validateName, valid)();
    }
  }
  function _callRef(validate2, valid) {
    return valid ? () => gen.block(() => {
      (0, ref_1.callRef)(cxt, validate2);
      gen.let(valid, true);
    }) : () => (0, ref_1.callRef)(cxt, validate2);
  }
}
dynamicRef$1.dynamicRef = dynamicRef;
dynamicRef$1.default = def$8;
var recursiveAnchor = {};
Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
const dynamicAnchor_1$1 = dynamicAnchor$1;
const util_1$4 = util;
const def$7 = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(cxt) {
    if (cxt.schema)
      (0, dynamicAnchor_1$1.dynamicAnchor)(cxt, "");
    else
      (0, util_1$4.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
  }
};
recursiveAnchor.default = def$7;
var recursiveRef = {};
Object.defineProperty(recursiveRef, "__esModule", { value: true });
const dynamicRef_1$1 = dynamicRef$1;
const def$6 = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (cxt) => (0, dynamicRef_1$1.dynamicRef)(cxt, cxt.schema)
};
recursiveRef.default = def$6;
Object.defineProperty(dynamic$1, "__esModule", { value: true });
const dynamicAnchor_1 = dynamicAnchor$1;
const dynamicRef_1 = dynamicRef$1;
const recursiveAnchor_1 = recursiveAnchor;
const recursiveRef_1 = recursiveRef;
const dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
dynamic$1.default = dynamic;
var next$1 = {};
var dependentRequired = {};
Object.defineProperty(dependentRequired, "__esModule", { value: true });
const dependencies_1$1 = dependencies;
const def$5 = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: dependencies_1$1.error,
  code: (cxt) => (0, dependencies_1$1.validatePropertyDeps)(cxt)
};
dependentRequired.default = def$5;
var dependentSchemas = {};
Object.defineProperty(dependentSchemas, "__esModule", { value: true });
const dependencies_1 = dependencies;
const def$4 = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
};
dependentSchemas.default = def$4;
var limitContains = {};
Object.defineProperty(limitContains, "__esModule", { value: true });
const util_1$3 = util;
const def$3 = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: keyword2, parentSchema, it: it2 }) {
    if (parentSchema.contains === void 0) {
      (0, util_1$3.checkStrictMode)(it2, `"${keyword2}" without "contains" is ignored`);
    }
  }
};
limitContains.default = def$3;
Object.defineProperty(next$1, "__esModule", { value: true });
const dependentRequired_1 = dependentRequired;
const dependentSchemas_1 = dependentSchemas;
const limitContains_1 = limitContains;
const next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
next$1.default = next;
var unevaluated$1 = {};
var unevaluatedProperties = {};
Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
const codegen_1$2 = codegen;
const util_1$2 = util;
const names_1 = names$1;
const error$2 = {
  message: "must NOT have unevaluated properties",
  params: ({ params }) => (0, codegen_1$2._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
};
const def$2 = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: true,
  error: error$2,
  code(cxt) {
    const { gen, schema: schema2, data, errsCount, it: it2 } = cxt;
    if (!errsCount)
      throw new Error("ajv implementation error");
    const { allErrors, props } = it2;
    if (props instanceof codegen_1$2.Name) {
      gen.if((0, codegen_1$2._)`${props} !== true`, () => gen.forIn("key", data, (key) => gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
    } else if (props !== true) {
      gen.forIn("key", data, (key) => props === void 0 ? unevaluatedPropCode(key) : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
    }
    it2.props = true;
    cxt.ok((0, codegen_1$2._)`${errsCount} === ${names_1.default.errors}`);
    function unevaluatedPropCode(key) {
      if (schema2 === false) {
        cxt.setParams({ unevaluatedProperty: key });
        cxt.error();
        if (!allErrors)
          gen.break();
        return;
      }
      if (!(0, util_1$2.alwaysValidSchema)(it2, schema2)) {
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "unevaluatedProperties",
          dataProp: key,
          dataPropType: util_1$2.Type.Str
        }, valid);
        if (!allErrors)
          gen.if((0, codegen_1$2.not)(valid), () => gen.break());
      }
    }
    function unevaluatedDynamic(evaluatedProps, key) {
      return (0, codegen_1$2._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
    }
    function unevaluatedStatic(evaluatedProps, key) {
      const ps2 = [];
      for (const p2 in evaluatedProps) {
        if (evaluatedProps[p2] === true)
          ps2.push((0, codegen_1$2._)`${key} !== ${p2}`);
      }
      return (0, codegen_1$2.and)(...ps2);
    }
  }
};
unevaluatedProperties.default = def$2;
var unevaluatedItems = {};
Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
const codegen_1$1 = codegen;
const util_1$1 = util;
const error$1 = {
  message: ({ params: { len } }) => (0, codegen_1$1.str)`must NOT have more than ${len} items`,
  params: ({ params: { len } }) => (0, codegen_1$1._)`{limit: ${len}}`
};
const def$1 = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: error$1,
  code(cxt) {
    const { gen, schema: schema2, data, it: it2 } = cxt;
    const items2 = it2.items || 0;
    if (items2 === true)
      return;
    const len = gen.const("len", (0, codegen_1$1._)`${data}.length`);
    if (schema2 === false) {
      cxt.setParams({ len: items2 });
      cxt.fail((0, codegen_1$1._)`${len} > ${items2}`);
    } else if (typeof schema2 == "object" && !(0, util_1$1.alwaysValidSchema)(it2, schema2)) {
      const valid = gen.var("valid", (0, codegen_1$1._)`${len} <= ${items2}`);
      gen.if((0, codegen_1$1.not)(valid), () => validateItems(valid, items2));
      cxt.ok(valid);
    }
    it2.items = true;
    function validateItems(valid, from) {
      gen.forRange("i", from, len, (i) => {
        cxt.subschema({ keyword: "unevaluatedItems", dataProp: i, dataPropType: util_1$1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1$1.not)(valid), () => gen.break());
      });
    }
  }
};
unevaluatedItems.default = def$1;
Object.defineProperty(unevaluated$1, "__esModule", { value: true });
const unevaluatedProperties_1 = unevaluatedProperties;
const unevaluatedItems_1 = unevaluatedItems;
const unevaluated = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
unevaluated$1.default = unevaluated;
var discriminator = {};
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
types.DiscrError = void 0;
var DiscrError;
(function(DiscrError2) {
  DiscrError2["Tag"] = "tag";
  DiscrError2["Mapping"] = "mapping";
})(DiscrError || (types.DiscrError = DiscrError = {}));
Object.defineProperty(discriminator, "__esModule", { value: true });
const codegen_1 = codegen;
const types_1 = types;
const compile_1 = compile;
const ref_error_1 = ref_error;
const util_1 = util;
const error = {
  message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
  params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
};
const def = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt) {
    const { gen, data, schema: schema2, parentSchema, it: it2 } = cxt;
    const { oneOf: oneOf2 } = parentSchema;
    if (!it2.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option");
    }
    const tagName = schema2.propertyName;
    if (typeof tagName != "string")
      throw new Error("discriminator: requires propertyName");
    if (schema2.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!oneOf2)
      throw new Error("discriminator: requires oneOf keyword");
    const valid = gen.let("valid", false);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
    gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
    cxt.ok(valid);
    function validateMapping() {
      const mapping = getMapping();
      gen.if(false);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        gen.assign(valid, applyTagSchema(mapping[tagValue]));
      }
      gen.else();
      cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
      gen.endIf();
    }
    function applyTagSchema(schemaProp) {
      const _valid = gen.name("valid");
      const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
      cxt.mergeEvaluated(schCxt, codegen_1.Name);
      return _valid;
    }
    function getMapping() {
      var _a;
      const oneOfMapping = {};
      const topRequired = hasRequired(parentSchema);
      let tagRequired = true;
      for (let i = 0; i < oneOf2.length; i++) {
        let sch = oneOf2[i];
        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
          const ref2 = sch.$ref;
          sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref2);
          if (sch instanceof compile_1.SchemaEnv)
            sch = sch.schema;
          if (sch === void 0)
            throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref2);
        }
        const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
        if (typeof propSch != "object") {
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
        }
        tagRequired = tagRequired && (topRequired || hasRequired(sch));
        addMappings(propSch, i);
      }
      if (!tagRequired)
        throw new Error(`discriminator: "${tagName}" must be required`);
      return oneOfMapping;
      function hasRequired({ required: required2 }) {
        return Array.isArray(required2) && required2.includes(tagName);
      }
      function addMappings(sch, i) {
        if (sch.const) {
          addMapping(sch.const, i);
        } else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i);
          }
        } else {
          throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
        }
      }
      function addMapping(tagValue, i) {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName}" values must be unique strings`);
        }
        oneOfMapping[tagValue] = i;
      }
    }
  }
};
discriminator.default = def;
var jsonSchema201909 = {};
const $schema$6 = "https://json-schema.org/draft/2019-09/schema";
const $id$6 = "https://json-schema.org/draft/2019-09/schema";
const $vocabulary$6 = {
  "https://json-schema.org/draft/2019-09/vocab/core": true,
  "https://json-schema.org/draft/2019-09/vocab/applicator": true,
  "https://json-schema.org/draft/2019-09/vocab/validation": true,
  "https://json-schema.org/draft/2019-09/vocab/meta-data": true,
  "https://json-schema.org/draft/2019-09/vocab/format": false,
  "https://json-schema.org/draft/2019-09/vocab/content": true
};
const $recursiveAnchor$6 = true;
const title$6 = "Core and Validation specifications meta-schema";
const allOf = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format"
  },
  {
    $ref: "meta/content"
  }
];
const type$6 = [
  "object",
  "boolean"
];
const properties$7 = {
  definitions: {
    $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
    type: "object",
    additionalProperties: {
      $recursiveRef: "#"
    },
    "default": {}
  },
  dependencies: {
    $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $recursiveRef: "#"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    }
  }
};
const require$$0 = {
  $schema: $schema$6,
  $id: $id$6,
  $vocabulary: $vocabulary$6,
  $recursiveAnchor: $recursiveAnchor$6,
  title: title$6,
  allOf,
  type: type$6,
  properties: properties$7
};
const $schema$5 = "https://json-schema.org/draft/2019-09/schema";
const $id$5 = "https://json-schema.org/draft/2019-09/meta/applicator";
const $vocabulary$5 = {
  "https://json-schema.org/draft/2019-09/vocab/applicator": true
};
const $recursiveAnchor$5 = true;
const title$5 = "Applicator vocabulary meta-schema";
const type$5 = [
  "object",
  "boolean"
];
const properties$6 = {
  additionalItems: {
    $recursiveRef: "#"
  },
  unevaluatedItems: {
    $recursiveRef: "#"
  },
  items: {
    anyOf: [
      {
        $recursiveRef: "#"
      },
      {
        $ref: "#/$defs/schemaArray"
      }
    ]
  },
  contains: {
    $recursiveRef: "#"
  },
  additionalProperties: {
    $recursiveRef: "#"
  },
  unevaluatedProperties: {
    $recursiveRef: "#"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $recursiveRef: "#"
    },
    "default": {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $recursiveRef: "#"
    },
    propertyNames: {
      format: "regex"
    },
    "default": {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $recursiveRef: "#"
    }
  },
  propertyNames: {
    $recursiveRef: "#"
  },
  "if": {
    $recursiveRef: "#"
  },
  then: {
    $recursiveRef: "#"
  },
  "else": {
    $recursiveRef: "#"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $recursiveRef: "#"
  }
};
const $defs$1 = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $recursiveRef: "#"
    }
  }
};
const require$$1 = {
  $schema: $schema$5,
  $id: $id$5,
  $vocabulary: $vocabulary$5,
  $recursiveAnchor: $recursiveAnchor$5,
  title: title$5,
  type: type$5,
  properties: properties$6,
  $defs: $defs$1
};
const $schema$4 = "https://json-schema.org/draft/2019-09/schema";
const $id$4 = "https://json-schema.org/draft/2019-09/meta/content";
const $vocabulary$4 = {
  "https://json-schema.org/draft/2019-09/vocab/content": true
};
const $recursiveAnchor$4 = true;
const title$4 = "Content vocabulary meta-schema";
const type$4 = [
  "object",
  "boolean"
];
const properties$5 = {
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  contentSchema: {
    $recursiveRef: "#"
  }
};
const require$$2 = {
  $schema: $schema$4,
  $id: $id$4,
  $vocabulary: $vocabulary$4,
  $recursiveAnchor: $recursiveAnchor$4,
  title: title$4,
  type: type$4,
  properties: properties$5
};
const $schema$3 = "https://json-schema.org/draft/2019-09/schema";
const $id$3 = "https://json-schema.org/draft/2019-09/meta/core";
const $vocabulary$3 = {
  "https://json-schema.org/draft/2019-09/vocab/core": true
};
const $recursiveAnchor$3 = true;
const title$3 = "Core vocabulary meta-schema";
const type$3 = [
  "object",
  "boolean"
];
const properties$4 = {
  $id: {
    type: "string",
    format: "uri-reference",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $anchor: {
    type: "string",
    pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $recursiveRef: {
    type: "string",
    format: "uri-reference"
  },
  $recursiveAnchor: {
    type: "boolean",
    "default": false
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      type: "string",
      format: "uri"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $recursiveRef: "#"
    },
    "default": {}
  }
};
const require$$3 = {
  $schema: $schema$3,
  $id: $id$3,
  $vocabulary: $vocabulary$3,
  $recursiveAnchor: $recursiveAnchor$3,
  title: title$3,
  type: type$3,
  properties: properties$4
};
const $schema$2 = "https://json-schema.org/draft/2019-09/schema";
const $id$2 = "https://json-schema.org/draft/2019-09/meta/format";
const $vocabulary$2 = {
  "https://json-schema.org/draft/2019-09/vocab/format": true
};
const $recursiveAnchor$2 = true;
const title$2 = "Format vocabulary meta-schema";
const type$2 = [
  "object",
  "boolean"
];
const properties$3 = {
  format: {
    type: "string"
  }
};
const require$$4 = {
  $schema: $schema$2,
  $id: $id$2,
  $vocabulary: $vocabulary$2,
  $recursiveAnchor: $recursiveAnchor$2,
  title: title$2,
  type: type$2,
  properties: properties$3
};
const $schema$1 = "https://json-schema.org/draft/2019-09/schema";
const $id$1 = "https://json-schema.org/draft/2019-09/meta/meta-data";
const $vocabulary$1 = {
  "https://json-schema.org/draft/2019-09/vocab/meta-data": true
};
const $recursiveAnchor$1 = true;
const title$1 = "Meta-data vocabulary meta-schema";
const type$1 = [
  "object",
  "boolean"
];
const properties$2 = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  "default": true,
  deprecated: {
    type: "boolean",
    "default": false
  },
  readOnly: {
    type: "boolean",
    "default": false
  },
  writeOnly: {
    type: "boolean",
    "default": false
  },
  examples: {
    type: "array",
    items: true
  }
};
const require$$5 = {
  $schema: $schema$1,
  $id: $id$1,
  $vocabulary: $vocabulary$1,
  $recursiveAnchor: $recursiveAnchor$1,
  title: title$1,
  type: type$1,
  properties: properties$2
};
const $schema = "https://json-schema.org/draft/2019-09/schema";
const $id = "https://json-schema.org/draft/2019-09/meta/validation";
const $vocabulary = {
  "https://json-schema.org/draft/2019-09/vocab/validation": true
};
const $recursiveAnchor = true;
const title = "Validation vocabulary meta-schema";
const type = [
  "object",
  "boolean"
];
const properties$1 = {
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    "default": false
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    "default": 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  },
  "const": true,
  "enum": {
    type: "array",
    items: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  }
};
const $defs = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    "default": 0
  },
  simpleTypes: {
    "enum": [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    "default": []
  }
};
const require$$6 = {
  $schema,
  $id,
  $vocabulary,
  $recursiveAnchor,
  title,
  type,
  properties: properties$1,
  $defs
};
Object.defineProperty(jsonSchema201909, "__esModule", { value: true });
const metaSchema = require$$0;
const applicator = require$$1;
const content = require$$2;
const core = require$$3;
const format = require$$4;
const metadata = require$$5;
const validation = require$$6;
const META_SUPPORT_DATA = ["/properties"];
function addMetaSchema2019($data) {
  [
    metaSchema,
    applicator,
    content,
    core,
    with$data(this, format),
    metadata,
    with$data(this, validation)
  ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
  return this;
  function with$data(ajv2, sch) {
    return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
  }
}
jsonSchema201909.default = addMetaSchema2019;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv2019 = void 0;
  const core_12 = core$3;
  const draft7_1 = draft7;
  const dynamic_1 = dynamic$1;
  const next_1 = next$1;
  const unevaluated_1 = unevaluated$1;
  const discriminator_1 = discriminator;
  const json_schema_2019_09_1 = jsonSchema201909;
  const META_SCHEMA_ID = "https://json-schema.org/draft/2019-09/schema";
  class Ajv2019 extends core_12.default {
    constructor(opts = {}) {
      super({
        ...opts,
        dynamicRef: true,
        next: true,
        unevaluated: true
      });
    }
    _addVocabularies() {
      super._addVocabularies();
      this.addVocabulary(dynamic_1.default);
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      this.addVocabulary(next_1.default);
      this.addVocabulary(unevaluated_1.default);
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data, meta } = this.opts;
      if (!meta)
        return;
      json_schema_2019_09_1.default.call(this, $data);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
    }
  }
  exports.Ajv2019 = Ajv2019;
  module.exports = exports = Ajv2019;
  module.exports.Ajv2019 = Ajv2019;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv2019;
  var validate_12 = validate$1;
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_12.KeywordCxt;
  } });
  var codegen_12 = codegen;
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_12._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_12.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_12.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_12.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_12.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_12.CodeGen;
  } });
  var validation_error_12 = validation_error;
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_12.default;
  } });
  var ref_error_12 = ref_error;
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_12.default;
  } });
})(_2019, _2019.exports);
var _2019Exports = _2019.exports;
const AJV = /* @__PURE__ */ getDefaultExportFromCjs(_2019Exports);
const planItemsSchema = {
  type: "array",
  items: {
    type: "object",
    properties: {
      planId: { type: "string" },
      quantity: { type: "number" },
      thumbnail: optional({ type: "string" })
    },
    required: ["planId", "quantity"]
  },
  default: []
};
const itemsSchema = {
  type: "array",
  items: {
    type: "object",
    oneOf: [
      {
        properties: {
          planId: { type: "string" },
          thumbnail: { type: "string" },
          quantity: { type: "number" }
        }
      },
      {
        properties: {
          planId: { type: "string" },
          thumbnail: { type: "string" },
          quantity: {
            type: "object",
            properties: {
              default: { type: "number" },
              minimum: { type: "number" },
              maximum: { type: "number" },
              multipleOf: { type: "number" }
            }
          }
        }
      }
    ],
    required: ["planId", "quantity"]
  },
  minItems: 1
};
const moneySchema = {
  type: "object",
  properties: {
    amount: {
      type: "number"
    },
    currency: {
      type: "string",
      minLength: 3,
      maxLength: 3
    }
  },
  required: ["amount", "currency"]
};
const payoutSchema = {
  type: "object",
  properties: {
    payoutRequestId: {
      type: "string"
    }
  },
  required: ["payoutRequestId"]
};
const i18nSchema = {
  type: "object",
  patternProperties: {
    "^[a-z]{2}(-[A-Z]{2})?$": {
      type: "object",
      properties: {
        // TODO: Add schema for all translation keys
        summary: optional({ type: "object" }),
        form: optional({ type: "object" }),
        confirmation: optional({ type: "object" }),
        result: optional({ type: "object" }),
        validations: optional({ type: "object" }),
        paymentMethods: optional({ type: "object" })
      },
      required: []
    }
  },
  required: []
};
const themeSchema = {
  type: "object",
  properties: {
    colorPrimary: optional({
      type: "string",
      default: "#0044d4"
    }),
    colorBackground: optional({
      type: "string",
      default: "#FFFFFF"
    }),
    colorText: optional({
      type: "string",
      default: "#0D2B3E"
    }),
    colorDanger: optional({
      type: "string",
      default: "#CD5C5C"
    }),
    borderRadius: optional({
      type: "string",
      default: "4px"
    }),
    labels: optional({
      type: "string",
      enum: ["stacked", "floating"],
      default: "stacked"
    }),
    // Font properties
    fontFamily: optional({
      type: "string",
      default: "-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial sans-serif"
    }),
    fontSizeBase: optional({
      type: "string",
      default: "16px"
    }),
    fontWeightBase: optional({
      type: "string",
      default: "400"
    }),
    fontLineHeightBase: optional({
      type: "string",
      default: "24px"
    }),
    fontSmooth: optional({
      type: "string",
      enum: ["auto", "never", "always"],
      default: "auto"
    }),
    // Heading properties
    headingFontFamily: optional({
      type: "string"
    }),
    headingFontWeight: optional({
      type: "string",
      default: "500"
    }),
    headingColorText: optional({
      type: "string"
    }),
    // Button properties
    buttonColorBackground: optional({
      type: "string"
    }),
    buttonColorText: optional({
      type: "string",
      default: "#FFFFFF"
    }),
    buttonFontFamily: optional({
      type: "string"
    }),
    buttonFontSize: optional({
      type: "string"
    }),
    buttonFontLineHeight: optional({
      type: "string"
    }),
    buttonFontWeight: optional({
      type: "string"
    }),
    buttonBorder: optional({
      type: "string",
      default: "1px solid transparent"
    }),
    buttonBorderColor: optional({
      type: "string"
    }),
    buttonBorderWidth: optional({
      type: "string"
    }),
    buttonBorderType: optional({
      type: "string"
    }),
    buttonBorderRadius: optional({
      type: "string"
    }),
    buttonBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    buttonSecondaryColorText: optional({
      type: "string"
    }),
    buttonSecondaryFontFamily: optional({
      type: "string"
    }),
    buttonSecondaryFontSize: optional({
      type: "string"
    }),
    buttonSecondaryFontLineHeight: optional({
      type: "string"
    }),
    buttonSecondaryFontWeight: optional({
      type: "string"
    }),
    buttonSecondaryBorder: optional({
      type: "string"
    }),
    buttonSecondaryBorderColor: optional({
      type: "string"
    }),
    buttonSecondaryBorderWidth: optional({
      type: "string"
    }),
    buttonSecondaryBorderType: optional({
      type: "string"
    }),
    buttonSecondaryBorderRadius: optional({
      type: "string"
    }),
    buttonSecondaryBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    // Button hover state properties
    buttonHoverColorBackground: optional({
      type: "string"
    }),
    buttonHoverColorText: optional({
      type: "string"
    }),
    buttonHoverFontFamily: optional({
      type: "string"
    }),
    buttonHoverFontSize: optional({
      type: "string"
    }),
    buttonHoverFontLineHeight: optional({
      type: "string"
    }),
    buttonHoverFontWeight: optional({
      type: "string"
    }),
    buttonHoverBorder: optional({
      type: "string"
    }),
    buttonHoverBorderColor: optional({
      type: "string"
    }),
    buttonHoverBorderWidth: optional({
      type: "string"
    }),
    buttonHoverBorderType: optional({
      type: "string"
    }),
    buttonHoverBorderRadius: optional({
      type: "string"
    }),
    buttonHoverBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    buttonSecondaryHoverColorBackground: optional({
      type: "string"
    }),
    buttonSecondaryHoverColorText: optional({
      type: "string"
    }),
    buttonSecondaryHoverFontFamily: optional({
      type: "string"
    }),
    buttonSecondaryHoverFontSize: optional({
      type: "string"
    }),
    buttonSecondaryHoverFontLineHeight: optional({
      type: "string"
    }),
    buttonSecondaryHoverFontWeight: optional({
      type: "string"
    }),
    buttonSecondaryHoverBorder: optional({
      type: "string"
    }),
    buttonSecondaryHoverBorderColor: optional({
      type: "string"
    }),
    buttonSecondaryHoverBorderWidth: optional({
      type: "string"
    }),
    buttonSecondaryHoverBorderType: optional({
      type: "string"
    }),
    buttonSecondaryHoverBorderRadius: optional({
      type: "string"
    }),
    buttonSecondaryHoverBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    // Button active state properties
    buttonActiveColorBackground: optional({
      type: "string"
    }),
    buttonActiveColorText: optional({
      type: "string"
    }),
    buttonActiveFontFamily: optional({
      type: "string"
    }),
    buttonActiveFontSize: optional({
      type: "string"
    }),
    buttonActiveFontLineHeight: optional({
      type: "string"
    }),
    buttonActiveFontWeight: optional({
      type: "string"
    }),
    buttonActiveBorder: optional({
      type: "string"
    }),
    buttonActiveBorderColor: optional({
      type: "string"
    }),
    buttonActiveBorderWidth: optional({
      type: "string"
    }),
    buttonActiveBorderType: optional({
      type: "string"
    }),
    buttonActiveBorderRadius: optional({
      type: "string"
    }),
    buttonActiveBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    buttonSecondaryActiveColorBackground: optional({
      type: "string"
    }),
    buttonSecondaryActiveColorText: optional({
      type: "string"
    }),
    buttonSecondaryActiveFontFamily: optional({
      type: "string"
    }),
    buttonSecondaryActiveFontSize: optional({
      type: "string"
    }),
    buttonSecondaryActiveFontLineHeight: optional({
      type: "string"
    }),
    buttonSecondaryActiveFontWeight: optional({
      type: "string"
    }),
    buttonSecondaryActiveBorder: optional({
      type: "string"
    }),
    buttonSecondaryActiveBorderColor: optional({
      type: "string"
    }),
    buttonSecondaryActiveBorderWidth: optional({
      type: "string"
    }),
    buttonSecondaryActiveBorderType: optional({
      type: "string"
    }),
    buttonSecondaryActiveBorderRadius: optional({
      type: "string"
    }),
    buttonSecondaryActiveBoxShadow: optional({
      type: "string",
      default: "none"
    }),
    // Input properties
    inputColorBackground: optional({
      type: "string"
    }),
    inputColorText: optional({
      type: "string"
    }),
    inputFontFamily: optional({
      type: "string"
    }),
    inputFontSize: optional({
      type: "string"
    }),
    inputFontLineHeight: optional({
      type: "string"
    }),
    inputFontWeight: optional({
      type: "string"
    }),
    inputBorder: optional({
      type: "string"
    }),
    inputBorderRadius: optional({
      type: "string"
    }),
    inputBoxShadow: optional({
      type: "string"
    }),
    // Input hover state properties
    inputHoverColorBackground: optional({
      type: "string"
    }),
    inputHoverColorText: optional({
      type: "string"
    }),
    inputHoverFontFamily: optional({
      type: "string"
    }),
    inputHoverFontSize: optional({
      type: "string"
    }),
    inputHoverFontLineHeight: optional({
      type: "string"
    }),
    inputHoverFontWeight: optional({
      type: "string"
    }),
    inputHoverBorder: optional({
      type: "string"
    }),
    inputHoverBorderRadius: optional({
      type: "string"
    }),
    inputHoverBoxShadow: optional({
      type: "string"
    }),
    // Input focus state properties
    inputFocusColorBackground: optional({
      type: "string"
    }),
    inputFocusColorText: optional({
      type: "string"
    }),
    inputFocusFontFamily: optional({
      type: "string"
    }),
    inputFocusFontSize: optional({
      type: "string"
    }),
    inputFocusFontLineHeight: optional({
      type: "string"
    }),
    inputFocusFontWeight: optional({
      type: "string"
    }),
    inputFocusBorder: optional({
      type: "string"
    }),
    inputFocusBorderRadius: optional({
      type: "string"
    }),
    inputFocusBoxShadow: optional({
      type: "string"
    }),
    // Input placeholder properties
    inputPlaceholderColorText: optional({
      type: "string"
    }),
    inputPlaceholderFontFamily: optional({
      type: "string"
    }),
    inputPlaceholderFontSize: optional({
      type: "string"
    }),
    inputPlaceholderFontLineHeight: optional({
      type: "string"
    }),
    inputPlaceholderFontWeight: optional({
      type: "string"
    }),
    // Selected input text properties
    inputSelectionColorText: optional({
      type: "string"
    }),
    inputSelectionColorBackground: optional({
      type: "string"
    }),
    // Invalid input properties
    inputErrorColorBackground: optional({
      type: "string"
    }),
    inputErrorColorText: optional({
      type: "string"
    }),
    inputErrorFontFamily: optional({
      type: "string"
    }),
    inputErrorFontSize: optional({
      type: "string"
    }),
    inputErrorFontLineHeight: optional({
      type: "string"
    }),
    inputErrorFontWeight: optional({
      type: "string"
    }),
    inputErrorBorder: optional({
      type: "string"
    }),
    inputErrorBorderRadius: optional({
      type: "string"
    }),
    inputErrorBoxShadow: optional({
      type: "string"
    }),
    // Invalid input hover state properties
    inputErrorHoverColorBackground: optional({
      type: "string"
    }),
    inputErrorHoverColorText: optional({
      type: "string"
    }),
    inputErrorHoverFontFamily: optional({
      type: "string"
    }),
    inputErrorHoverFontSize: optional({
      type: "string"
    }),
    inputErrorHoverFontLineHeight: optional({
      type: "string"
    }),
    inputErrorHoverFontWeight: optional({
      type: "string"
    }),
    inputErrorHoverBorder: optional({
      type: "string"
    }),
    inputErrorHoverBorderRadius: optional({
      type: "string"
    }),
    inputErrorHoverBoxShadow: optional({
      type: "string"
    }),
    // Invalid input focus state properties
    inputErrorFocusColorBackground: optional({
      type: "string"
    }),
    inputErrorFocusColorText: optional({
      type: "string"
    }),
    inputErrorFocusFontFamily: optional({
      type: "string"
    }),
    inputErrorFocusFontSize: optional({
      type: "string"
    }),
    inputErrorFocusFontLineHeight: optional({
      type: "string"
    }),
    inputErrorFocusFontWeight: optional({
      type: "string"
    }),
    inputErrorFocusBorder: optional({
      type: "string"
    }),
    inputErrorFocusBorderRadius: optional({
      type: "string"
    }),
    inputErrorFocusBoxShadow: optional({
      type: "string"
    }),
    // Invalid input placeholder properties
    inputErrorPlaceholderColorText: optional({
      type: "string"
    }),
    inputErrorPlaceholderFontFamily: optional({
      type: "string"
    }),
    inputErrorPlaceholderFontSize: optional({
      type: "string"
    }),
    inputErrorPlaceholderFontLineHeight: optional({
      type: "string"
    }),
    inputErrorPlaceholderFontWeight: optional({
      type: "string"
    }),
    // Invalid input selected text properties
    inputErrorSelectionColorText: optional({
      type: "string"
    }),
    inputErrorSelectionColorBackground: optional({
      type: "string"
    })
  },
  default: {},
  required: []
};
const addressFields = [
  "email",
  "organization",
  "phoneNumber",
  "city",
  "country",
  "region",
  "postalCode",
  "address",
  "address2"
];
const additionalFields = ["poNumber"];
const addressSchema = {
  type: "object",
  properties: {
    name: optional({
      type: "string",
      enum: ["default", "combined", "stacked"],
      default: "default"
    }),
    region: optional({
      type: "string",
      enum: ["default", "split", "stacked"],
      default: "default"
    }),
    show: optional({
      type: "array",
      default: [],
      items: {
        type: "string",
        enum: ["all", ...addressFields]
      }
    }),
    hide: optional({
      type: "array",
      default: [],
      items: {
        type: "string",
        enum: ["all", ...addressFields]
      }
    }),
    require: optional({
      type: "array",
      default: [],
      items: {
        type: "string",
        enum: addressFields
      }
    })
  },
  default: {},
  required: []
};
const digitalWalletConfigurationSchema = {
  type: "object",
  properties: {
    displayOptions: optional({
      type: "object",
      properties: {
        buttonColor: optional({
          type: "string",
          default: "black"
        }),
        buttonHeight: optional({
          type: "string",
          pattern: "^[0-9]+px$",
          default: "48px"
        }),
        buttonType: optional({
          type: "string",
          default: "plain"
        })
      },
      default: {}
    })
  },
  default: {},
  required: []
};
const paymentInstrumentsDisplayOptionsSchema = {
  type: "object",
  properties: {
    compactExpressInstruments: optional({
      type: "boolean",
      default: false
    }),
    allowDeactivate: optional({
      type: "boolean",
      default: false
    }),
    allowUpdate: optional({
      type: "boolean",
      default: false
    }),
    allowMakeDefault: optional({
      type: "boolean",
      default: false
    }),
    allowCreate: optional({
      type: "boolean",
      default: true
    }),
    address: optional(addressSchema),
    paypal: optional({
      type: "object",
      properties: {
        buttonHeight: optional({
          type: "number",
          default: 48
        })
      },
      default: {},
      required: []
    }),
    googlePay: optional(digitalWalletConfigurationSchema),
    applePay: optional(digitalWalletConfigurationSchema),
    paymentCard: optional({
      type: "object",
      properties: {
        input: optional({
          type: "string",
          enum: ["default", "split"],
          default: "default"
        })
      }
    }),
    additionalFields: optional({
      type: "object",
      properties: {
        show: optional({
          type: "array",
          default: [],
          items: {
            type: "string",
            enum: [...additionalFields]
          }
        }),
        require: optional({
          type: "array",
          default: [],
          items: {
            type: "string",
            enum: [...additionalFields]
          }
        })
      }
    })
  },
  default: {},
  required: []
};
const featuresSchema = {
  type: "object",
  properties: {
    enableTelemetry: optional({
      type: "boolean",
      default: true
    }),
    hideConfirmation: optional({
      type: "boolean",
      default: false
    }),
    hideResult: optional({
      type: "boolean",
      default: false
    }),
    fullPageRedirect: optional({
      type: "boolean",
      default: false
    }),
    showCoupons: optional({
      type: "array",
      items: {
        type: "string",
        enum: ["summary", "confirmation"]
      }
    }),
    hideContinue: optional({
      type: "boolean",
      default: false
    })
  },
  default: {}
};
const devSchema = {
  type: "object",
  properties: {
    paymentMethodsUrl: optional({
      type: "string",
      default: "https://forms.local.rebilly.dev:3000"
    }),
    liveUrl: optional({ type: "string" }),
    sandboxUrl: optional({ type: "string" }),
    framePayScriptLink: optional({ type: "string" }),
    framePayStyleLink: optional({ type: "string" })
  }
};
const purchaseDataKeys = [
  "items",
  "transactionId",
  "invoiceId",
  "money",
  "deposit",
  "payout"
];
const requireJWT = ["invoiceId", "transactionId", "deposit", "payout"];
const schema = {
  title: "Mount Options Schema",
  type: "object",
  properties: {
    organizationId: optional({ type: "string" }),
    publishableKey: optional({ type: "string" }),
    websiteId: optional({ type: "string" }),
    items: itemsSchema,
    money: moneySchema,
    invoiceId: { type: "string" },
    transactionId: { type: "string" },
    deposit: depositSchema,
    payout: payoutSchema,
    jwt: optional({ type: "string" }),
    addons: optional(planItemsSchema),
    bumpOffer: optional(planItemsSchema),
    form: optional({
      default: ".rebilly-instruments",
      type: ["string", "object"],
      oneOf: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            id: {
              type: "string"
            }
          }
        }
      ]
    }),
    summary: optional({
      default: ".rebilly-instruments-summary",
      type: ["string", "object"],
      oneOf: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            id: {
              type: "string"
            }
          }
        }
      ]
    }),
    apiMode: {
      type: "string",
      enum: ["sandbox", "live"]
    },
    transactionType: optional({
      type: "string",
      enum: ["purchase", "setup"],
      default: "purchase"
    }),
    css: optional({ type: "string" }),
    theme: optional(themeSchema),
    i18n: optional(i18nSchema),
    countryCode: optional({
      type: "string",
      default: "US"
    }),
    locale: optional({
      type: "string",
      default: "auto"
    }),
    paymentInstruments: optional(paymentInstrumentsDisplayOptionsSchema),
    features: optional(featuresSchema),
    _dev: optional(devSchema)
  },
  required: ["apiMode"],
  dependentRequired: {
    ...requireJWT.reduce((accumulator, currentValue) => {
      return {
        ...accumulator,
        [`${currentValue}`]: ["jwt"]
      };
    }, {})
  },
  anyOf: [
    ...purchaseDataKeys.map((key) => {
      const otherPurchaseDataKeys = purchaseDataKeys.filter(
        (value) => value !== key
      );
      return {
        if: { required: [key] },
        then: {
          properties: {
            ...otherPurchaseDataKeys.reduce(
              (otherProperties, currentKey) => {
                return {
                  ...otherProperties,
                  [currentKey]: false
                };
              },
              {}
            )
          }
        },
        else: false
      };
    }),
    {
      required: ["jwt"]
    }
  ]
};
class RebillyInstrumentsConfigError extends Error {
  constructor(message) {
    super(message);
    this.name = "Rebilly Instruments Configuration Error";
  }
  trimStack() {
    Error.captureStackTrace(this, RebillyInstrumentsConfigError);
    return this;
  }
}
const ajv = new AJV({
  allErrors: true,
  removeAdditional: true,
  useDefaults: true
});
const validate = ajv.compile(schema);
function sanitize2(data) {
  return Object.assign(JSON.parse(JSON.stringify(data)), {
    // HTMLElement is turned into objects by JSON.stringify
    form: data.form,
    summary: data.summary
  });
}
function validateOptions(data) {
  const sanitizedData = sanitize2(data);
  const valid = validate(sanitizedData);
  if (valid) {
    return sanitizedData;
  }
  validate.errors.forEach((error2) => {
    let errorMessage = ``;
    let instancePathReadable = error2.instancePath.substring(1).replace(/\//gi, ".");
    instancePathReadable = instancePathReadable.replace(
      /\.\d+/gi,
      (match) => `[${match.replace(".", "")}]`
    );
    if (!instancePathReadable.length) {
      instancePathReadable = "options";
    }
    let nodes;
    let schemaPath;
    let value;
    switch (error2.keyword) {
      case "if":
      case "false schema":
        break;
      case "required":
        if (error2.schemaPath.match(/(oneOf|anyOf)/)) {
          break;
        }
        errorMessage = `${instancePathReadable} ${error2.message}`;
        break;
      case "oneOf":
      case "anyOf":
        console.error(
          new RebillyInstrumentsConfigError(
            `${instancePathReadable} ${error2.message}, see schemas below.`
          ).trimStack()
        );
        schemaPath = error2.schemaPath.replace("#/", "").split("/");
        nodes = schema;
        schemaPath.forEach((item) => {
          nodes = nodes[item];
        });
        nodes.forEach((node) => {
          const displayNode = JSON.stringify(node, null, 2);
          console.error(
            `${instancePathReadable} ${error2.keyword} schema.
${displayNode}`
          );
        });
        break;
      case "enum":
        value = instancePathReadable.split(".").reduce((acc, key) => acc[key], data);
        errorMessage = `${instancePathReadable} ${error2.message}: ${error2.params.allowedValues}. received: ${value}`;
        break;
      case "dependentRequired":
      case "maxLength":
      case "minItems":
      case "pattern":
        errorMessage = `${instancePathReadable} ${error2.message}`;
        break;
      default:
        errorMessage = `Error with ${instancePathReadable} - See error message`;
        console.error(error2);
        break;
    }
    if (errorMessage) {
      console.error(
        new RebillyInstrumentsConfigError(errorMessage).trimStack()
      );
    }
  });
  console.error(
    new RebillyInstrumentsConfigError(
      "Configuration is invalid"
    ).trimStack()
  );
  return null;
}
function handleComputedProperty(options) {
  var _a;
  return Object.assign({}, options, {
    _computed: {
      version: "0.0.0",
      paymentMethodsUrl: ((_a = options._dev) == null ? void 0 : _a.paymentMethodsUrl) ?? "https://forms.secure-payments.app"
    }
  });
}
function handleNestedPropertiesDefaultValues(options) {
  var _a;
  if (!isDepositRequest(options.deposit) && ((_a = options.deposit) == null ? void 0 : _a.currency)) {
    options.deposit = merge$2(
      {
        editable: true,
        buttons: [],
        customAmount: {
          minimum: 1,
          maximum: 1e12,
          multipleOf: 1
        }
      },
      options.deposit || {}
    );
    if (Number.isNaN(options.deposit.amount)) {
      if (options.deposit.buttons && options.deposit.buttons.length > 0) {
        [options.deposit.amount] = options.deposit.buttons;
      }
    }
  } else if (isDepositRequest(options.deposit)) {
    options.deposit = merge$2(
      {
        customAmount: {
          minimum: 1,
          maximum: 1e12,
          multipleOf: 1
        }
      },
      options.deposit || {}
    );
  }
  if (options.items) {
    options.items = options.items.map((item) => ({
      ...item,
      quantity: parseQuantity(item)
    }));
  }
  return options;
}
function handleJwtDestructuring(options) {
  if (options.jwt && !options.publishableKey) {
    const {
      merchant: organizationId,
      claims: { transactionId, invoiceId, websiteId, cashierRequestId }
    } = o(options.jwt);
    Object.entries({
      organizationId,
      transactionId,
      invoiceId,
      websiteId
    }).forEach(([key, value]) => {
      if (value) {
        options[key] = value;
      }
    });
    if (cashierRequestId && !options.deposit) {
      options.deposit = Object.assign(
        {},
        {
          depositRequestId: cashierRequestId
        }
      );
    }
  }
  return options;
}
const setupOptions = ({
  options = {}
} = {}) => {
  let validOptions = validateOptions(options);
  if (validOptions) {
    validOptions = handleJwtDestructuring(validOptions);
    validOptions = handleNestedPropertiesDefaultValues(validOptions);
    validOptions = handleComputedProperty(validOptions);
  }
  return validOptions;
};
async function setupFramepay() {
  const { _dev } = state.options || {};
  const urls = {
    script: (_dev == null ? void 0 : _dev.framePayScriptLink) || "https://framepay.rebilly.com/framepay.js",
    style: (_dev == null ? void 0 : _dev.framePayStyleLink) || "https://framepay.rebilly.com/framepay.css"
  };
  return new Promise((resolve2) => {
    const framepayStyle = document.createElement("link");
    framepayStyle.setAttribute("href", urls.style);
    framepayStyle.setAttribute("rel", "stylesheet");
    document.head.prepend(framepayStyle);
    const framepayScript = document.createElement("script");
    framepayScript.setAttribute("src", urls.script);
    framepayScript.onload = () => resolve2();
    document.head.append(framepayScript);
  });
}
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
const colorName$1 = /* @__PURE__ */ getDefaultExportFromCjs(colorName);
const hexCharacters = "a-f\\d";
const match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
const match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
const nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
const validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
var hexRgb = (hex, options = {}) => {
  if (typeof hex !== "string" || nonHexChars.test(hex) || !validHexSize.test(hex)) {
    throw new TypeError("Expected a valid hex string");
  }
  hex = hex.replace(/^#/, "");
  let alphaFromHex = 1;
  if (hex.length === 8) {
    alphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;
    hex = hex.slice(0, 6);
  }
  if (hex.length === 4) {
    alphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
    hex = hex.slice(0, 3);
  }
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  const number2 = Number.parseInt(hex, 16);
  const red = number2 >> 16;
  const green = number2 >> 8 & 255;
  const blue = number2 & 255;
  const alpha = typeof options.alpha === "number" ? options.alpha : alphaFromHex;
  if (options.format === "array") {
    return [red, green, blue, alpha];
  }
  if (options.format === "css") {
    const alphaString = alpha === 1 ? "" : ` / ${Number((alpha * 100).toFixed(2))}%`;
    return `rgb(${red} ${green} ${blue}${alphaString})`;
  }
  return { red, green, blue, alpha };
};
const hex2Rgb = /* @__PURE__ */ getDefaultExportFromCjs(hexRgb);
const pattern$8 = /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/;
var hexRe$1 = new RegExp(pattern$8, "i");
const float$1 = "-?\\d*(?:\\.\\d+)";
const number$1 = `(${float$1}?)`;
const percentage$1 = `(${float$1}?%)`;
const numberOrPercentage$1 = `(${float$1}?%?)`;
const pattern$1$1 = `^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*,
    \\s*${percentage$1}\\s*,
    \\s*${percentage$1}\\s*
    (?:,\\s*${numberOrPercentage$1}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var hsl3Re$1 = new RegExp(pattern$1$1);
const pattern$2$1 = `^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*
    \\s+${percentage$1}
    \\s+${percentage$1}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage$1}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var hsl4Re$1 = new RegExp(pattern$2$1);
const pattern$3$1 = `^
  rgba?\\(
    \\s*${number$1}\\s*,
    \\s*${number$1}\\s*,
    \\s*${number$1}\\s*
    (?:,\\s*${numberOrPercentage$1}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var rgb3NumberRe$1 = new RegExp(pattern$3$1);
const pattern$4$1 = `^
  rgba?\\(
    \\s*${percentage$1}\\s*,
    \\s*${percentage$1}\\s*,
    \\s*${percentage$1}\\s*
    (?:,\\s*${numberOrPercentage$1}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var rgb3PercentageRe$1 = new RegExp(pattern$4$1);
const pattern$5$1 = `^
  rgba?\\(
    \\s*${number$1}
    \\s+${number$1}
    \\s+${number$1}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage$1}\\s*)?
  \\)
$
`.replace(/\n|\s/g, "");
var rgb4NumberRe$1 = new RegExp(pattern$5$1);
const pattern$6$1 = `^
  rgba?\\(
    \\s*${percentage$1}
    \\s+${percentage$1}
    \\s+${percentage$1}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage$1}\\s*)?
  \\)
$
`.replace(/\n|\s/g, "");
var rgb4PercentageRe$1 = new RegExp(pattern$6$1);
const pattern$7$1 = /^transparent$/;
var transparentRe$1 = new RegExp(pattern$7$1, "i");
const clamp$3 = (num, min, max) => Math.min(Math.max(min, num), max);
const parseRGB$1 = (num) => {
  let n2 = num;
  if (typeof n2 !== "number") n2 = n2.endsWith("%") ? parseFloat(n2) * 255 / 100 : parseFloat(n2);
  return clamp$3(Math.round(n2), 0, 255);
};
const parsePercentage$1 = (percentage2) => clamp$3(parseFloat(percentage2), 0, 100);
function parseAlpha$1(alpha) {
  let a = alpha;
  if (typeof a !== "number") a = a.endsWith("%") ? parseFloat(a) / 100 : parseFloat(a);
  return clamp$3(a, 0, 1);
}
function getHEX$1(hex) {
  const [r2, g, b2, a] = hex2Rgb(hex, { format: "array" });
  return getRGB$1([null, ...[r2, g, b2, a]]);
}
function getHSL$1([, h, s, l, a = 1]) {
  let hh = h;
  if (hh.endsWith("turn")) {
    hh = parseFloat(hh) * 360 / 1;
  } else if (hh.endsWith("rad")) {
    hh = Math.round(parseFloat(hh) * 180 / Math.PI);
  } else {
    hh = parseFloat(hh);
  }
  return {
    type: "hsl",
    values: [hh, parsePercentage$1(s), parsePercentage$1(l)],
    alpha: parseAlpha$1(a === null ? 1 : a)
  };
}
function getRGB$1([, r2, g, b2, a = 1]) {
  return {
    type: "rgb",
    values: [r2, g, b2].map(parseRGB$1),
    alpha: parseAlpha$1(a === null ? 1 : a)
  };
}
/**
 * parse-css-color
 * @version v0.1.2
 * @link http://github.com/noeldelgado/parse-css-color/
 * @license MIT
 */
const parseCSSColor$1 = (str) => {
  if (typeof str !== "string") return null;
  const hex = hexRe$1.exec(str);
  if (hex) return getHEX$1(hex[0]);
  const hsl = hsl4Re$1.exec(str) || hsl3Re$1.exec(str);
  if (hsl) return getHSL$1(hsl);
  const rgb = rgb4NumberRe$1.exec(str) || rgb4PercentageRe$1.exec(str) || rgb3NumberRe$1.exec(str) || rgb3PercentageRe$1.exec(str);
  if (rgb) return getRGB$1(rgb);
  if (transparentRe$1.exec(str)) return getRGB$1([null, 0, 0, 0, 0]);
  const cn2 = colorName$1[str.toLowerCase()];
  if (cn2) return getRGB$1([null, cn2[0], cn2[1], cn2[2], 1]);
  return null;
};
function hsl2rgb(hsl) {
  var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val;
  if (s == 0) {
    val = l * 255;
    return [val, val, val];
  }
  if (l < 0.5)
    t2 = l * (1 + s);
  else
    t2 = l + s - l * s;
  t1 = 2 * l - t2;
  rgb = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1);
    t3 < 0 && t3++;
    t3 > 1 && t3--;
    if (6 * t3 < 1)
      val = t1 + (t2 - t1) * 6 * t3;
    else if (2 * t3 < 1)
      val = t2;
    else if (3 * t3 < 2)
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    else
      val = t1;
    rgb[i] = val * 255;
  }
  return rgb;
}
var hsl2rgb_1 = hsl2rgb;
const hsl2rgb$1 = /* @__PURE__ */ getDefaultExportFromCjs(hsl2rgb_1);
function clamp$2(val, min, max) {
  return Math.min(Math.max(val, min), max);
}
var clamp_1 = clamp$2;
var clamp$1 = clamp_1;
function componentToHex(c) {
  var value = Math.round(clamp$1(c, 0, 255));
  var hex = value.toString(16);
  return hex.length == 1 ? "0" + hex : hex;
}
function rgb2hex(rgb) {
  var alpha = rgb.length === 4 ? componentToHex(rgb[3] * 255) : "";
  return "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]) + alpha;
}
var rgb2hex_1 = rgb2hex;
const rgb2hex$1 = /* @__PURE__ */ getDefaultExportFromCjs(rgb2hex_1);
function rgb2hsl(rgb) {
  var r2 = rgb[0] / 255, g = rgb[1] / 255, b2 = rgb[2] / 255, min = Math.min(r2, g, b2), max = Math.max(r2, g, b2), delta = max - min, h, s, l;
  if (max == min)
    h = 0;
  else if (r2 == max)
    h = (g - b2) / delta;
  else if (g == max)
    h = 2 + (b2 - r2) / delta;
  else if (b2 == max)
    h = 4 + (r2 - g) / delta;
  h = Math.min(h * 60, 360);
  if (h < 0)
    h += 360;
  l = (min + max) / 2;
  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);
  return [h, s * 100, l * 100];
}
var rgb2hsl_1 = rgb2hsl;
const rgb2hsl$1 = /* @__PURE__ */ getDefaultExportFromCjs(rgb2hsl_1);
/**
 * mix-css-color
 * @version v0.2.0
 * @link http://github.com/noeldelgado/mix-css-color/
 * @license MIT
 */
function parseColor(color) {
  const res = parseCSSColor$1(color);
  if (res === null) return null;
  if (res.type === "hsl") res.values = hsl2rgb$1(res.values);
  return res;
}
function mix(color1, color2, percentage2 = 50) {
  const c1 = parseColor(color1);
  const c2 = parseColor(color2);
  if (!c1 || !c2) return null;
  const p2 = Math.min(Math.max(0, percentage2), 100) / 100;
  const w2 = p2 * 2 - 1;
  const a = c1.alpha - c2.alpha;
  const w1 = ((w2 * a === -1 ? w2 : (w2 + a) / (1 + w2 * a)) + 1) / 2;
  const w22 = 1 - w1;
  const [r2, g, b2] = c1.values.map((c, i) => Math.round(c1.values[i] * w1 + c2.values[i] * w22));
  const alpha = parseFloat((c1.alpha * p2 + c2.alpha * (1 - p2)).toFixed(8));
  return {
    hex: rgb2hex$1([r2, g, b2]),
    hexa: rgb2hex$1([r2, g, b2, alpha]),
    rgba: [r2, g, b2, alpha],
    hsla: [...rgb2hsl$1([r2, g, b2]).map(Math.round), alpha]
  };
}
const pattern = /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/;
var hexRe = new RegExp(pattern, "i");
const float = "-?\\d*(?:\\.\\d+)";
const number = `(${float}?)`;
const percentage = `(${float}?%)`;
const numberOrPercentage = `(${float}?%?)`;
const pattern$1 = `^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*,
    \\s*${percentage}\\s*,
    \\s*${percentage}\\s*
    (?:,\\s*${numberOrPercentage}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var hsl3Re = new RegExp(pattern$1);
const pattern$2 = `^
  hsla?\\(
    \\s*(-?\\d*(?:\\.\\d+)?(?:deg|rad|turn)?)\\s*
    \\s+${percentage}
    \\s+${percentage}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var hsl4Re = new RegExp(pattern$2);
const pattern$3 = `^
  rgba?\\(
    \\s*${number}\\s*,
    \\s*${number}\\s*,
    \\s*${number}\\s*
    (?:,\\s*${numberOrPercentage}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var rgb3NumberRe = new RegExp(pattern$3);
const pattern$4 = `^
  rgba?\\(
    \\s*${percentage}\\s*,
    \\s*${percentage}\\s*,
    \\s*${percentage}\\s*
    (?:,\\s*${numberOrPercentage}\\s*)?
  \\)
  $
`.replace(/\n|\s/g, "");
var rgb3PercentageRe = new RegExp(pattern$4);
const pattern$5 = `^
  rgba?\\(
    \\s*${number}
    \\s+${number}
    \\s+${number}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage}\\s*)?
  \\)
$
`.replace(/\n|\s/g, "");
var rgb4NumberRe = new RegExp(pattern$5);
const pattern$6 = `^
  rgba?\\(
    \\s*${percentage}
    \\s+${percentage}
    \\s+${percentage}
    \\s*(?:\\s*\\/\\s*${numberOrPercentage}\\s*)?
  \\)
$
`.replace(/\n|\s/g, "");
var rgb4PercentageRe = new RegExp(pattern$6);
const pattern$7 = /^transparent$/;
var transparentRe = new RegExp(pattern$7, "i");
const clamp = (num, min, max) => Math.min(Math.max(min, num), max);
const parseRGB = (num) => {
  let n2 = num;
  if (typeof n2 !== "number") n2 = n2.endsWith("%") ? parseFloat(n2) * 255 / 100 : parseFloat(n2);
  return clamp(Math.round(n2), 0, 255);
};
const parsePercentage = (percentage2) => clamp(parseFloat(percentage2), 0, 100);
function parseAlpha(alpha) {
  let a = alpha;
  if (typeof a !== "number") a = a.endsWith("%") ? parseFloat(a) / 100 : parseFloat(a);
  return clamp(a, 0, 1);
}
function getHEX(hex) {
  const [r2, g, b2, a] = hex2Rgb(hex, { format: "array" });
  return getRGB([null, ...[r2, g, b2, a]]);
}
function getHSL([, h, s, l, a = 1]) {
  let hh = h;
  if (hh.endsWith("turn")) {
    hh = parseFloat(hh) * 360 / 1;
  } else if (hh.endsWith("rad")) {
    hh = Math.round(parseFloat(hh) * 180 / Math.PI);
  } else {
    hh = parseFloat(hh);
  }
  return {
    type: "hsl",
    values: [hh, parsePercentage(s), parsePercentage(l)],
    alpha: parseAlpha(a === null ? 1 : a)
  };
}
function getRGB([, r2, g, b2, a = 1]) {
  return {
    type: "rgb",
    values: [r2, g, b2].map(parseRGB),
    alpha: parseAlpha(a === null ? 1 : a)
  };
}
/**
 * parse-css-color
 * @version v0.2.0
 * @link http://github.com/noeldelgado/parse-css-color/
 * @license MIT
 */
const parseCSSColor = (str) => {
  if (typeof str !== "string") return null;
  const hex = hexRe.exec(str);
  if (hex) return getHEX(hex[0]);
  const hsl = hsl4Re.exec(str) || hsl3Re.exec(str);
  if (hsl) return getHSL(hsl);
  const rgb = rgb4NumberRe.exec(str) || rgb4PercentageRe.exec(str) || rgb3NumberRe.exec(str) || rgb3PercentageRe.exec(str);
  if (rgb) return getRGB(rgb);
  if (transparentRe.exec(str)) return getRGB([null, 0, 0, 0, 0]);
  const cn2 = colorName$1[str.toLowerCase()];
  if (cn2) return getRGB([null, cn2[0], cn2[1], cn2[2], 1]);
  return null;
};
/**
 * values.js - Get the tints and shades of a color
 * @version v2.1.1
 * @link http://noeldelgado.github.io/values.js/
 * @license MIT
 */
const defaultNumberParam = (v2, d2) => v2 === null || isNaN(v2) || typeof v2 === "string" ? d2 : v2;
class Values {
  constructor(color = "#000", type2 = "base", weight = 0) {
    [this.rgb, this.alpha, this.type, this.weight] = [[0, 0, 0], 1, type2, weight];
    const c = color === null ? "#000" : color;
    if (typeof c !== "string") throw new TypeError(`Input should be a string: ${c}`);
    const parsed = parseCSSColor(c);
    if (!parsed) throw new Error(`Unable to parse color from string: ${c}`);
    return this[`_setFrom${parsed.type.toUpperCase()}`]([...parsed.values, parsed.alpha]);
  }
  get hex() {
    return this.hexString().replace(/^#/, "");
  }
  setColor(color) {
    const parsed = parseCSSColor(color);
    if (!parsed) return null;
    return this[`_setFrom${parsed.type.toUpperCase()}`]([...parsed.values, parsed.alpha]);
  }
  tint(weight, w2 = defaultNumberParam(weight, 50)) {
    return new Values(`rgb(${mix("#fff", this.rgbString(), w2).rgba})`, "tint", w2);
  }
  shade(weight, w2 = defaultNumberParam(weight, 50)) {
    return new Values(`rgb(${mix("#000", this.rgbString(), w2).rgba})`, "shade", w2);
  }
  tints(weight, w2 = defaultNumberParam(weight, 10)) {
    return Array.from({ length: 100 / w2 }, (_2, i) => this.tint((i + 1) * w2));
  }
  shades(weight, w2 = defaultNumberParam(weight, 10)) {
    return Array.from({ length: 100 / w2 }, (_2, i) => this.shade((i + 1) * w2));
  }
  all(weight = 10) {
    return [...this.tints(weight).reverse(), Object.assign(this), ...this.shades(weight)];
  }
  hexString() {
    return rgb2hex$1(this.alpha >= 1 ? this.rgb : [...this.rgb, this.alpha]);
  }
  rgbString() {
    const channels = (this.alpha >= 1 ? this.rgb : [...this.rgb, this.alpha]).join(", ");
    return `${this.alpha >= 1 ? "rgb" : "rgba"}(${channels})`;
  }
  getBrightness() {
    return Math.round(this.rgb.reduce((a, b2) => a + b2) / (255 * 3) * 100);
  }
  _setFromRGB([r2, g, b2, a]) {
    [this.rgb, this.alpha] = [[r2, g, b2], a];
    return this;
  }
  _setFromHSL([h, s, l, a]) {
    [this.rgb, this.alpha] = [hsl2rgb$1([h, s, l]).map(Math.round), a];
    return this;
  }
}
Values.VERSION = "v2.1.1";
const colorValues = (color) => new Values(color.trim());
function alphaColor(color, alphaValue = 1) {
  if (color === null) {
    return color;
  }
  const _alphaColor = colorValues(color);
  _alphaColor.alpha = alphaValue;
  return _alphaColor.rgbString();
}
const mutedTextColor = (color) => alphaColor(color, 0.5);
const mutedBorderColor = (color) => alphaColor(color, 0.25);
const darken = (color, percent) => {
  if (color === null) {
    return color;
  }
  const _color = colorValues(color);
  return _color.shade(percent).hexString();
};
class Border {
  constructor(str) {
    this.allStyles = [
      "none",
      "hidden",
      "dotted",
      "dashed",
      "solid",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset",
      "initial",
      "inherit"
    ];
    this.str = str || "";
    const style = this.allStyles.find((s) => this.str.includes(s));
    if (style == null) {
      throw new Error("Invalid border style.");
    }
    const borderProps = this.str.split(style).map((a) => a.trim());
    this.border = [borderProps[0], style, borderProps[1]];
  }
  get stylePosition() {
    let stylePosition = 0;
    if (this.border.length === 3) {
      stylePosition = 1;
    } else if (this.border.length === 2) {
      if (this.allStyles.includes(this.border[0])) {
        stylePosition = 0;
      } else {
        stylePosition = 1;
      }
    }
    return stylePosition;
  }
  updateColor(color) {
    this.border[this.stylePosition + 1] = color;
    return this;
  }
  get value() {
    return this.border.join(" ");
  }
}
const properties = {
  /** Base Colors */
  colorPrimary: {
    fallback: {
      type: "static",
      value: "#0044D4"
    }
  },
  colorBackground: {
    fallback: {
      type: "static",
      value: "#FFFFFF"
    }
  },
  colorText: {
    fallback: {
      type: "static",
      value: "#0D2B3E"
    }
  },
  colorMutedText: {
    fallback: {
      type: "func",
      value: (theme2) => mutedTextColor(theme2.colorText)
    }
  },
  colorMutedBorder: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.colorTextProvided) {
          return mutedBorderColor(theme2.colorText);
        }
        return "#DCE3EA";
      }
    }
  },
  colorDanger: {
    fallback: {
      type: "static",
      value: "#CD5C5C"
    }
  },
  colorSuccess: {
    fallback: {
      type: "static",
      value: "#22BC32"
    }
  },
  colorSuccessMuted: {
    fallback: {
      type: "static",
      value: "#DDF5E0"
    }
  },
  colorSuccessDark: {
    fallback: {
      type: "static",
      value: "#0C4112"
    }
  },
  /** Base Fonts */
  fontFamily: {
    fallback: {
      type: "static",
      value: "-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial sans-serif"
    }
  },
  fontSizeBase: {
    fallback: {
      type: "static",
      value: "16px"
    }
  },
  fontWeightBase: {
    fallback: {
      type: "static",
      value: "500"
    }
  },
  fontLineHeightBase: {
    fallback: {
      type: "func",
      value: (theme2) => `calc(${theme2.fontSizeBase} * 1.5)`
    }
  },
  fontSmooth: {
    fallback: {
      type: "static",
      value: "auto"
    }
  },
  /** Misc */
  borderRadius: {
    fallback: {
      type: "static",
      value: "6px"
    }
  },
  /** Headings */
  headingFontFamily: {
    fallback: {
      type: "variable",
      value: "fontFamily"
    }
  },
  headingFontWeight: {
    fallback: {
      type: "static",
      value: "600"
    }
  },
  headingColorText: {
    fallback: {
      type: "variable",
      value: "colorText"
    }
  },
  /** Buttons */
  buttonColorBackground: {
    fallback: {
      type: "variable",
      value: "colorPrimary"
    }
  },
  buttonColorText: {
    fallback: {
      type: "static",
      value: "#FFFFFF"
    }
  },
  buttonFontFamily: {
    fallback: {
      type: "variable",
      value: "fontFamily"
    }
  },
  buttonFontSize: {
    fallback: {
      type: "variable",
      value: "fontSizeBase"
    }
  },
  buttonFontLineHeight: {
    fallback: {
      type: "variable",
      value: "fontLineHeightBase"
    }
  },
  buttonFontWeight: {
    fallback: {
      type: "variable",
      value: "fontWeightBase"
    }
  },
  buttonBorder: {
    fallback: {
      type: "static",
      value: "1px solid transparent"
    }
  },
  buttonBorderColor: {
    fallback: {
      type: "variable",
      value: "colorPrimary"
    }
  },
  buttonBorderWidth: {
    fallback: {
      type: "static",
      value: "1px"
    }
  },
  buttonBorderType: {
    fallback: {
      type: "static",
      value: "solid"
    }
  },
  buttonBorderRadius: {
    fallback: {
      type: "variable",
      value: "borderRadius"
    }
  },
  buttonBoxShadow: {
    fallback: {
      type: "static",
      value: "none"
    }
  },
  /** Buttons Secondary */
  buttonSecondaryColorBackground: {
    fallback: {
      type: "variable",
      value: "colorBackground"
    }
  },
  buttonSecondaryColorText: {
    fallback: {
      type: "variable",
      value: "colorText"
    }
  },
  buttonSecondaryFontFamily: {
    fallback: {
      type: "variable",
      value: "fontFamily"
    }
  },
  buttonSecondaryFontSize: {
    fallback: {
      type: "variable",
      value: "fontSizeBase"
    }
  },
  buttonSecondaryFontLineHeight: {
    fallback: {
      type: "variable",
      value: "fontLineHeightBase"
    }
  },
  buttonSecondaryFontWeight: {
    fallback: {
      type: "variable",
      value: "fontWeightBase"
    }
  },
  buttonSecondaryBorder: {
    fallback: {
      type: "func",
      value: (theme2) => `1px solid ${theme2.colorMutedBorder}`
    }
  },
  buttonSecondaryBorderColor: {
    fallback: {
      type: "variable",
      value: "colorMutedBorder"
    }
  },
  buttonSecondaryBorderWidth: {
    fallback: {
      type: "static",
      value: "1px"
    }
  },
  buttonSecondaryBorderType: {
    fallback: {
      type: "static",
      value: "solid"
    }
  },
  buttonSecondaryBorderRadius: {
    fallback: {
      type: "variable",
      value: "borderRadius"
    }
  },
  buttonSecondaryBoxShadow: {
    fallback: {
      type: "static",
      value: "none"
    }
  },
  /** Buttons: Hover */
  buttonHoverColorBackground: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.buttonColorBackgroundProvided) {
          return darken(theme2.buttonColorBackground, 20);
        }
        return darken(theme2.colorPrimary, 20);
      }
    }
  },
  buttonHoverColorText: {
    fallback: {
      type: "variable",
      value: "buttonColorText"
    }
  },
  buttonHoverFontFamily: {
    fallback: {
      type: "variable",
      value: "buttonFontFamily"
    }
  },
  buttonHoverFontSize: {
    fallback: {
      type: "variable",
      value: "buttonFontSize"
    }
  },
  buttonHoverFontLineHeight: {
    fallback: {
      type: "variable",
      value: "buttonFontLineHeight"
    }
  },
  buttonHoverFontWeight: {
    fallback: {
      type: "variable",
      value: "buttonFontWeight"
    }
  },
  buttonHoverBorder: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.buttonBorderProvided) {
          return theme2.buttonBorder;
        }
        const buttonBorder = new Border(theme2.buttonBorder);
        return buttonBorder.updateColor(
          theme2.buttonHoverColorBackground
        ).value;
      }
    }
  },
  buttonHoverBorderColor: {
    fallback: {
      type: "variable",
      value: "colorPrimary"
    }
  },
  buttonHoverBorderWidth: {
    fallback: {
      type: "variable",
      value: "buttonBorderWidth"
    }
  },
  buttonHoverBorderType: {
    fallback: {
      type: "variable",
      value: "buttonBorderType"
    }
  },
  buttonHoverBorderRadius: {
    fallback: {
      type: "variable",
      value: "buttonBorderRadius"
    }
  },
  buttonHoverBoxShadow: {
    fallback: {
      type: "variable",
      value: "buttonBoxShadow"
    }
  },
  /** Buttons Secondary: Hover */
  buttonSecondaryHoverColorBackground: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.colorBackgroundProvided) {
          return darken(theme2.colorBackground, 3);
        }
        return darken(theme2.colorBackground, 3);
      }
    }
  },
  buttonSecondaryHoverColorText: {
    fallback: {
      type: "variable",
      value: "colorText"
    }
  },
  buttonSecondaryHoverFontFamily: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryFontFamily"
    }
  },
  buttonSecondaryHoverFontSize: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryFontSize"
    }
  },
  buttonSecondaryHoverFontLineHeight: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryFontLineHeight"
    }
  },
  buttonSecondaryHoverFontWeight: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryFontWeight"
    }
  },
  buttonSecondaryHoverBorder: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBorder"
    }
  },
  buttonSecondaryHoverBorderColor: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBorderColor"
    }
  },
  buttonSecondaryHoverBorderWidth: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBorderWidth"
    }
  },
  buttonSecondaryHoverBorderType: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBorderType"
    }
  },
  buttonSecondaryHoverBorderRadius: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBorderRadius"
    }
  },
  buttonSecondaryHoverBoxShadow: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryBoxShadow"
    }
  },
  /** Buttons: Active */
  buttonActiveColorBackground: {
    fallback: {
      type: "variable",
      value: "buttonHoverColorBackground"
    }
  },
  buttonActiveColorText: {
    fallback: {
      type: "variable",
      value: "buttonHoverColorText"
    }
  },
  buttonActiveFontFamily: {
    fallback: {
      type: "variable",
      value: "buttonHoverFontFamily"
    }
  },
  buttonActiveFontSize: {
    fallback: {
      type: "variable",
      value: "buttonHoverFontSize"
    }
  },
  buttonActiveFontLineHeight: {
    fallback: {
      type: "variable",
      value: "buttonHoverFontLineHeight"
    }
  },
  buttonActiveFontWeight: {
    fallback: {
      type: "variable",
      value: "buttonHoverFontWeight"
    }
  },
  buttonActiveBorder: {
    fallback: {
      type: "variable",
      value: "buttonHoverBorder"
    }
  },
  buttonActiveBorderColor: {
    fallback: {
      type: "variable",
      value: "buttonHoverBorderColor"
    }
  },
  buttonActiveBorderWidth: {
    fallback: {
      type: "variable",
      value: "buttonHoverBorderWidth"
    }
  },
  buttonActiveBorderType: {
    fallback: {
      type: "variable",
      value: "buttonHoverBorderType"
    }
  },
  buttonActiveBorderRadius: {
    fallback: {
      type: "variable",
      value: "buttonHoverBorderRadius"
    }
  },
  buttonActiveBoxShadow: {
    fallback: {
      type: "variable",
      value: "buttonHoverBoxShadow"
    }
  },
  /** Buttons Secondary: Active */
  buttonSecondaryActiveColorBackground: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverColorBackground"
    }
  },
  buttonSecondaryActiveColorText: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverColorText"
    }
  },
  buttonSecondaryActiveFontFamily: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverFontFamily"
    }
  },
  buttonSecondaryActiveFontSize: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverFontSize"
    }
  },
  buttonSecondaryActiveFontLineHeight: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverFontLineHeight"
    }
  },
  buttonSecondaryActiveFontWeight: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverFontWeight"
    }
  },
  buttonSecondaryActiveBorder: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBorder"
    }
  },
  buttonSecondaryActiveBorderColor: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBorderColor"
    }
  },
  buttonSecondaryActiveBorderWidth: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBorderWidth"
    }
  },
  buttonSecondaryActiveBorderType: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBorderType"
    }
  },
  buttonSecondaryActiveBorderRadius: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBorderRadius"
    }
  },
  buttonSecondaryActiveBoxShadow: {
    fallback: {
      type: "variable",
      value: "buttonSecondaryHoverBoxShadow"
    }
  },
  /** Inputs: Base */
  inputColorBackground: {
    fallback: {
      type: "static",
      value: "transparent"
    }
  },
  inputColorText: {
    fallback: {
      type: "variable",
      value: "colorText"
    }
  },
  inputFontFamily: {
    fallback: {
      type: "variable",
      value: "fontFamily"
    }
  },
  inputFontSize: {
    fallback: {
      type: "variable",
      value: "fontSizeBase"
    }
  },
  inputFontLineHeight: {
    fallback: {
      type: "variable",
      value: "fontLineHeightBase"
    }
  },
  inputFontWeight: {
    fallback: {
      type: "variable",
      value: "fontWeightBase"
    }
  },
  inputBorder: {
    fallback: {
      type: "func",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      value: (theme2) => `1px solid ${darken(theme2.colorMutedBorder, 4)}`
    }
  },
  inputBorderRadius: {
    fallback: {
      type: "variable",
      value: "borderRadius"
    }
  },
  inputBoxShadow: {
    fallback: {
      type: "static",
      value: "none"
    }
  },
  /** Inputs: Hover */
  inputHoverColorBackground: {
    fallback: {
      type: "variable",
      value: "inputColorBackground"
    }
  },
  inputHoverColorText: {
    fallback: {
      type: "variable",
      value: "inputColorText"
    }
  },
  inputHoverFontFamily: {
    fallback: {
      type: "variable",
      value: "inputFontFamily"
    }
  },
  inputHoverFontSize: {
    fallback: {
      type: "variable",
      value: "inputFontSize"
    }
  },
  inputHoverFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputFontLineHeight"
    }
  },
  inputHoverFontWeight: {
    fallback: {
      type: "variable",
      value: "inputFontWeight"
    }
  },
  inputHoverBorder: {
    fallback: {
      type: "variable",
      value: "inputBorder"
    }
  },
  inputHoverBorderRadius: {
    fallback: {
      type: "variable",
      value: "inputBorderRadius"
    }
  },
  inputHoverBoxShadow: {
    fallback: {
      type: "variable",
      value: "inputBoxShadow"
    }
  },
  /** Inputs: Focus */
  inputFocusColorBackground: {
    fallback: {
      type: "variable",
      value: "inputHoverColorBackground"
    }
  },
  inputFocusColorText: {
    fallback: {
      type: "variable",
      value: "inputHoverColorText"
    }
  },
  inputFocusFontFamily: {
    fallback: {
      type: "variable",
      value: "inputHoverFontFamily"
    }
  },
  inputFocusFontSize: {
    fallback: {
      type: "variable",
      value: "inputHoverFontSize"
    }
  },
  inputFocusFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputHoverFontLineHeight"
    }
  },
  inputFocusFontWeight: {
    fallback: {
      type: "variable",
      value: "inputHoverFontWeight"
    }
  },
  inputFocusBorder: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.inputHoverBorderProvided) {
          return theme2.inputHoverBorder;
        }
        const inputBorder = new Border(theme2.inputBorder);
        return inputBorder.updateColor(theme2.colorPrimary).value;
      }
    }
  },
  inputFocusBorderRadius: {
    fallback: {
      type: "variable",
      value: "inputHoverBorderRadius"
    }
  },
  inputFocusBoxShadow: {
    fallback: {
      type: "func",
      value: (theme2) => `0 0 0 1px ${theme2.colorPrimary}`
    }
  },
  /** Inputs: Placholder */
  inputPlaceholderColorText: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.inputColorTextProvided) {
          return mutedTextColor(theme2.inputColorText);
        }
        return theme2.colorMutedText;
      }
    }
  },
  inputPlaceholderFontFamily: {
    fallback: {
      type: "variable",
      value: "inputFontFamily"
    }
  },
  inputPlaceholderFontSize: {
    fallback: {
      type: "variable",
      value: "inputFontSize"
    }
  },
  inputPlaceholderFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputFontLineHeight"
    }
  },
  inputPlaceholderFontWeight: {
    fallback: {
      type: "variable",
      value: "inputFontWeight"
    }
  },
  /** Inputs: Selection */
  inputSelectionColorText: {
    fallback: {
      type: "static",
      value: "initial"
    }
  },
  inputSelectionColorBackground: {
    fallback: {
      type: "static",
      value: "highlight"
    }
  },
  /** Inputs Error */
  inputErrorColorBackground: {
    fallback: {
      type: "variable",
      value: "inputColorBackground"
    }
  },
  inputErrorColorText: {
    fallback: {
      type: "variable",
      value: "colorDanger"
    }
  },
  inputErrorFontFamily: {
    fallback: {
      type: "variable",
      value: "inputFontFamily"
    }
  },
  inputErrorFontSize: {
    fallback: {
      type: "variable",
      value: "inputFontSize"
    }
  },
  inputErrorFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputFontLineHeight"
    }
  },
  inputErrorFontWeight: {
    fallback: {
      type: "variable",
      value: "inputFontWeight"
    }
  },
  inputErrorBorder: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.inputBorderProvided) {
          const inputBorder = new Border(theme2.inputBorder);
          return inputBorder.updateColor(theme2.colorDanger).value;
        }
        return `1px solid ${theme2.colorDanger}`;
      }
    }
  },
  inputErrorBorderRadius: {
    fallback: {
      type: "variable",
      value: "inputBorderRadius"
    }
  },
  inputErrorBoxShadow: {
    fallback: {
      type: "variable",
      value: "inputBoxShadow"
    }
  },
  /** Inputs Error: Hover */
  inputErrorHoverColorBackground: {
    fallback: {
      type: "variable",
      value: "inputErrorColorBackground"
    }
  },
  inputErrorHoverColorText: {
    fallback: {
      type: "variable",
      value: "inputErrorColorText"
    }
  },
  inputErrorHoverFontFamily: {
    fallback: {
      type: "variable",
      value: "inputErrorFontFamily"
    }
  },
  inputErrorHoverFontSize: {
    fallback: {
      type: "variable",
      value: "inputErrorFontSize"
    }
  },
  inputErrorHoverFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputErrorFontLineHeight"
    }
  },
  inputErrorHoverFontWeight: {
    fallback: {
      type: "variable",
      value: "inputErrorFontWeight"
    }
  },
  inputErrorHoverBorder: {
    fallback: {
      type: "variable",
      value: "inputErrorBorder"
    }
  },
  inputErrorHoverBorderRadius: {
    fallback: {
      type: "variable",
      value: "inputErrorBorderRadius"
    }
  },
  inputErrorHoverBoxShadow: {
    fallback: {
      type: "variable",
      value: "inputErrorBoxShadow"
    }
  },
  /** Inputs Error: Focus */
  inputErrorFocusColorBackground: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverColorBackground"
    }
  },
  inputErrorFocusColorText: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverColorText"
    }
  },
  inputErrorFocusFontFamily: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverFontFamily"
    }
  },
  inputErrorFocusFontSize: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverFontSize"
    }
  },
  inputErrorFocusFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverFontLineHeight"
    }
  },
  inputErrorFocusFontWeight: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverFontWeight"
    }
  },
  inputErrorFocusBorder: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverBorder"
    }
  },
  inputErrorFocusBorderRadius: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverBorderRadius"
    }
  },
  inputErrorFocusBoxShadow: {
    fallback: {
      type: "variable",
      value: "inputErrorHoverBoxShadow"
    }
  },
  /** Inputs Error: Placholder */
  inputErrorPlaceholderColorText: {
    fallback: {
      type: "func",
      value: (theme2) => {
        if (theme2.inputErrorColorTextProvided) {
          return mutedTextColor(theme2.inputErrorColorText);
        }
        return mutedTextColor(theme2.colorDanger);
      }
    }
  },
  inputErrorPlaceholderFontFamily: {
    fallback: {
      type: "variable",
      value: "inputPlaceholderFontFamily"
    }
  },
  inputErrorPlaceholderFontSize: {
    fallback: {
      type: "variable",
      value: "inputPlaceholderFontSize"
    }
  },
  inputErrorPlaceholderFontLineHeight: {
    fallback: {
      type: "variable",
      value: "inputPlaceholderFontLineHeight"
    }
  },
  inputErrorPlaceholderFontWeight: {
    fallback: {
      type: "variable",
      value: "inputPlaceholderFontWeight"
    }
  },
  /** Inputs Error: Selection */
  inputErrorSelectionColorText: {
    fallback: {
      type: "variable",
      value: "inputSelectionColorText"
    }
  },
  inputErrorSelectionColorBackground: {
    fallback: {
      type: "variable",
      value: "inputSelectionColorBackground"
    }
  },
  /** Labels */
  labels: {
    fallback: {
      type: "static",
      value: "floating"
    }
  }
};
const theme = new Proxy(properties, {
  get(obj, prop, receiver) {
    if (prop in obj) {
      if (obj[prop].value) {
        return obj[prop].value;
      }
      const { type: type2, value } = obj[prop].fallback;
      if (type2 === "static") {
        return value;
      }
      if (type2 === "variable") {
        return `var(--rebilly-${value})`;
      }
      if (type2 === "func" && typeof value === "function") {
        return value(receiver);
      }
    }
    if (prop.endsWith("Provided")) {
      const target = prop.replace("Provided", "");
      if (target in obj) {
        return obj[target].isProvided;
      }
    }
    return void 0;
  },
  set: (obj, prop, value) => {
    if (!(prop in obj) || !value) {
      throw new Error(`Invalid theme option provided: ${prop}`);
    }
    obj[prop].value = value;
    obj[prop].isProvided = true;
    return true;
  }
});
const _Theme = class _Theme {
  constructor(overrides = {}) {
    this.overrides = overrides;
    this.theme = theme;
  }
  overrideTheme() {
    Object.keys(this.overrides).forEach((prop) => {
      this.theme[prop] = this.overrides[prop];
    });
  }
  get cssVars() {
    return Object.keys(this.theme).filter((v2) => !_Theme.nonCssProperties.includes(v2)).map((p2, i) => `${!i ? "" : "  "}--rebilly-${p2}: ${this.theme[p2]};`).join("\n");
  }
  build() {
    this.overrideTheme();
    return {
      cssVars: this.cssVars
    };
  }
};
_Theme.nonCssProperties = ["labels"];
let Theme = _Theme;
const vars = (theme2) => `
/* Instruments 'global' variables
------------------------------------------------------------ */
:root, :host {
  ${theme2.cssVars}

  --rebilly-fontWeight400: 400;
  --rebilly-fontWeight500: 500;
  --rebilly-fontWeight600: 600;
  --rebilly-fontScaleFactor: 1.5;
  --rebilly-fontScaleFactorS: 0.875;
  --rebilly-fontSizeS: calc(var(--rebilly-fontSizeBase) * var(--rebilly-fontScaleFactorS));
  --rebilly-fontLineHeightS: calc(var(--rebilly-fontSizeS) * 1);

  --rebilly-fontSizeXs: calc(var(--rebilly-fontSizeS) * var(--rebilly-fontScaleFactorS));
  --rebilly-fontSizeL: calc(var(--rebilly-fontSizeBase) * var(--rebilly-fontScaleFactor));
  --rebilly-fontLineHeightL: calc(var(--rebilly-fontLineHeightBase) * 2);
  --rebilly-fontMarginTopL: 0;
  --rebilly-fontMarginBottomL: var(--rebilly-fontLineHeightBase);

  --rebilly-spacing2xs: calc(var(--rebilly-fontLineHeightBase) / 6);
  --rebilly-spacingXs: calc(var(--rebilly-fontLineHeightBase) / 4);
  --rebilly-spacingS: calc(var(--rebilly-fontLineHeightBase) / 2);
  --rebilly-spacingM: var(--rebilly-fontLineHeightBase);
  --rebilly-spacingL: calc(var(--rebilly-fontLineHeightBase) * 2);
  --rebilly-spacingXl: calc(var(--rebilly-fontLineHeightBase) * 4);

  --rebilly-spacingFormElementMinHeight: calc(var(--rebilly-spacingM) * 1.83333);

  --rebilly-summaryLoaderMinHeight: var(--rebilly-fontLineHeightBase);
  --rebilly-methodLoaderMinHeight: calc((4 * var(--rebilly-spacingFormElementMinHeight)) + (2 * var(--rebilly-fontLineHeightBase)) + (2 * var(--rebilly-spacingM)) + var(--rebilly-spacing2xs) + var(--rebilly-fontSizeS) + calc(2 * (var(--rebilly-spacingXs) + var(--rebilly-spacingS))) + var(--rebilly-spacingL));
  
  --rebilly-monoFontFamily: 'SFMono-Medium', 'SF Mono', 'Segoe UI Mono', 'Roboto Mono', 'Ubuntu Mono', Menlo, Consolas, Courier, monospace;
}

/* Base, Typography
------------------------------------------------------------ */
/* Base setup for top level elements */
.rebilly-instruments-content {
  color: var(--rebilly-colorText);
  background: var(--rebilly-colorBackground);
  font-size: var(--rebilly-fontSizeBase);
  font-weight: var(--rebilly-fontWeightBase);
  line-height: var(--rebilly-fontLineHeightBase);
  font-family: var(--rebilly-fontFamily);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: left;
  transition: all 200ms;
  font-smooth: var(--rebilly-fontSmooth);
  padding: 2px;
  font-display: swap;
}

/* Views. Method Selector
------------------------------------------------------------ */
.rebilly-instruments-method-selector.has-express-compact {
  padding-top: var(--rebilly-spacingS);
}

.rebilly-instruments-amount-selector {
  padding: 2px;
}

/* Express Methods
------------------------------------------------------------ */
@-webkit-keyframes rebillyExpressShine {
  to {
    background-position-x: -200%;
  }
}

@keyframes rebillyExpressShine {
  to {
    background-position-x: -200%;
  }
}

.rebilly-instruments-express-methods { padding: 2px; }

.rebilly-instruments-express-methods.is-compact {
  border: 1px solid var(--rebilly-colorMutedBorder);
  padding: var(--rebilly-spacingS);
  padding-top: calc(var(--rebilly-spacingXs) + var(--rebilly-spacingS));
  padding-top: calc(var(--rebilly-fontSizeBase) + var(--rebilly-spacing2xs));
  border-radius: var(--rebilly-borderRadius);
  position: relative;
}

.rebilly-instruments-express-methods .rebilly-instruments-iframe {
  display: block;
  margin-bottom: 0;
  height: var(--rebilly-spacingFormElementMinHeight);
}

.rebilly-instruments-express-methods .rebilly-instruments-express-methods-container > * {
  border-radius: 6px;
  margin-bottom: var(--rebilly-spacingS);
  background: linear-gradient(110deg, var(--rebilly-colorMutedBorder) 0%, var(--rebilly-colorBackground) 25%, var(--rebilly-colorMutedBorder) 50%);
  background-size: 200% 100%;
  -webkit-animation: 1.5s rebillyExpressShine linear infinite;
          animation: 1.5s rebillyExpressShine linear infinite;
  min-height: 48px;
}

.rebilly-instruments-express-methods .rebilly-instruments-express-methods-container > *:last-child {
  margin: 0;
}

.rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container {
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-pack: center;
      -ms-flex-pack: center;
          justify-content: center;
}

.rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container > * {
  -webkit-box-flex: 1;
      -ms-flex: 1 1 0px;
          flex: 1 1 0px;
  max-width: 260px;
  margin: 0 var(--rebilly-spacingXs);
}

.rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container > *:first-child {
  margin-left: 0;
}

.rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container > *:last-child {
  margin-right: 0;
}

.rebilly-instruments-express-methods .rebilly-instruments-express-methods-label {
  display: none;
}

.rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-label {
  position: absolute;
  font-family: var(--rebilly-fontFamily);
  top: 0; left: 50%;
  -webkit-transform: translateX(-50%) translateY(-50%);
          transform: translateX(-50%) translateY(-50%);
  color: var(--rebilly-colorText);
  padding: var(--rebilly-spacing2xs) var(--rebilly-spacingM);
  line-height: 1;
  background: var(--rebilly-colorBackground);
  display: inline-block;
  font-weight: var(--rebilly-fontWeightBase);
  min-height: auto;
  margin: 0;
  white-space: nowrap;
}

.rebilly-instruments-express-methods .rebilly-instruments-google-pay-method {
  border-radius: 100px;
}

.rebilly-instruments-express-methods .rebilly-instruments-google-pay-method iframe {
  width: 100%;
  height: 100%;
  border: none;
}

@media (max-width: 600px) {
  .rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container  {
    -webkit-box-orient: vertical;
    -webkit-box-direction: normal;
        -ms-flex-direction: column;
            flex-direction: column;
  }

  .rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container > * {
    max-width: 100%;
    margin: 0 0 var(--rebilly-spacingS);
  }
  
  .rebilly-instruments-express-methods.is-compact .rebilly-instruments-express-methods-container > *:last-child {
    margin: 0;
  }
}

/* Components. Divider
------------------------------------------------------------ */
.rebilly-instruments-divider {
  line-height: var(--rebilly-fontLineHeightBase);
  padding: var(--rebilly-spacingM) 0;
  margin: 0;
  position: relative;
  outline: 0;
  border: 0;
  text-align: center;
  font-family: var(--rebilly-fontFamily);
}

.rebilly-instruments-divider-s { padding: var(--rebilly-spacingS) 0; }
.rebilly-instruments-divider-xs { padding: var(--rebilly-spacingXs) 0; }

.rebilly-instruments-divider::before {
  background: var(--rebilly-colorMutedBorder);
  content: '';
  position: absolute;
  left: 0;
  top: 50%;
  width: 100%;
  height: 1px;
}

.rebilly-instruments-divider .rebilly-instruments-divider-label {
  color: var(--rebilly-colorMutedText);
  font-weight: var(--rebilly-fontWeightBase);
  padding: 0 var(--rebilly-spacingM);
  line-height: var(--rebilly-fontLineHeightS);
  background-color: var(--rebilly-colorBackground);
  font-size: var(--rebilly-fontSizeS);
  position: relative;
  display: inline-block;
}

/* Components. Icons
------------------------------------------------------------ */
.rebilly-instruments-icon {
  width: var(--rebilly-fontLineHeightBase);
  height: var(--rebilly-fontLineHeightBase);
  fill: var(--rebilly-colorText);
}

/* Components. Forms. Checkboxes
------------------------------------------------------------ */
.rebilly-instruments-form-field-checkbox {
  position: relative;
  opacity: 1;
  align-items: center;
  display: flex;
  flex-direction: row-reverse;
  justify-content: flex-start;
  cursor: pointer;
  transform: none;
}

.rebilly-instruments-form-field-checkbox > * {
  cursor: pointer;
}

.rebilly-instruments-form-field-checkbox input[type="checkbox"] {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

.rebilly-instruments-form-field-checkbox span {
  position: relative;
  top: 0;
  left: 0;
  width: calc(var(--rebilly-spacingM) - var(--rebilly-spacing2xs));
  height: calc(var(--rebilly-spacingM) - var(--rebilly-spacing2xs));
  min-width: calc(var(--rebilly-spacingM) - var(--rebilly-spacing2xs));
  border-radius: 4px;
  box-shadow: inset 0 0 0 2px var(--rebilly-colorMutedBorder);
  margin-right: var(--rebilly-spacingS);
  background-color: transparent;
  transition: all 200ms;
}

.rebilly-instruments-form-field-checkbox span:after {
  content: '';
  position: absolute;
  border: solid var(--rebilly-colorPrimary);
  width: calc(var(--rebilly-spacingXs) + var(--rebilly-spacing2xs));
  height: calc(var(--rebilly-spacingXs) - var(--rebilly-spacing2xs) + 2px);
  border-width: 2px 2px 0 0;
  border-radius: 2px;
  top: 50%;
  left: 50%;
  opacity: 0;
  transform: translateY(-60%) translateX(-50%) rotate(135deg);
  transition: all 0.2s ease;
}

.rebilly-instruments-form-field-checkbox input[type="checkbox"]:focus ~ span {
  box-shadow: inset 0 0 0 2px var(--rebilly-colorPrimary);
}

.rebilly-instruments-form-field-checkbox input[type="checkbox"]:checked ~ span {
  box-shadow: inset 0 0 0 2px var(--rebilly-colorPrimary);
}

.rebilly-instruments-form-field-checkbox input[type="checkbox"]:checked ~ span:after {
  opacity: 1;
}

.rebilly-instruments-form-field-checkbox input[type="checkbox"]:disabled ~ span {
  opacity: 0.6;
}

/* Vendor, Postmate
------------------------------------------------------------ */
.rebilly-instruments-iframe {
  border: none;
  width: 100%;
  height: 0;
  padding: 0;
}

.rebilly-instruments-iframe-overlay {
  top: -2px;
  left: -2px;
  width: calc(100vw + 2px);
  height: 100vh;
  min-height: calc(100vh + 4px);
  position: fixed;
  z-index: 99999999999999;
}

/* Views. Modal
------------------------------------------------------------ */
.rebilly-instruments-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  overflow-x: hidden;
  overflow-y: auto;
  z-index: 1055;
  padding: 30px;
  width:  100%;
  height: 100%;
  margin: 0;
  padding: 0;
  -webkit-transition: all 0.12s ease-in-out;
  transition: all 0.12s ease-in-out;
  background-color: rgba(0,0,0,0.7);
  opacity: 0
}

.rebilly-instruments-modal-overlay.is-visible {
  opacity: 1;
}

.rebilly-instruments-modal-container {
  -webkit-transition: all .24s ease-in-out;
  transition: all .24s ease-in-out;
  position: relative;
  max-width: 750px;
  background: var(--rebilly-colorBackground);
  margin: 50px auto 20px;
  -webkit-box-shadow: 0 19px 38px rgba(0,0,0,0.20), 0 15px 12px rgba(0,0,0,0.12);
          box-shadow: 0 19px 38px rgba(0,0,0,0.20), 0 15px 12px rgba(0,0,0,0.12);
  border-radius: 4px;
  -webkit-transform: translateY(-50px);
          transform: translateY(-50px);
  opacity: 0;
}

.rebilly-instruments-modal-container.is-visible {
  -webkit-transform: translateY(0);
          transform: translateY(0);
  opacity: 1;
}

.rebilly-instruments-modal-container.is-redirect {
  max-width: 60vw;
  width: auto;
}

.rebilly-instruments-modal-content {
  -webkit-transition: all .15s;
  transition: all .15s;
  padding: 20px;
  overflow: hidden;
  background-color: var(--rebilly-colorBackground);
  text-align: center;
  border-radius: 4px;
}

.rebilly-instruments-modal-content .rebilly-instruments-iframe {
  -webkit-transition: all .15s;
  transition: all .15s;
  height: auto;
  min-height: 360px;
}

.rebilly-instruments-modal-container.is-redirect .rebilly-instruments-modal-content {
  padding: 0;
}

.rebilly-instruments-modal-close {
  position: absolute;
  width: 30px;
  height: 30px;
  top: -40px;
  right: 0;
  fill: #FFF;
  cursor: pointer;
}

.rebilly-instruments-modal-close:hover{
  color: #000;
}

.rebilly-instruments-confirmation-modal-container {
    width: 350px;
    margin: var(--rebilly-spacingL) auto;
    padding: var(--rebilly-spacingM);
    font-size: var(--rebilly-fontSizeBase);
    font-family: var(--rebilly-fontFamily);
}

.rebilly-instruments-confirmation-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: var(--rebilly-fontWeight600);
    line-height: var(--rebilly-fontLineHeightBase);
    margin-bottom: var(--rebilly-spacingM);
}

.rebilly-instruments-confirmation-modal-content {
    text-align: left !important;
    padding: 0 !important;
    line-height: var(--rebilly-fontLineHeightBase);
}

.rebilly-instruments-confirmation-modal-actions {
    display: flex;
    justify-content: flex-end;
    align-items: baseline;
    line-height: var(--rebilly-fontLineHeightBase);
}

.rebilly-instruments-confirmation-modal-actions .rebilly-instruments-confirmation-modal-confirm {
    margin-left: var(--rebilly-spacingS);
}

@media screen and (max-width: 480px) {
  .rebilly-instruments-modal-container.is-redirect {
    max-width: 96vw;
    margin: 20px auto 20px;
  }
}

/* Components. Loader
------------------------------------------------------------ */
.rebilly-instruments-loader {
  text-align: left;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  display: none;
  background-color: var(--rebilly-colorBackground);
  z-index: 1000;
  -webkit-transition: all 200ms;
  transition: all 200ms;
  border-radius: var(--rebilly-borderRadius);
}

.rebilly-instruments-loader.is-active {
  display: block;
}

/* Type */
.rebilly-instruments-loader p {
  color: var(--rebilly-colorText);
  display: inline-block;
  margin: 0;
  font-weight: var(--rebilly-fontWeightBase);
  font-size: var(--rebilly-fontSizeBase);
  line-height: var(--rebilly-fontLineHeightBase);
}

.rebilly-instruments-loader small {
  color: var(--rebilly-colorText);
  display: inline-block;
  margin: 0;
  font-size: var(--rebilly-fontSizeS);
  line-height: 1;
}

/* Summary */
.rebilly-instruments-summary-loader-total p.total {
  font-family: var(--rebilly-fontFamily);
  font-size: var(--rebilly-fontSizeL);
  font-weight: var(--rebilly-headingFontWeight);
}

/* Methods */
.rebilly-instruments-methods-loader-card-icon {
  width: calc(var(--rebilly-fontLineHeightBase) + 10px);
  height: var(--rebilly-fontLineHeightBase);
  margin-left: var(--rebilly-spacing2xs);
  margin-bottom: var(--rebilly-spacing2xs);
}

.rebilly-instruments-methods-loader-form-fields { margin: calc(var(--rebilly-spacingXs) + var(--rebilly-spacingS)) 0; }

/* Spinner */
.rebilly-instruments-loader-spinner {
  top: 50%;
  left: 50%;
  position: absolute;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  border: 2px solid transparent;
  border-top: 2px solid var(--rebilly-colorPrimary);
  border-radius: 50%;
  width: var(--rebilly-fontLineHeightBase);
  height: var(--rebilly-fontLineHeightBase);
  margin-top: calc(-1 * var(--rebilly-fontLineHeightBase) / 2);
  margin-left: calc(-1 * var(--rebilly-fontLineHeightBase) / 2);
  -webkit-animation: spin 0.5s ease infinite;
          animation: spin 0.5s ease infinite;
}

@-webkit-keyframes spin {
  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
}

@keyframes spin {
  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
}

/* Utils */
.rebilly-instruments-loader-display-flex { display: -webkit-box; display: -ms-flexbox; display: flex; }
.rebilly-instruments-loader-align-center { -webkit-box-align: center; -ms-flex-align: center; align-items: center; }
.rebilly-instruments-loader-justify-space-between { -webkit-box-pack: justify; -ms-flex-pack: justify; justify-content: space-between; }
.rebilly-instruments-loader-justify-end { -webkit-box-pack: end; -ms-flex-pack: end; justify-content: flex-end; }

.is-el-loading {
  position: relative;
  color: transparent!important;
}

.is-el-loading::before {
  position: absolute;
  content: '';
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(110deg, var(--rebilly-colorMutedBorder) 0%, var(--rebilly-colorBackground) 25%, var(--rebilly-colorMutedBorder) 50%);
  background-size: 200% 100%;
  -webkit-animation: 1.5s rebillyExpressShine linear infinite;
          animation: 1.5s rebillyExpressShine linear infinite;
  border-radius: var(--rebilly-borderRadius);
}

.rebilly-instruments-loader-form-el {
  width: 100%;
  min-height: var(--rebilly-spacingFormElementMinHeight);
}

.rebilly-instruments-loader-form-label {
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  margin-bottom: var(--rebilly-spacing2xs);
}

.rebilly-instruments-loader-form-el.is-button {
  margin-top: var(--rebilly-spacingL);
  text-align: center;
  font-size: var(--rebilly-buttonFontSize);
  font-family: var(--rebilly-buttonFontFamily);
  line-height: var(--rebilly-buttonFontLineHeight);
  padding: var(--rebilly-spacingS);
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  background: var(--rebilly-buttonColorBackground);
  color: transparent;
  border-radius: var(--rebilly-buttonBorderRadius);
  font-weight: var(--rebilly-buttonFontWeight);
  border: var(--rebilly-buttonBorder);
  -webkit-box-shadow: var(--rebilly-buttonBoxShadow);
          box-shadow: var(--rebilly-buttonBoxShadow);
  outline: none;
  cursor: not-allowed;
  opacity: 0.6; 
}

.rebilly-instruments-methods-loader-card-icon.is-el-loading::before {
  border-radius: calc(var(--rebilly-borderRadius) / 2);
}

/* Error
------------------------------------------------------------ */
.rebilly-instruments-error-card {
  border: 1px solid var(--rebilly-colorDanger);
  border-radius: var(--rebilly-borderRadius);
  text-align: left;
  padding: var(--rebilly-spacingS);
  margin-bottom: var(--rebilly-spacingL);
}
.rebilly-instruments-error-card.not-closeable {
  margin-bottom: 0;
}

.rebilly-instruments-error-card-header {
  display: -webkit-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-align: center;
      -ms-flex-align: center;
          align-items: center;
  -webkit-box-pack: justify;
      -ms-flex-pack: justify;
          justify-content: space-between;
  width: 100%;
  -webkit-box-align: start;
      -ms-flex-align: start;
          align-items: flex-start;
}

.rebilly-instruments-error-card-title {
  font-weight: var(--rebilly-fontWeightBase);
  font-size: var(--rebilly-fontSizeBase);
  line-height: var(--rebilly-fontLineHeightBase);
  font-family: var(--rebilly-headingFontFamily);
  margin: 0 0 var(--rebilly-spacingS);
  color: var(--rebilly-colorDanger);
}

.rebilly-instruments-error-card-close-button {
  cursor: pointer;
  background: transparent;
  border: none;
  padding: 0;
}

.rebilly-instruments-error-card-close-button svg {
  width: var(--rebilly-fontLineHeightBase);
  height: var(--rebilly-fontLineHeightBase);
  fill: var(--rebilly-colorText);
}

.rebilly-instruments-error-card-details {
  padding: 0;
  margin: 0;
  list-style: none;
}

.rebilly-instruments-error-card-details li,
.rebilly-instruments-error-card-message {
  color: var(--rebilly-colorText);
  margin: 0;
  font-weight: var(--rebilly-fontWeightBase);
  font-size: var(--rebilly-fontSizeBase);
  line-height: var(--rebilly-fontLineHeightBase);
}

/* Components. Button
------------------------------------------------------------ */
.rebilly-instruments-button {
    font-size: var(--rebilly-buttonFontSize);
    font-family: var(--rebilly-buttonFontFamily);
    line-height: var(--rebilly-buttonFontLineHeight);
    padding: var(--rebilly-spacingS);
    box-sizing: border-box;
    background: var(--rebilly-buttonColorBackground);
    color: var(--rebilly-buttonColorText);
    border-radius: var(--rebilly-buttonBorderRadius);
    font-weight: var(--rebilly-buttonFontWeight);
    border: var(--rebilly-buttonBorder);
    box-shadow: var(--rebilly-buttonBoxShadow);
    margin: calc(var(--rebilly-spacing2xs) + var(--rebilly-spacingS) / 2) 0;
    width: 100%;
    cursor: pointer;
    min-height: 44px;
    transition: all 0.2s ease;
    outline: none;
}

.rebilly-instruments-button:not([disabled]):hover {
    background: var(--rebilly-buttonHoverColorBackground);
    color: var(--rebilly-buttonHoverColorText);
    font-family: var(--rebilly-buttonHoverFontFamily);
    font-size: var(--rebilly-buttonHoverFontSize);
    line-height: var(--rebilly-buttonHoverFontLineHeight);
    font-weight: var(--rebilly-buttonHoverFontWeight);
    border: var(--rebilly-buttonHoverBorder);
    border-radius: var(--rebilly-buttonHoverBorderRadius);
    box-shadow: var(--rebilly-buttonHoverBoxShadow);
}

.rebilly-instruments-button:not([disabled]):active {
    background: var(--rebilly-buttonActiveColorBackground);
    color: var(--rebilly-buttonActiveColorText);
    font-family: var(--rebilly-buttonActiveFontFamily);
    font-size: var(--rebilly-buttonActiveFontSize);
    line-height: var(--rebilly-buttonActiveFontLineHeight);
    font-weight: var(--rebilly-buttonActiveFontWeight);
    border: var(--rebilly-buttonActiveBorder);
    border-radius: var(--rebilly-buttonActiveBorderRadius);
    box-shadow: var(--rebilly-buttonActiveBoxShadow);
}

.rebilly-instruments-button.rebilly-instruments-button-secondary {
    font-size: var(--rebilly-buttonSecondaryFontSize);
    font-family: var(--rebilly-buttonSecondaryFontFamily);
    line-height: var(--rebilly-buttonSecondaryFontLineHeight);
    background: var(--rebilly-buttonSecondaryColorBackground);
    color: var(--rebilly-buttonSecondaryColorText);
    border: var(--rebilly-buttonSecondaryBorder);
    box-shadow: var(--rebilly-buttonSecondaryBoxShadow);
}

.rebilly-instruments-button.rebilly-instruments-button-secondary:not(
        [disabled]
    ):hover {
    font-size: var(--rebilly-buttonSecondaryHoverFontSize);
    font-family: var(--rebilly-buttonSecondaryHoverFontFamily);
    line-height: var(--rebilly-buttonSecondaryHoverFontLineHeight);
    background: var(--rebilly-buttonSecondaryHoverColorBackground);
    color: var(--rebilly-buttonSecondaryHoverColorText);
    border: var(--rebilly-buttonSecondaryHoverBorder);
    box-shadow: var(--rebilly-buttonSecondaryHoverBoxShadow);
}

.rebilly-instruments-button.rebilly-instruments-button-secondary:not(
        [disabled]
    ):active {
    font-size: var(--rebilly-buttonSecondaryActiveFontSize);
    font-family: var(--rebilly-buttonSecondaryActiveFontFamily);
    line-height: var(--rebilly-buttonSecondaryActiveFontLineHeight);
    background: var(--rebilly-buttonSecondaryActiveColorBackground);
    color: var(--rebilly-buttonSecondaryActiveColorText);
    border: var(--rebilly-buttonSecondaryActiveBorder);
    box-shadow: var(--rebilly-buttonSecondaryActiveBoxShadow);
}

.rebilly-instruments-button:focus {
    box-shadow: none;
}

.rebilly-instruments-button:disabled,
.rebilly-instruments-button:disabled:hover {
    cursor: not-allowed;
    opacity: 0.6;
}

.rebilly-instruments-button::first-letter {
    text-transform: uppercase;
}

.rebilly-instruments-button:first-of-type {
    margin-top: var(--rebilly-spacingL);
}

.rebilly-instruments-button:last-of-type {
    margin-bottom: 0;
}

.rebilly-instruments-button-group {
    display: flex;
    align-items: stretch;
    margin-top: var(--rebilly-spacingL);
}

.rebilly-instruments-button-group .rebilly-instruments-button {
    margin: 0 var(--rebilly-spacingXs);
}

.rebilly-instruments-button-group .rebilly-instruments-button:first-of-type {
    margin-left: 0;
}

.rebilly-instruments-button-group .rebilly-instruments-button:last-of-type {
    margin-right: 0;
}

@media screen and (max-width: 480px) {
    .rebilly-instruments-button-group {
        flex-direction: column-reverse;
    }

    .rebilly-instruments-button-group
        .rebilly-instruments-button:first-of-type {
        margin: 0;
    }

    .rebilly-instruments-button-group .rebilly-instruments-button:last-of-type {
        margin: 0;
    }

    .rebilly-instruments-button-group
        .rebilly-instruments-button
        + .rebilly-instruments-button {
        margin-bottom: var(--rebilly-spacingS);
    }
}

.rebilly-instruments-button-transparent {
    border: none;
    background: transparent;
    cursor: pointer;
    color: inherit;
    font: inherit;
}



/* Bump offer
------------------------------------------------------------ */
.rebilly-instruments-bump-offers {
  text-align: left;
  margin-bottom: calc(var(--rebilly-spacingM) + var(--rebilly-fontSizeS));
}

.rebilly-instruments-bump-offers .rebilly-instruments-form-field-checkbox {
  margin-bottom: var(--rebilly-spacingS);
}

.rebilly-instruments-bump-offers .rebilly-instruments-bump-offer-label {
  width: 100%;
  font-weight: var(--rebilly-fontWeightBase);
}

.rebilly-instruments-bump-offer-line-item {
  border-bottom: 1px solid var(--rebilly-colorMutedBorder);
  padding: var(--rebilly-spacingS) 0;
  display: flex;
  align-items: center;
  position: relative;
}

.rebilly-instruments-bump-offer-line-item:first-child {
  padding-top: 0;
}

.rebilly-instruments-bump-offer-line-item-figure {
  margin: 0 var(--rebilly-spacingS) 0 0;
  flex: 0 0 auto;
  width: 48px;
  height: 48px;
  border-radius: var(--rebilly-borderRadius);
  border: 1px solid var(--rebilly-colorMutedBorder);
  overflow: hidden;
}

.rebilly-instruments-bump-offer-line-item-figure img {
  width: 100%;
}

.rebilly-instruments-bump-offer-line-item-synopsis {
  flex: 1 2 auto;
  font-weight: var(--rebilly-fontWeightBase);
}

.rebilly-instruments-bump-offer-line-item-synopsis-title {
  margin: 0;
}

.rebilly-instruments-bump-offer-line-item-synopsis-description {
  color: var(--rebilly-colorMutedText);
  margin: 0;
  font-size: var(--rebilly-fontSizeS);
  line-height: var(--rebilly-fontLineHeightS);
}

.rebilly-instruments-bump-offer-line-item-price-breakdown {
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--rebilly-colorMutedText);
  margin: 0 0 0 var(--rebilly-spacingS);
  font-weight: var(--rebilly-fontWeightBase);
}

.rebilly-instruments-bump-offer-line-item-price-breakdown .rebilly-instruments-icon {
  fill: var(--rebilly-colorMutedText);
}

.rebilly-instruments-bump-offer-line-item-price-breakdown-unit-price {
  color: var(--rebilly-colorText);
}
`;
const mainStyleVars = (themeOverride) => {
  const resolvedTheme = new Theme(themeOverride).build();
  const style = `
    ${vars(resolvedTheme)}
    `;
  return style;
};
function minifyCss(_content) {
  let content2 = _content;
  content2 = content2.replace(/\/\*(?:(?!\*\/)[\s\S])*\*\/|[\r\n\t]+/g, "");
  content2 = content2.replace(/\s{2,}/g, " ");
  content2 = content2.replace(/\s([{:}])\s/g, "$1");
  content2 = content2.replace(/([;,])\s/g, "$1");
  content2 = content2.replace(/\s!/g, "!");
  return content2;
}
const setupStylesVars = () => {
  validateOptions$1(state.options);
  const { theme: theme2 = {}, css } = state.options;
  const styleVars = mainStyleVars(theme2 || {});
  addDOMElement({
    element: "style",
    attributes: { type: "text/css" },
    content: minifyCss(styleVars),
    target: state.shadowRoot || "head"
  });
  if (css) {
    addDOMElement({
      element: "style",
      attributes: { type: "text/css" },
      content: minifyCss(css),
      target: state.shadowRoot || "head"
    });
  }
  return styleVars;
};
const triggerTranslations = () => {
  var _a, _b;
  state.translate.init((_a = state.options) == null ? void 0 : _a.locale, (_b = state.options) == null ? void 0 : _b.i18n);
  state.translate.translateItems();
};
const setupI18n = () => {
  var _a, _b, _c, _d, _e2, _f;
  if (((_a = state.options) == null ? void 0 : _a.locale) === "auto" && ((_d = (_c = (_b = state.data) == null ? void 0 : _b.riskMetadata) == null ? void 0 : _c.browserData) == null ? void 0 : _d.language)) {
    const {
      browserData: { language }
    } = state.data.riskMetadata;
    state.options.locale = language;
  }
  state.translate.init((_e2 = state.options) == null ? void 0 : _e2.locale, (_f = state.options) == null ? void 0 : _f.i18n);
  return triggerTranslations;
};
function processCSS(rawCss) {
  const cssMap = {};
  Array.from(rawCss.matchAll(/(--rebilly.*(?=:))[:\s](.*(?=;))/g)).forEach(
    (item) => {
      cssMap[item[1]] = item[2].trim();
    }
  );
  function parseValue(value) {
    const cssVariables = value.match(/var\((.+?)\)/g);
    if (cssVariables) {
      let cssValue = value;
      cssVariables.forEach((variable) => {
        const cssVar = variable.match(/\((.*)\)/i);
        if (cssVar) {
          cssValue = value.replace(variable, cssMap[cssVar[1]]);
        }
      });
      return parseValue(cssValue);
    }
    return value;
  }
  return Object.entries(cssMap).map(([key, value]) => [
    key,
    parseValue(value)
  ]);
}
function replaceCssVars(rawCss) {
  const CssVarsObj = {};
  processCSS(rawCss).forEach(([key, value]) => {
    CssVarsObj[key] = value;
  });
  return CssVarsObj;
}
const getStyleProps = (obj, particle = "") => {
  const output = {
    color: obj[`--rebilly-${particle}ColorText`],
    fontFamily: obj[`--rebilly-${particle}FontFamily`],
    fontSize: obj[`--rebilly-${particle}FontSize`],
    fontWeight: obj[`--rebilly-${particle}FontWeight`],
    lineHeight: obj[`--rebilly-${particle}FontLineHeight`],
    background: obj[`--rebilly-${particle}ColorBackground`],
    boxShadow: obj[`--rebilly-${particle}BoxShadow`],
    borderColor: obj[`--rebilly-${particle}BorderColor`],
    borderWidth: obj[`--rebilly-${particle}BorderWidth`],
    borderType: obj[`--rebilly-${particle}BorderType`]
  };
  return output;
};
const setupFramepayTheme = () => {
  var _a;
  const fullCss = `
    ${state.mainStyleVars}
    ${((_a = state.options) == null ? void 0 : _a.css) || ""}
  `;
  const resolvedCssVarsObj = replaceCssVars(fullCss);
  const framepayStyle = {
    base: {
      ...getStyleProps(resolvedCssVarsObj, "input"),
      ":hover": getStyleProps(resolvedCssVarsObj, "inputHover"),
      ":focus": getStyleProps(resolvedCssVarsObj, "inputFocus"),
      "::placeholder": getStyleProps(
        resolvedCssVarsObj,
        "inputPlaceholder"
      ),
      "::selection": getStyleProps(resolvedCssVarsObj, "inputSelection")
    },
    invalid: {
      ...getStyleProps(resolvedCssVarsObj, "inputError"),
      ":hover": getStyleProps(resolvedCssVarsObj, "inputErrorHover"),
      ":focus": getStyleProps(resolvedCssVarsObj, "inputErrorFocus"),
      "::placeholder": getStyleProps(
        resolvedCssVarsObj,
        "inputErrorPlaceholder"
      ),
      "::selection": getStyleProps(
        resolvedCssVarsObj,
        "inputErrorSelection"
      )
    },
    buttons: {
      base: {
        ...getStyleProps(resolvedCssVarsObj, "buttonSecondary"),
        ":hover": getStyleProps(
          resolvedCssVarsObj,
          "buttonSecondaryHover"
        ),
        ":focus": getStyleProps(
          resolvedCssVarsObj,
          "buttonSecondaryActive"
        )
      },
      focus: {
        ...getStyleProps(resolvedCssVarsObj, "buttonSecondary")
      },
      active: {
        ...getStyleProps(resolvedCssVarsObj, "button"),
        ":hover": getStyleProps(resolvedCssVarsObj, "buttonHover"),
        ":focus": getStyleProps(resolvedCssVarsObj, "buttonActive")
      }
    }
  };
  return framepayStyle;
};
function on({ eventName, callback }) {
  if (!publicEventNames.includes(eventName)) {
    throw new Error(`${eventName} is not a supported event`);
  }
  const internalEventName = camelCase$1(eventName);
  events[internalEventName].addEventListener(callback);
}
const modalTemplate = (isRedirect, method) => `
  <div class="rebilly-instruments-modal-overlay">
    <div class="rebilly-instruments-modal-container ${method ? `rebilly-instruments-${method}` : ""} ${isRedirect ? "is-redirect" : ""}">
      ${isRedirect ? "" : `
      <svg class="rebilly-instruments-modal-close" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
        <path d="m15 13.5858 7.2929-7.293c.3905-.3904 1.0237-.3904 1.4142 0 .3905.3906.3905 1.0238 0 1.4143L16.4142 15l7.293 7.2929c.3904.3905.3904 1.0237 0 1.4142-.3906.3905-1.0238.3905-1.4143 0L15 16.4142l-7.2929 7.293c-.3905.3904-1.0237.3904-1.4142 0-.3905-.3906-.3905-1.0238 0-1.4143L13.5858 15l-7.293-7.2929c-.3904-.3905-.3904-1.0237 0-1.4142.3906-.3905 1.0238-.3905 1.4143 0L15 13.5858Z" fill-rule="nonzero"/>
      </svg>
      `}
      <div class="rebilly-instruments-modal-content"></div>
    </div>
  </div>
`;
async function mountModal({
  name = "",
  url = "",
  model = {},
  classListArray = [],
  close = () => void 0
} = {}) {
  var _a, _b;
  const method = (_a = model == null ? void 0 : model.method) == null ? void 0 : _a.method;
  const isRedirect = name === "rebilly-instruments-approval-url";
  state.form.insertAdjacentHTML(
    "beforeend",
    modalTemplate(isRedirect, method)
  );
  const modalOverlay = state.form.querySelector(
    ".rebilly-instruments-modal-overlay"
  );
  const modalContainer = state.form.querySelector(
    ".rebilly-instruments-modal-container"
  );
  const closeButton = state.form.querySelector(
    ".rebilly-instruments-modal-close"
  );
  const modalContent = state.form.querySelector(
    ".rebilly-instruments-modal-content"
  );
  document.body.style.overflow = "hidden";
  setTimeout(() => {
    modalOverlay.classList.add("is-visible");
    modalContainer.classList.add("is-visible");
  }, 240);
  state.loader.addDOMElement({ section: "modal", el: modalContent });
  state.loader.startLoading({ section: "modal", id: name });
  const modelSafeState = state.toModel();
  const injectedModel = {
    options: modelSafeState.options,
    ...model
  };
  const iframe = await new ModalIframe2({
    name,
    url,
    model: injectedModel,
    classListArray,
    container: modalContent
  });
  const closeModal = (...args) => {
    modalContainer.classList.remove("is-visible");
    modalOverlay.classList.remove("is-visible");
    setTimeout(() => {
      document.body.style.overflow = "auto";
      const list = modalOverlay.children;
      for (let i = 0; i < list.length; i += 1) {
        list[i].remove();
      }
      modalOverlay.remove();
      close(...args);
      iframe.destroy();
    }, 300);
  };
  iframe.bindEventListeners({
    close: closeModal,
    loader: state.loader
  });
  if (!isRedirect) {
    closeButton.addEventListener("click", closeModal);
  }
  (_b = iframe.component) == null ? void 0 : _b.call("route", {
    name: "approval-url"
  });
  return iframe;
}
function handleApprovalUrl({ fields, payload }) {
  var _a, _b, _c, _d, _e2;
  if (state.options.features.fullPageRedirect && (payload.redirectUrl || ((_a = fields.transaction) == null ? void 0 : _a.approvalUrl))) {
    window.location = payload.redirectUrl || ((_b = fields.transaction) == null ? void 0 : _b.approvalUrl);
    return;
  }
  if (payload.redirectUrl || !((_c = fields.transaction) == null ? void 0 : _c.approvalUrl)) {
    const { paymentMethodsUrl } = state.options._computed;
    const modelSafeFields = JSON.parse(JSON.stringify(fields));
    const model = {};
    if (state.data.isPayment) {
      model.payment = modelSafeFields;
    } else {
      model.purchase = modelSafeFields;
    }
    state.data = new DataInstance({ ...fields });
    const name = "rebilly-instruments-approval-url";
    mountModal({
      name,
      url: `${paymentMethodsUrl}?name=${name}`,
      model,
      close: (updatedPurchase) => {
        events.purchaseCompleted.dispatch(updatedPurchase);
      }
    });
  } else if ((_d = fields.transaction) == null ? void 0 : _d.approvalUrl) {
    window.location = (_e2 = fields.transaction) == null ? void 0 : _e2.approvalUrl;
  }
}
async function postPurchase({ data }) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    const purchaseSchemaKeys = [
      "websiteId",
      "paymentInstruction",
      "items",
      "billingAddress",
      "deliveryAddress",
      "shippingRateId",
      "couponIds",
      "password",
      "redirectUrl",
      "poNumber"
    ];
    Object.keys(data).forEach((key) => {
      if (!purchaseSchemaKeys.includes(key)) {
        delete data[key];
      }
    });
    return state.storefront.purchase.purchase({ data });
  });
}
async function postPayment({ data }) {
  return Endpoint(async () => {
    validateStorefront(state.storefront);
    const {
      token,
      transactionId,
      invoiceId,
      websiteId,
      paymentInstrumentId
    } = data;
    const purchaseSchemaKeys = ["riskMetadata", "redirectUrl"];
    if (token) {
      purchaseSchemaKeys.push("token");
    }
    if (paymentInstrumentId) {
      purchaseSchemaKeys.push("paymentInstrumentId");
    }
    if (transactionId) {
      purchaseSchemaKeys.push("transactionId");
    }
    if (invoiceId) {
      purchaseSchemaKeys.push("invoiceId");
    }
    if (websiteId) {
      purchaseSchemaKeys.push("amount", "currency", "websiteId");
    }
    Object.keys(data).forEach((key) => {
      if (!purchaseSchemaKeys.includes(key)) {
        delete data[key];
      }
    });
    return state.storefront.purchase.payment({ data });
  });
}
async function makePurchase({ payload }) {
  let data = {
    websiteId: state.options.websiteId,
    paymentInstruction: {
      token: payload._raw.id
    },
    ...payload
  };
  if (state.data.acceptBumpOffer) {
    data.items = state.options.bumpOffer;
  } else {
    data.items = mapItemsQuantities(state.options.items);
  }
  if (state.data.couponIds && Array.isArray(state.data.couponIds)) {
    data.couponIds = state.data.couponIds;
  }
  if (state.options.addons && state.data.addons && Array.isArray(state.data.addons)) {
    state.options.addons.forEach((addon) => {
      if (state.data.addons.includes(addon.planId)) {
        data.items.push(addon);
      }
    });
  }
  if (data.additionalFields) {
    data = {
      ...data,
      ...data.additionalFields
    };
  }
  const { fields } = await postPurchase({ data });
  return fields;
}
async function makePayment({ payload }) {
  var _a, _b, _c, _d, _e2, _f;
  const {
    _raw: { id: id2 },
    isExistingInstrument
  } = payload;
  delete payload.isExistingInstrument;
  delete payload._raw;
  const data = {
    ...payload
  };
  if (isExistingInstrument) {
    data.paymentInstrumentId = id2;
  } else {
    data.token = id2;
  }
  if ((_a = state.options) == null ? void 0 : _a.invoiceId) {
    data.invoiceId = state.options.invoiceId;
  }
  if ((_b = state.options) == null ? void 0 : _b.transactionId) {
    data.transactionId = state.options.transactionId;
  }
  if ((_c = state.options) == null ? void 0 : _c.money) {
    data.websiteId = state.options.websiteId;
    data.amount = state.options.money.amount;
    data.currency = state.options.money.currency;
  }
  if ((_d = state.options) == null ? void 0 : _d.deposit) {
    data.websiteId = state.options.websiteId;
    data.amount = state.data.amountAndCurrency.amount;
    data.currency = state.data.amountAndCurrency.currency;
  }
  if (((_e2 = state.data) == null ? void 0 : _e2.couponIds) && Array.isArray(state.data.couponIds)) {
    data.couponIds = state.data.couponIds;
  }
  if ((_f = state.data) == null ? void 0 : _f.riskMetadata) {
    data.riskMetadata = state.data.riskMetadata;
  }
  let { fields } = await postPayment({ data });
  fields = {
    transaction: fields,
    token: fields.token || state.options.jwt
  };
  if (state.data.invoice) {
    fields.invoice = state.data.invoice;
  }
  return fields;
}
async function makePayout({
  payload: {
    isExistingInstrument,
    _raw: { id: paymentInstrumentId }
  }
}) {
  if (!isExistingInstrument) {
    const { id: newPaymentInstrumentId } = await createPaymentInstrument({
      data: { token: paymentInstrumentId }
    });
    paymentInstrumentId = newPaymentInstrumentId;
  }
  const payoutRequest = await updatePayoutRequest({
    id: state.data.payout.id,
    data: {
      paymentInstrumentId
    }
  });
  return payoutRequest;
}
async function purchase({ payload }) {
  var _a, _b;
  Object.keys(payload).forEach((key) => {
    if (payload[key] === null) {
      delete payload[key];
    }
  });
  try {
    let fields;
    let completedEvent;
    let flow;
    if (state.options.payout) {
      fields = await makePayout({ payload });
      completedEvent = events.payoutCompleted;
      flow = "payout";
    } else if (state.data.isPayment) {
      fields = await makePayment({ payload });
      completedEvent = events.purchaseCompleted;
      flow = "payment";
    } else {
      fields = await makePurchase({ payload });
      completedEvent = events.purchaseCompleted;
      flow = "purchase";
    }
    if (((_a = fields.transaction) == null ? void 0 : _a.approvalUrl) && ((_b = fields.transaction) == null ? void 0 : _b.result) === "unknown") {
      if (state.options.features.fullPageRedirect) {
        window.location = fields.transaction.approvalUrl;
      } else {
        handleApprovalUrl({ fields, payload });
      }
    } else if (flow !== "payout" && fields.selectedPaymentInstrumentRedirectUrl) {
      window.location = fields.selectedPaymentInstrumentRedirectUrl;
    } else {
      completedEvent.dispatch(fields);
    }
  } catch (error2) {
    showError(error2);
    return error2;
  }
}
async function setup({ payload }) {
  var _a;
  try {
    const {
      _raw: { id: id2 },
      isExistingInstrument
    } = payload;
    delete payload.isExistingInstrument;
    delete payload._raw;
    const data = {
      ...payload
    };
    if (isExistingInstrument) {
      data.paymentInstrumentId = id2;
    } else {
      data.token = id2;
    }
    const { instrument, transaction } = await setupPaymentInstrument({
      data: {
        websiteId: (_a = state.options) == null ? void 0 : _a.websiteId,
        ...data
      }
    });
    state.data = new DataInstance({ instrument, transaction });
    if (transaction.approvalUrl && transaction.result === "unknown") {
      if (state.options.features.fullPageRedirect) {
        window.location = transaction.approvalUrl;
      } else {
        const { paymentMethodsUrl } = state.options._computed;
        mountModal({
          name: "rebilly-instruments-approval-url",
          url: `${paymentMethodsUrl}/approval-url`,
          model: {
            setup: { transaction }
          },
          close: ({
            transaction: updatedTransaction = transaction
          }) => {
            events.setupCompleted.dispatch({
              instrument,
              transaction: updatedTransaction
            });
          }
        });
      }
    } else {
      events.setupCompleted.dispatch({ instrument, transaction });
    }
    return { instrument, transaction };
  } catch (error2) {
    showError(error2, false);
    return error2;
  }
}
async function mountConfirmation({ payload: instrument }) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  if (instrument.billingAddress && state.summary && state.data.isPurchase) {
    updateSummary({ instrument });
  }
  const iframe = iframes.form;
  if (!iframe) {
    await mountForm();
  }
  const modelSafeState = state.toModel();
  const model = {
    options: modelSafeState.options,
    data: modelSafeState.data,
    instrument
  };
  (_a = iframe == null ? void 0 : iframe.component) == null ? void 0 : _a.call("update", model);
  (_b = iframe == null ? void 0 : iframe.component) == null ? void 0 : _b.call("route", {
    name: "confirmation"
  });
  if (!((_d = (_c = iframe == null ? void 0 : iframe.component) == null ? void 0 : _c.events) == null ? void 0 : _d[`${iframe.name}-confirm-purchase`])) {
    (_e2 = iframe == null ? void 0 : iframe.component) == null ? void 0 : _e2.on(
      `${iframe.name}-confirm-purchase`,
      (confirmedInstrument) => {
        purchase({ payload: confirmedInstrument });
      }
    );
  }
  if (!((_g = (_f = iframe == null ? void 0 : iframe.component) == null ? void 0 : _f.events) == null ? void 0 : _g[`${iframe.name}-confirm-setup`])) {
    (_h = iframe == null ? void 0 : iframe.component) == null ? void 0 : _h.on(
      `${iframe.name}-confirm-setup`,
      (confirmedInstrument) => {
        setup({ payload: confirmedInstrument });
      }
    );
  }
}
async function mountResult({ payload }) {
  var _a, _b;
  const iframe = iframes.form;
  if (!iframe) {
    await mountForm();
  }
  const modelSafeState = state.toModel();
  const model = {
    data: modelSafeState.data,
    options: modelSafeState.options
  };
  if (state.data.payout) {
    model.payoutRequest = payload;
  } else {
    model[state.options.transactionType] = payload;
  }
  (_a = iframe == null ? void 0 : iframe.component) == null ? void 0 : _a.call("route", {
    name: "result"
  });
  (_b = iframe == null ? void 0 : iframe.component) == null ? void 0 : _b.call("update", model);
}
async function show({ componentName, payload }) {
  switch (componentName) {
    case "result":
      hideExtraUI();
      mountResult({ payload });
      break;
    case "confirmation":
      hideExtraUI();
      mountConfirmation({ payload });
      break;
    default:
      throw new Error(`'${componentName}' not a supported component`);
  }
}
function showResult({ payload }) {
  show({
    componentName: "result",
    payload
  });
}
const setupUserFlow = ({ state: state2 = {} }) => {
  var _a, _b, _c, _d;
  if (!((_b = (_a = state2 == null ? void 0 : state2.options) == null ? void 0 : _a.features) == null ? void 0 : _b.hideConfirmation)) {
    on({
      eventName: "instrument-ready",
      callback: (payload) => {
        var _a2, _b2, _c2, _d2;
        if (((_a2 = payload._raw) == null ? void 0 : _a2.method) === "paypal") {
          if (!((_b2 = state2.data) == null ? void 0 : _b2.isShippingRequired)) {
            if (((_c2 = state2.options) == null ? void 0 : _c2.transactionType) === "setup") {
              setup({ payload });
            } else {
              purchase({ payload });
            }
            (_d2 = state2.loader) == null ? void 0 : _d2.startLoading({
              id: "express-purchase"
            });
            return;
          }
        }
        show({
          componentName: "confirmation",
          payload
        });
      }
    });
  }
  if (!((_d = (_c = state2 == null ? void 0 : state2.options) == null ? void 0 : _c.features) == null ? void 0 : _d.hideResult)) {
    on({
      eventName: "payout-completed",
      callback: (payload) => {
        payload = JSON.parse(JSON.stringify(payload));
        showResult({ payload });
      }
    });
    on({
      eventName: "purchase-completed",
      callback: (payload) => {
        payload = JSON.parse(JSON.stringify(payload));
        showResult({ payload });
      }
    });
    on({
      eventName: "setup-completed",
      callback: (payload) => {
        payload = JSON.parse(JSON.stringify(payload));
        showResult({ payload });
      }
    });
  }
};
function getShadowParent(element) {
  if (element.getRootNode() instanceof ShadowRoot) {
    return element.getRootNode();
  }
  return null;
}
async function mount({
  setupFramepay: setupFramepay$1 = setupFramepay,
  ...options
} = {}) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s2, _t3;
  try {
    state.data = {};
    state.options = {};
    state.options = setupOptions({ options });
    state.form = setupElement({ element: "form" });
    state.summary = setupElement({ element: "summary" });
    state.shadowRoot = getShadowParent(state.form);
    if (state.form) {
      state.form.style.maxWidth = "750px";
    }
    if (state.summary) {
      state.summary.style.maxWidth = "750px";
    }
    state.storefront = setupStorefront();
    state.mainStyleVars = setupStylesVars();
    if (state.options) {
      state.options.themeFramepay = setupFramepayTheme();
    }
    state.loader.addDOMElement({ el: state.form });
    state.loader.addDOMElement({ section: "summary", el: state.summary });
    state.loader.startLoading({
      section: "summary",
      id: "rebilly-instruments-summary"
    });
    state.loader.startLoading({ id: "rebilly-instruments-form" });
    const [data] = await Promise.all([fetchData(), setupFramepay$1()]);
    state.data = data;
    events.dataReady.dispatch(state.data);
    state.i18n = setupI18n();
    if (state.options && !state.options.websiteId && ((_a = state.data.transaction) == null ? void 0 : _a.websiteId)) {
      state.options.websiteId = state.data.transaction.websiteId;
    } else if (state.options && !state.options.websiteId && ((_b = state.data.invoice) == null ? void 0 : _b.websiteId)) {
      state.options.websiteId = state.data.invoice.websiteId;
    }
    if (state.options && state.data.transaction && ((_c = state.data.transaction) == null ? void 0 : _c.type) === "setup") {
      state.options.transactionType = "setup";
    }
    if (state.form) {
      mountForm().then(() => determineFirstView());
    }
    if (state.summary) {
      mountSummary();
    }
    state.i18n();
    state.hasMounted = true;
    const clearFormOnError = (errorMessage) => {
      state.loader.stopLoading({ id: "rebilly-instruments-form" });
      removeForm();
      showError(state.translate.getTranslation(errorMessage), false);
    };
    const invoiceId = ((_d = state.options) == null ? void 0 : _d.invoiceId) || ((_f = (_e2 = state.data) == null ? void 0 : _e2.transaction) == null ? void 0 : _f.invoiceId);
    if (invoiceId && ((_g = state.data.invoice) == null ? void 0 : _g.isPaid)) {
      clearFormOnError("form.error.invoiceIsPaid");
    } else if (invoiceId && ((_h = state.data.invoice) == null ? void 0 : _h.isAbandoned)) {
      clearFormOnError("form.error.invoiceIsAbandoned");
    } else if (invoiceId && ((_i = state.data.invoice) == null ? void 0 : _i.isVoid)) {
      clearFormOnError("form.error.invoiceIsVoid");
    } else if (invoiceId && ((_j = state.data.invoice) == null ? void 0 : _j.isRefunded)) {
      clearFormOnError("form.error.invoiceIsRefunded");
    }
    const transactionId = ((_k = state.options) == null ? void 0 : _k.transactionId) || ((_m = (_l = state.data) == null ? void 0 : _l.transaction) == null ? void 0 : _m.id);
    if (transactionId && ((_o = (_n = state.data) == null ? void 0 : _n.transaction) == null ? void 0 : _o.transactionIsCompleted)) {
      clearFormOnError("form.error.transactionIsCompleted");
    }
    if (((_q = (_p = state.options) == null ? void 0 : _p.payout) == null ? void 0 : _q.payoutRequestId) && !((_r = state.data.payout) == null ? void 0 : _r.isPending)) {
      clearFormOnError("form.error.payoutNotPending");
    }
    let hasNoPaymentMethods = false;
    if (data.payout) {
      hasNoPaymentMethods = !((_s2 = data.readyToPayout) == null ? void 0 : _s2.length);
    } else {
      hasNoPaymentMethods = !((_t3 = data.readyToPay) == null ? void 0 : _t3.length);
    }
    if (hasNoPaymentMethods) {
      state.loader.stopLoading({ id: "rebilly-instruments-form" });
      showError(
        state.translate.getTranslation("form.error.noPaymentMethods"),
        false
      );
    }
  } catch (error2) {
    showError(error2, false);
    throw error2;
  }
  setupUserFlow({ state });
}
async function destroy() {
  Object.keys(iframes).forEach((frame) => {
    if (iframes.hasFrame(frame)) {
      iframes[frame].destroy();
      iframes[frame] = null;
    }
  });
  registeredListeners.removeAll();
  state.hasMounted = false;
  if (state.summary instanceof HTMLElement) {
    state.summary.textContent = "";
  }
  if (state.form instanceof HTMLElement) {
    state.form.textContent = "";
  }
  await cn$1.cancelAll();
  state.loader.clearAll();
}
async function update({ newOptions = {} } = {}) {
  if (!state.hasMounted) {
    throw Error(
      "Update method cannot be called before mounting instruments"
    );
  }
  const updatedOptions = merge$2({ ...state.options }, newOptions);
  await destroy();
  mount({
    form: state.form,
    summary: state.summary,
    ...updatedOptions
  });
}
class RebillyInstrumentsInstance {
  constructor() {
    this.state = state;
    this.iframes = iframes;
  }
  async mount(options) {
    await mount(options);
  }
  async destroy() {
    await destroy();
  }
  async update(newOptions) {
    await update({ newOptions });
  }
  async purchase(payload) {
    await purchase({ payload });
  }
  async setup(payload) {
    await setup({ payload });
  }
  async show(componentName, payload) {
    await show({ componentName, payload });
  }
  get version() {
    return `RebillyInstruments Ver.${"0.0.0"}`;
  }
  on(eventName, callback) {
    on({ eventName, callback });
  }
}
const index = new RebillyInstrumentsInstance();
export {
  index as default
};
